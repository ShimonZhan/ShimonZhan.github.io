<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://shimonzhan.com/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Shimon's Blog</title>
    <link>https://shimonzhan.com/</link>
    <description>Shimon的技术日志</description>
    <language>zh-CN</language>
    <pubDate>Sun, 15 May 2022 21:31:42 GMT</pubDate>
    <lastBuildDate>Sun, 15 May 2022 21:31:42 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <category>服务器</category>
    <category>教程</category>
    <category>Linux</category>
    <category>基础</category>
    <category>Node.js</category>
    <category>Vue</category>
    <category>前端</category>
    <category>JavaScript</category>
    <category>Git</category>
    <category>GitHub</category>
    <category>JSON</category>
    <category>Markdown</category>
    <category>Python</category>
    <category>TypeScript</category>
    <category>YAML</category>
    <item>
      <title>Nginx</title>
      <link>https://shimonzhan.com/software/nginx.html</link>
      <guid>https://shimonzhan.com/software/nginx.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Nginx</source>
      <description>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。
</description>
      <category>服务器</category>
      <pubDate>Fri, 13 Dec 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Nginx 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP / POP3 / SMTP 代理服务器。其特点是占有内存少，并发能力强，稳定性高，并且 Nginx 也拥有友好灵活的配置。</p>

<h2 id="启动-停止和重新加载配置" tabindex="-1"> 启动，停止和重新加载配置</h2>
<p>要启动 nginx，请运行可执行文件。一旦启动 nginx，就可以通过使用 <code>-s</code> 参数调用可执行文件来对其进行控制。使用以下语法:</p>
<div><pre><code>nginx -s signal
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中 <code>signal</code> 可能是以下之一:</p>
<ul>
<li>stop - 快速关机</li>
<li>quit — 正常关机</li>
<li>reload — 重新加载配置文件</li>
<li>reopen — 重新打开日志文件</li>
</ul>
<h2 id="配置文件的结构" tabindex="-1"> 配置文件的结构</h2>
<p>Nginx 由受配置文件中指定的指令控制的模块组成。指令分为简单指令和块指令。一个简单的指令由名称和参数组成，这些名称和参数之间用空格分隔，并以分号(<code>;</code>)结尾。块指令的结构与简单指令的结构相同，但是它不以分号结尾，而是带有一组用括号 (<code>{</code> 和 <code>}</code>) 括起来的附加指令。如果一个块指令在括号内可以有其他指令，则称为 context (例如: <code>events</code>, <code>http</code>, <code>server</code> 和 <code>location</code>)。</p>
<p>放置在任何 context 外部的配置文件中的指令都被视为在 main context 中。<code>events</code> 和 <code>http</code> 指令位于 <code>main</code> context 中，<code>server</code> 位于 <code>http</code> 中, 并且 <code>location</code> 在 <code>server</code> 中</p>
<p><code>#</code> 号后的其余行被视为注释。</p>
<h2 id="提供静态内容" tabindex="-1"> 提供静态内容</h2>
<p>Web 服务器的一项重要任务是分发文件(例如图像或静态 HTML 页面)。您将实现一个示例，其中将根据请求从不同的本地目录提供文件: <code>/data/www</code> (可能包含 HTML 文件)和 <code>/data/images</code>(包含图像)。这将需要编辑配置文件，并在带有两个位置块的 http 块内设置服务器块。</p>
<p>首先，创建 <code>/data/www</code> 目录，并将包含任何文本内容的 <code>index.html</code> 文件放入其中，并创建 <code>/data/images</code> 目录并将一些图像放入其中。</p>
<p>接下来，打开配置文件。默认配置文件已经包含了服务器块的几个示例，大部分已被注释掉。现在，注释掉所有这些块并启动一个新的服务器块:</p>
<div><pre><code><span><span>http</span></span> <span>{</span>
  <span><span>server</span></span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>通常，配置文件可以包括几个服务器块，这些服务器块通过它们侦听的端口和服务器名称来区分。一旦 nginx 决定了哪个服务器处理请求，它就会根据服务器块内定义的 location 指令的参数测试请求标头中指定的 URI。</p>
<p>将以下位置块添加到服务器块:</p>
<div><pre><code><span><span>location</span> /</span> <span>{</span>
  <span><span>root</span> /data/www</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>与请求中的 URI 相比，此位置块指定 “<code>/</code>” 前缀。对于匹配的请求，URI 将被添加到 root 指令中指定的路径，即 <code>/data/www</code>，以形成本地文件系统上所请求文件的路径。如果有多个匹配的位置块，nginx 将选择前缀最长的位置块。上面的位置块提供了最短的前缀，长度为 1，因此，只有在所有其他位置块均未提供匹配项时，才会使用该块。</p>
<p>接下来，添加第二个位置块:</p>
<div><pre><code><span><span>location</span> /images/</span> <span>{</span>
  <span><span>root</span> /data</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这将匹配以 <code>/images/</code> 开头的请求(位置 <code>/</code> 也匹配此类请求，但前缀较短)。</p>
<p>服务器块的最终配置应如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>root</span> /data/www</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这已经是服务器的工作配置，可以在标准端口 <code>80</code> 上侦听，并且可以在本地计算机上的 <code>http://localhost/</code> 上访问。响应以 <code>/images/</code> 开头的 URI 请求，服务器将从 <code>/data/images</code> 目录中发送文件。例如，为响应 <code>http://localhost/images/example.png</code> 请求，nginx 将发送文件 <code>/data/images/example.png</code>。如果该文件不存在，nginx 将发送一个注明 404 错误的响应。URI 不以 <code>/images/</code> 开头的请求将被映射到 <code>/data/www</code> 目录。例如，nginx 会响应 <code>http://localhost/some/example.html</code> 请求发送 <code>/data/www/some/example.html</code> 文件。</p>
<p>要应用新配置，请启动 nginx (如果尚未启动)，或通过执行以下命令向 nginx 的主进程发送 <code>reload</code> 信号:</p>
<div><pre><code>nginx -s reload
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果某些东西无法按预期工作，则可以尝试在目录 <code>/usr/local/nginx/logs</code> 或目录 <code>/var/log/nginx</code> 中的 access.log 和 error.log 文件中找出原因。。</p>
<h2 id="设置简单的代理服务器" tabindex="-1"> 设置简单的代理服务器</h2>
<p>Nginx 的一种常用用法是将其设置为代理服务器，这意味着服务器可以接收请求，将请求传递给代理服务器，从请求中检索响应并将它们发送给客户端。</p>
<p>我们将配置一个基本的代理服务器，该服务器为图像请求和本地目录中的文件提供服务，并将所有其他请求发送到代理服务器。在此示例中，两个服务器都将在单个 nginx 实例上定义。</p>
<p>首先，通过向 nginx 的配置文件中添加另一个 <code>server</code> 块来定义代理服务器，其内容如下:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>listen</span> <span>8080</span></span><span>;</span>
  <span><span>root</span> /data/up1</span><span>;</span>

  <span><span>location</span> /</span> <span>{</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将是一个简单的服务器，它在端口 8080 上侦听 (以前，自从使用标准端口 80 以来，未指定 listen 指令) 并将所有请求映射到本地文件系统的 <code>/data/up1</code> 目录中。创建此目录，并将 <code>index.html</code> 文件放入其中。请注意，根指令位于服务器上下文中。当选择用于服务请求的位置块不包括自己的根指令时，将使用这种根指令。</p>
<p>接下来，使用上一部分中的服务器配置并对其进行修改以使其成为代理服务器配置。在第一个位置块中，将 <code>proxy_pass</code> 指令与参数中指定的代理服务器的协议，名称和端口放在一起 (在本例中为 <code>http://localhost:8080</code> ):</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080</span><span>;</span>
  <span>}</span>

  <span><span>location</span> /images/</span> <span>{</span>
    <span><span>root</span> /data</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们将修改第二个 location 块，该位置块当前将带有 <code>/images/</code> 前缀的请求映射到 <code>/data/images</code> 目录下的文件，以使其与具有典型文件扩展名的图像的请求相匹配。修改后的位置块如下所示:</p>
<div><pre><code><span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
  <span><span>root</span> /data/images</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>该参数是一个正则表达式，它匹配以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的所有 URI。正则表达式应以 <code>~</code> 开头。相应的请求将被映射到 <code>/ data/images</code> 目录。</p>
<p>当 nginx 选择一个 <code>location</code> 块来服务请求时，它首先检查指定前缀的 <code>location</code> 指令，记住带有最长前缀的 <code>location</code>，然后检查正则表达式。如果存在与正则表达式匹配的内容，nginx 会选择该 “<code>location</code>”，否则，它将选择之前记住的位置。</p>
<p>代理服务器的最终配置如下所示:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>proxy_pass</span> http://localhost:8080/</span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>该服务器将过滤以 <code>.gif</code>，<code>.jpg</code> 或 <code>.png</code> 结尾的请求，并将它们映射到目录 <code>/data/images</code>(通过将 URI 添加到根指令的参数)，并将所有其他请求传递给上面配置的代理服务器。</p>
<p>要应用新配置，请按照前面几节的说明将重载信号发送到 nginx。</p>
<p>还有许多其他指令可用于进一步配置代理连接。</p>
<h2 id="设置-fastcgi-代理" tabindex="-1"> 设置 FastCGI 代理</h2>
<p>Nginx 可用于将请求路由到 FastCGI 服务器，该服务器运行使用各种框架和编程语言 (例如 PHP) 构建的应用程序。</p>
<p>与 FastCGI 服务器一起使用的最基本的 Nginx 配置包括使用 <code>fastcgi_pass</code> 指令而不是 <code>proxy_pass</code> 指令和 <code>fastcgi_param</code> 指令来设置传递给 FastCGI 服务器的参数。假设 FastCGI 服务器可以在 <code>localhost:9000</code> 上访问。以上一节中的代理配置为基础，用 <code>fastcgi_pass</code> 指令替换 <code>proxy_pass</code> 指令，并将参数更改为 <code>localhost:9000</code>。在 PHP 中， <code>SCRIPT_FILENAME</code> 参数用于确定脚本名称，而 <code>QUERY_STRING</code> 参数用于传递请求参数。配置的结果为:</p>
<div><pre><code><span><span>server</span></span> <span>{</span>
  <span><span>location</span> /</span> <span>{</span>
    <span><span>fastcgi_pass</span>  localhost:9000</span><span>;</span>
    <span><span>fastcgi_param</span> SCRIPT_FILENAME <span>$document_root</span><span>$fastcgi_script_name</span></span><span>;</span>
    <span><span>fastcgi_param</span> QUERY_STRING    <span>$query_string</span></span><span>;</span>
  <span>}</span>

  <span><span>location</span> ~ \.(gif|jpg|png)$</span> <span>{</span>
    <span><span>root</span> /data/images</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这将设置一个服务器，该服务器将通过 FastCGI 协议将除静态图像请求以外的所有请求路由到运行在 <code>localhost:9000</code> 上的代理服务器。</p>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://docs.nginx.com/nginx/admin-guide/" target="_blank" rel="noopener noreferrer">点击此处</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>代码学习教程</title>
      <link>https://shimonzhan.com/code/language/</link>
      <guid>https://shimonzhan.com/code/language/</guid>
      <source url="https://shimonzhan.com/rss.xml">代码学习教程</source>
      <category>教程</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li><a href="/code/language/learning.html">如何学习一门语言</a></li>
</ul>
<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/language/js/">JavaScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/typescript/">TypeScript 教程</a></p>
</li>
<li>
<p><a href="/code/language/python/">Python 教程</a> (编写中...)</p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744" target="_blank" rel="noopener noreferrer">Java 教程</a>(廖雪峰的博客)</p>
</li>
<li>
<p><a href="/code/language/markdown/">Markdown 教程</a></p>
</li>
<li>
<p><a href="/code/language/yaml/">YAML 教程</a></p>
</li>
<li>
<p><a href="/code/language/json/">JSON 教程</a></p>
</li>
</ul>
<h2 id="linter" tabindex="-1"> Linter</h2>
<ul>
<li><a href="/code/language/linter/">Linter 介绍</a></li>
</ul>
<div><p>提示</p>
<p>C 、C++、Java、PHP 正在编写中...</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>如何学习一门计算机语言</title>
      <link>https://shimonzhan.com/code/language/learning.html</link>
      <guid>https://shimonzhan.com/code/language/learning.html</guid>
      <source url="https://shimonzhan.com/rss.xml">如何学习一门计算机语言</source>
      <category>教程</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="如何学习一门计算机语言" tabindex="-1"> 如何学习一门计算机语言</h1>
<div><p>提示</p>
<p>学习一门语言的基本顺序是:</p>
<ul>
<li>了解数据结构</li>
<li>了解变量声明与赋值</li>
<li>了解判断和循环体结构</li>
<li>了解函数声明</li>
<li>了解输入输出</li>
</ul>
<p>本部分将以 JS 作为示例，展示什么是一门计算机语言，应该如何学习它们。</p>
</div>
<h2 id="基础" tabindex="-1"> 基础</h2>
<p>首先，任何语言都是由一些基本结构组成的，下面介绍几乎所有语言共有的一些概念:</p>
<h3 id="语句" tabindex="-1"> 语句</h3>
<p>语句可以简单理解为一个操作，它可以是赋值，也可以是执行，还可以是介于或者是可以归类到两者上的判断、声明、标记等。</p>
<p>请注意一条语句通常是一个计算机语言描述的最小操作。</p>
<p>比如:</p>
<div><pre><code><span>let</span> a <span>=</span> <span>1</span><span>;</span> <span>// 赋值</span>
<span>alert</span><span>(</span><span>"Hello word"</span><span>)</span><span>;</span> <span>// 调用函数 执行操作</span>
<span>if</span> <span>(</span>a <span>></span> <span>2</span><span>)</span> <span>{</span>
  <span>// 判断</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="代码块" tabindex="-1"> 代码块</h3>
<p>通常情况下，在有了语句概念后，我们就要使用不同的语句顺序，完成不同的操作，但是某些操作总是固定的。</p>
<p>比如回家，总是 “掏出钥匙”-“插入钥匙”-“转动钥匙”-“开启房门”-“拔出钥匙”-“进入”-“关闭房门” 。</p>
<p>这些步骤每一步都可以理解为一个语句，但是由于其顺序基本是固定的，我们就可以设计一个代码块，来约束它们。</p>
<div><pre><code>{
  “掏出钥匙”;
  “插入钥匙”;
  “转动钥匙”;
  “开启房门”;
  “拔出钥匙”;
  “进入”;
  “关闭房门”;
}
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>大多数语言会使用 <code>{ }</code> 的形式，少数语言会使用统一的缩进进行表达。</p>
<h2 id="数据结构" tabindex="-1"> 数据结构</h2>
<p>计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。</p>
<p>任何语言都是操作、计算(处理)、生成数据的。数据结构是一门语言存放数据的方式。不同的数据，需要定义不同的数据类型。了解了数据结构就了解了一门语言可以存储或处理何种数据。</p>
<p>大多数语言都包含了以下的一种或多种内容:</p>
<ul>
<li>
<p>数字:</p>
<p>不同语言对数字有不同的处理方式，少数语言可能只有数字这一种类型，一些语言可能会拆分成整数与浮点数。一些底层语言(涉及到内存)可能会魔鬼的将数字拆分为: 整型、浮点数、无符号整型、长整型、无符号长整形、长浮点数。(说的就是您，C 语言)</p>
</li>
<li>
<p>字符串:</p>
<p>一些语言只有字符串这个概念，一些语言分为字符和字符串这个概念。</p>
</li>
<li>
<p>布尔值:</p>
<p>几乎所有语言都有布尔值，布尔值只有真和假两种类型。大多数会表示为 <code>true</code> 和 <code>false</code>，少数会表示为 <code>True</code> 和 <code>False</code>。</p>
</li>
<li>
<p>数组:</p>
<p>大部分语言都有数组 (Array) 这个概念，它是一个有序的元素集合。很多底层语言就是靠数组实现的字符串 (因为字符串长度不固定)。在数组中，每个元素具有标号，从 0 开始依次递增。</p>
<p>一些语言还有 Set 这个概念，Set 表示的是无序元素集合，所有元素没有先后与标号的概念，自然 Set 也无法存入相同的元素。</p>
</li>
<li>
<p>对象:</p>
<p>大部分语言的对象 (Object) 都是由键值对组成的，它是一个由键标记的元素集合，可以使用特定的键名写入或读取其对应的值。</p>
<p>一些产生较晚的语言，将对象改为 Map，Map 表达一个映射，将对应的键映射到对应的值上。</p>
</li>
<li>
<p>类:</p>
<p>类 (Class) 是一个内容集合，它包含了自己的构造器、变量与方法。类在声明后，可以很轻松的使用构造器创建一个新的实例。每个实例可以用其内部的变量维护或表达一个状态，并可以使用它自身的方法来读取或是改变自己的状态。不同的类之间还可以进行继承。</p>
</li>
</ul>
<h2 id="变量" tabindex="-1"> 变量</h2>
<p>一个<strong>变量</strong>是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。</p>
<p>下面的语句创建(换句话说，<strong>声明</strong>或者<strong>定义</strong>)了一个名称为“message”的变量:</p>
<div><pre><code><span>let</span> message<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在有了变量之后，我们就可以将刚了解的数据结构赋值给变量，以变量来代替这些数据。</p>
<div><pre><code><span>let</span> user <span>=</span> <span>"John"</span><span>;</span>
<span>let</span> age <span>=</span> <span>25</span><span>;</span>
<span>let</span> message <span>=</span> <span>"Hello"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="条件" tabindex="-1"> 条件</h2>
<p>条件运算符用于判断，通过判断一个条件的真假，来执行不同的逻辑。这是每一门语言逻辑结构的基础。</p>
<div><pre><code><span>let</span> year <span>=</span> <span>2015</span><span>;</span>
<span>if</span> <span>(</span>year <span>&lt;</span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too early..."</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span>year <span>></span> <span>2015</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Too late"</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Exactly!"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="循环" tabindex="-1"> 循环</h2>
<p>循环运算符的作用，是在条件控制下，零次或多次执行特定代码块。它使得重复执行成为了可能。</p>
<div><pre><code><span>let</span> result <span>=</span> <span>0</span><span>;</span>
<span>let</span> i <span>=</span> <span>1</span><span>;</span>

<span>while</span> <span>(</span>i <span>&lt;=</span> <span>100</span><span>)</span> <span>{</span>
  <span>// 计算1+2+3+...+100的结果</span>
  i <span>=</span> i <span>+</span> <span>1</span><span>;</span>
  result <span>=</span> result <span>+</span> i<span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>// 结果为 0、1、2</span>
  <span>alert</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="函数" tabindex="-1"> 函数</h2>
<p>函数是程序的主要“构建模块”，</p>
<p>创建函数时，需要声明函数内容，函数内容由一系列语句(代码块) 构成。在声明函数后，使用函数即可多次调用一段代码。</p>
<p>例如:</p>
<div><pre><code><span>function</span> <span>showMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>alert</span><span>(</span><span>"Hello everyone!"</span><span>)</span><span>;</span>
<span>}</span> <span>// 声明一个函数</span>

<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 调用它</span>
<span>showMessage</span><span>(</span><span>)</span><span>;</span> <span>// 可以在任意时刻调用它</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>同时函数可以通过接受参数的形式来根据情况返回不同的结果，比如这是一个简单的求和函数。</p>
<div><pre><code><span>function</span> <span>sum</span><span>(</span><span>sum1<span>,</span> sum2</span><span>)</span> <span>{</span>
  <span>return</span> sum1 <span>+</span> sum2<span>;</span>
<span>}</span>

<span>sum</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>)</span><span>;</span> <span>// return 3</span>
<span>sum</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span> <span>// return 11</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Linux</title>
      <link>https://shimonzhan.com/code/linux/</link>
      <guid>https://shimonzhan.com/code/linux/</guid>
      <source url="https://shimonzhan.com/rss.xml">Linux</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="linux-教程" tabindex="-1"> Linux 教程</h2>
<ul>
<li>
<p><a href="/code/linux/intro/">Linux 介绍</a></p>
<ul>
<li>
<p><a href="/code/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="/code/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="/code/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="/code/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="/code/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/linux/file/">Linux 文件</a></p>
<ul>
<li>
<p><a href="/code/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="/code/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="/code/linux/file/mount.html">挂载</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/code/linux/command/">Linux 命令</a></p>
<ul>
<li>
<p><a href="/code/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="/code/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="/code/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="/code/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="/code/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="/code/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="/code/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="/code/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="ubuntu" tabindex="-1"> ubuntu</h2>
<ul>
<li><a href="/code/linux/ubuntu/">点击前往</a></li>
</ul>
<h2 id="centos" tabindex="-1"> CentOS</h2>
<ul>
<li><a href="/code/linux/centos.html">点击前往</a></li>
</ul>
<h2 id="wsl" tabindex="-1"> WSL</h2>
<ul>
<li><a href="/code/linux/WSL.html">点击前往</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>WSL</title>
      <link>https://shimonzhan.com/code/linux/WSL.html</link>
      <guid>https://shimonzhan.com/code/linux/WSL.html</guid>
      <source url="https://shimonzhan.com/rss.xml">WSL</source>
      <description>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。
</description>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>

<h2 id="ubuntu" tabindex="-1"> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2 id="wsl-文件位置" tabindex="-1"> WSL 文件位置</h2>
<div><pre><code>C:\Users\%USERNAME%\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="重启-wsl" tabindex="-1"> 重启 WSL</h2>
<p>使用</p>
<div><pre><code>net stop LxssManager
</code></pre><div aria-hidden="true"><div></div></div></div><p>和</p>
<div><pre><code>net start LxssManager
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CentOS 教程</title>
      <link>https://shimonzhan.com/code/linux/centos.html</link>
      <guid>https://shimonzhan.com/code/linux/centos.html</guid>
      <source url="https://shimonzhan.com/rss.xml">CentOS 教程</source>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="管理工具" tabindex="-1"> 管理工具</h2>
<ul>
<li>yum (Centos 7)</li>
<li>dnf (Centos 8)</li>
</ul>
<h2 id="yarn" tabindex="-1"> yarn</h2>
<div><pre><code><span>curl</span> --silent --location https://dl.yarnpkg.com/rpm/yarn.repo <span>|</span> <span>sudo</span> <span>tee</span> /etc/yum.repos.d/yarn.repo

<span>sudo</span> yum <span>install</span> <span>yarn</span>
<span>## OR ##</span>
<span>sudo</span> dnf <span>install</span> <span>yarn</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>测试是否安装成功:</p>
<div><pre><code><span>yarn</span> --version
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ssh</title>
      <link>https://shimonzhan.com/code/linux/ssh.html</link>
      <guid>https://shimonzhan.com/code/linux/ssh.html</guid>
      <source url="https://shimonzhan.com/rss.xml">ssh</source>
      <category>基础</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用密码登录" tabindex="-1"> 使用密码登录</h2>
<ol>
<li>
<p>执行以下命令，连接 Linux 云服务器。</p>
<div><pre><code><span>ssh</span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
</li>
<li>
<p>输入已获取的密码，按 Enter，即可完成登录。</p>
</li>
</ol>
<h2 id="使用密钥登录" tabindex="-1"> 使用密钥登录</h2>
<ol>
<li>
<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>
<div><pre><code><span>chmod</span> <span>400</span> <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>执行以下命令，进行远程登录。</p>
<div><pre><code><span>ssh</span> -i <span>&lt;</span>下载的与云服务器关联的私钥的绝对路径<span>></span> <span>&lt;</span>username<span>></span>@<span>&lt;</span>hostname or IP address<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
<p>例如，执行 <code>ssh -i &quot;id_rsa&quot; ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>
</li>
</ol>
<h2 id="断开链接" tabindex="-1"> 断开链接</h2>
<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://shimonzhan.com/code/node-js/</link>
      <guid>https://shimonzhan.com/code/node-js/</guid>
      <source url="https://shimonzhan.com/rss.xml">Node.js</source>
      <description>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。
</description>
      <category>Node.js</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>

<h2 id="教程目录" tabindex="-1"> 教程目录</h2>
<ul>
<li>
<p><a href="/code/node-js/intro.html">Node.js 介绍</a></p>
</li>
<li>
<p><a href="/code/node-js/install.html">Node.js 与 npm 安装</a></p>
</li>
<li>
<p><a href="/code/node-js/environment.html">Node.js 环境</a></p>
</li>
<li>
<p><a href="/code/node-js/program.html">编程</a></p>
</li>
<li>
<p><a href="/code/node-js/module.html">Node.js 模块</a></p>
</li>
</ul>
<p>以上，就是 Node.js 的简易介绍，系统学习可以查看下方的详细教程。</p>
<h2 id="初学者教程" tabindex="-1"> 初学者教程</h2>
<ul>
<li>
<p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener noreferrer">Node.js 入门</a></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn/nodejs/" target="_blank" rel="noopener noreferrer">W3CSchool</a></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/" target="_blank" rel="noopener noreferrer">地址</a></li>
</ul>
<h2 id="yarn" tabindex="-1"> Yarn</h2>
<p>快速、可靠、安全的依赖管理工具。</p>
<ul>
<li>
<p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p>
</li>
<li>
<p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p>
</li>
<li>
<p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
</ul>
<h3 id="命令" tabindex="-1"> 命令</h3>
<ul>
<li>
<p><code>yarn install</code>: 执行安装</p>
</li>
<li>
<p><code>yarn upgrade</code>: 执行升级</p>
</li>
<li>
<p><code>yarn add &lt;package&gt;</code>: 添加一个包</p>
</li>
<li>
<p><code>yarn config set cache-folder &lt;path&gt;</code>: 更改缓存文件夹</p>
</li>
<li>
<p><code>yarn config set registry &lt;registry&gt;</code>: 更改源</p>
<div><p>提示</p>
<p>在国内，建议换成淘宝源 <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener noreferrer">https://registry.npm.taobao.org</a></p>
<p>即执行</p>
<div><pre><code><span>yarn</span> config <span>set</span> registry https://registry.npm.taobao.org
</code></pre><div aria-hidden="true"><div></div></div></div></div>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>搭建 Node 开发环境</title>
      <link>https://shimonzhan.com/code/node-js/environment.html</link>
      <guid>https://shimonzhan.com/code/node-js/environment.html</guid>
      <source url="https://shimonzhan.com/rss.xml">搭建 Node 开发环境</source>
      <description>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Shimon Zhan 隆重向大家推荐 Node.js 集成开发环境: Visual Studio Code。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。
</description>
      <category>Node.js</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Shimon Zhan 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>

<div><p>相关信息</p>
<p>有关 VS Code 使用教程请<a href="/software/vscode/">访问这里</a></p>
</div>
<h2 id="运行和调试-javascript" tabindex="-1"> 运行和调试 JavaScript</h2>
<p>在 VS Code 中，我们可以非常方便地运行 JavaScript 文件。</p>
<p>VS Code 以文件夹作为工程目录 (Workspace Dir)，所有的 JavaScript 文件都存放在该目录下。此外，VS Code 在工程目录下还需要一个 <code>.vscode</code> 的配置目录，里面存放里 VS Code 需要的配置文件。</p>
<p>假设我们在 <code>C:\Work\</code> 目录下创建了一个 hello 目录作为工程目录，并编写了一个 <code>hello.js</code> 文件，则该工程目录的结构如下:</p>
<div><pre><code>hello/ &lt;-- workspace dir
|
+- hello.js &lt;-- JavaScript file
|
+- .vscode/ &lt;-- VS Code config
|
+- launch.json &lt;-- VS Code config file for JavaScript
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以用 VS Code 快速创建 <code>launch.json</code>，然后修改如下:</p>
<div><pre><code><span>{</span>
  <span>"version"</span><span>:</span> <span>"0.2.0"</span><span>,</span>
  <span>"configurations"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"name"</span><span>:</span> <span>"Run hello.js"</span><span>,</span>
      <span>"type"</span><span>:</span> <span>"node"</span><span>,</span>
      <span>"request"</span><span>:</span> <span>"launch"</span><span>,</span>
      <span>"program"</span><span>:</span> <span>"${workspaceRoot}/hello.js"</span><span>,</span>
      <span>"stopOnEntry"</span><span>:</span> <span>false</span><span>,</span>
      <span>"args"</span><span>:</span> <span>[</span><span>]</span><span>,</span>
      <span>"cwd"</span><span>:</span> <span>"${workspaceRoot}"</span><span>,</span>
      <span>"preLaunchTask"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeExecutable"</span><span>:</span> <span>null</span><span>,</span>
      <span>"runtimeArgs"</span><span>:</span> <span>[</span><span>"--nolazy"</span><span>]</span><span>,</span>
      <span>"env"</span><span>:</span> <span>{</span>
        <span>"NODE_ENV"</span><span>:</span> <span>"development"</span>
      <span>}</span><span>,</span>
      <span>"externalConsole"</span><span>:</span> <span>false</span><span>,</span>
      <span>"sourceMaps"</span><span>:</span> <span>false</span><span>,</span>
      <span>"outDir"</span><span>:</span> <span>null</span>
    <span>}</span>
  <span>]</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>有了配置文件，即可使用 VS Code 调试 JavaScript。</p>
<h2 id="视频演示" tabindex="-1"> 视频演示</h2>
<ul>
<li><a href="https://www.bilibili.com/video/av5827351/" target="_blank" rel="noopener noreferrer">视频演示</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装 Node.js</title>
      <link>https://shimonzhan.com/code/node-js/install.html</link>
      <guid>https://shimonzhan.com/code/node-js/install.html</guid>
      <source url="https://shimonzhan.com/rss.xml">安装 Node.js</source>
      <description>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。
</description>
      <category>Node.js</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>

<h2 id="安装-node-js" tabindex="-1"> 安装 Node.js</h2>
<p>目前 Node.js 的 LTS 版本是 16.14.2。首先，从 Node.js 官网下载对应平台的安装程序。点击 LTS 版本的下载按钮。</p>
<ul>
<li><a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js官网</a></li>
</ul>
<h3 id="安装过程" tabindex="-1"> 安装过程</h3>
<ul>
<li>
<p>在 Windows 上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>
<p>在安装过程中，无需勾选 &quot;Automatically install the necessary tools&quot;。选中此项会在电脑中安装 VS 等日常开发使用不到的软件。</p>
<p>安装完成后，在 Windows 环境下，请打开命令提示符，然后输入 <code>node -v</code> ，如果安装正常，您应该看到 <code>v12.18.0</code> 这样的输出:</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>IEUser<span>></span>node -v
v12.18.0
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>继续在命令提示符输入 node，此刻您将进入 Node.js 的交互环境。在交互环境下，您可以输入任意 JavaScript 语句，例如 <code>100 + 200</code>，回车后将得到输出结果。</p>
<p>要退出 Node.js 环境，连按两次 <code>Ctrl+C</code> 。</p>
</li>
<li>
<p>在 Mac 或 Linux 环境下，请打开终端，然后输入 <code>node -v</code>，您应该看到如下输出:</p>
<div><pre><code>$ <span>node</span> -v
v12.18.0
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
</ul>
<h2 id="npm" tabindex="-1"> npm</h2>
<p>在正式开始 Node.js 学习之前，我们先认识一下 npm。</p>
<p>Npm 是什么东东? npm 其实是 Node.js 的包管理工具(package manager)。</p>
<p>为啥我们需要一个包管理工具呢? 因为我们在 Node.js 上开发时，会用到很多别人写的 JavaScript 代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生: 大家都把自己开发的模块打包后放到 npm 官网上，如果要使用，直接通过 npm 安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块 A，而模块 A 又依赖于模块 B，模块 B 又依赖于模块 X 和模块 Y，npm 可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm 究竟在哪?</p>
<p>其实 npm 已经在 Node.js 安装的时候顺带装好了。我们在命令提示符或者终端输入 <code>npm -v</code>，应该看到类似的输出:</p>
<div><pre><code>C:<span>\</span><span>></span>npm -v
<span>6.13</span>.1
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><blockquote>
<p>如果版本号太小，说明 npm 版本较低，请使用此命令升级到最新版本: <code>npm install -g npm</code>。</p>
</blockquote>
<p>如果直接输入 <code>npm</code>，您会看到类似下面的输出:</p>
<div><pre><code>C:<span>\</span><span>></span> <span>npm</span>

Usage: <span>npm</span> <span>&lt;</span>command<span>></span>

where <span>&lt;</span>command<span>></span> is one of:
    <span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的一大堆文字告诉您，npm 需要跟上命令。现在我们不用关心这些命令，后面会一一讲到。目前，您只需要确保 npm 正确安装了，能运行就行。</p>
<h2 id="墙" tabindex="-1"> 墙</h2>
<p>大家都知道天朝是有墙的，有的时候，访问国外的 Node.js 服务器可能会十分缓慢以至于您想把它砸了。</p>
<p>所以贴心的马云爸爸提供了淘宝镜像，淘宝镜像有一个自己定制的 <code>cnpm</code> 工具，服务器在国内，十分快捷。不过大家在使用 <code>cnpm</code> 安装模块之后再使用 npm 安装会报错，只能重新删掉 <code>node_modules</code> 文件夹重新执行 <code>npm install</code> 全新安装才会不报错。</p>
<div><p>注意</p>
<p>如果大家可以使用 <code>npm</code> 命令，非常不建议大家使用 <code>cnpm</code> 命令安装模块。</p>
</div>
<p>安装 <code>cnpm</code> 的命令如下:</p>
<div><pre><code><span>npm</span> <span>install</span> -g cnpm --registry<span>=</span>https://registry.npm.taobao.org
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="小结" tabindex="-1"> 小结</h2>
<p>请在本机安装 Node.js 环境，并确保 Node.js 和 npm 能正常运行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://shimonzhan.com/code/node-js/intro.html</link>
      <guid>https://shimonzhan.com/code/node-js/intro.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Node.js</source>
      <description>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。
Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。
</description>
      <category>Node.js</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>
<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>

<p>众所周知，在 Netscape 设计出 JavaScript 后的短短几个月，JavaScript 事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过 IE 击败了 Netscape 后一统桌面，结果几年时间，浏览器毫无进步。(2001 年推出的古老的 IE 6 到今天仍然有人在使用! )</p>
<p>没有竞争就没有发展。微软认为 IE6 浏览器已经非常完善，几乎没有可改进之处，然后解散了 IE6 开发团队! 而 Google 却认为支持现代 Web 应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行 JavaScript 的引擎性能还可提升 10 倍。</p>
<p>先是 Mozilla 借助已壮烈牺牲的 Netscape 遗产在 2002 年推出了 Firefox 浏览器，紧接着 Apple 于 2003 年在开源的 KHTML 浏览器的基础上推出了 WebKit 内核的 Safari 浏览器，不过仅限于 Mac 平台。</p>
<p>随后，Google 也开始创建自家的浏览器。他们也看中了 WebKit 内核，于是基于 WebKit 内核推出了 Chrome 浏览器。</p>
<p>Chrome 浏览器是跨 Windows 和 Mac 平台的，并且，Google 认为要运行现代 Web 应用，浏览器必须有一个性能非常强劲的 JavaScript 引擎，于是 Google 自己开发了一个高性能 JavaScript 引擎，名字叫 V8，以 BSD 许可证开源。</p>
<p>现代浏览器大战让微软的 IE 浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队! 回过头再追赶却发现，支持 HTML5 的 WebKit 已经成为手机端的标准了，IE 浏览器从此与主流移动端设备绝缘。</p>
<h2 id="浏览器大战和-node-js-的关系" tabindex="-1"> 浏览器大战和 Node.js 的关系</h2>
<p>话说有个叫 Ryan Dahl 的歪果仁，他的工作是用 C/C++写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发 Web 服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript 引擎。让 Google 投资去优化 V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在 2009 年，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。虽然名字很土，但是，Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</p>
<h2 id="在-node-js-上运行的-javascript-相比其他后端开发语言的优势" tabindex="-1"> 在 Node.js 上运行的 JavaScript 相比其他后端开发语言的优势</h2>
<p>最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</p>
<p>其次，JavaScript 语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉 JavaScript 就是个“玩具语言”。但是，在 Node.js 环境下，通过模块化的 JavaScript 代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的 ECMAScript 6 标准，可以完全满足工程上的需求。</p>
<blockquote>
<p>我还听说过 io.js，这又是什么鬼?</p>
</blockquote>
<p>因为 Node.js 是开源项目，虽然由社区推动，但幕后一直由 Joyent 公司资助。由于一群开发者对 Joyent 公司的策略不满，于 2014 年从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</p>
<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent 公司表示要和解，于是，io.js 项目又决定回归 Node.js。</p>
<p>具体做法是将来 io.js 将首先添加新的特性，如果大家测试用得爽，就把新特性加入 Node.js。Io.js 是“尝鲜版”，而 Node.js 是线上稳定版，相当于 Fedora Linux 和 RHEL 的关系。</p>
<p>本章教程的所有代码都在 Node.js 上调试通过。如果您要尝试 io.js 也是可以的，不过两者如果遇到一些区别请自行查看 io.js 的文档。</p>
<h2 id="node-js-相关链接" tabindex="-1"> Node.js 相关链接</h2>
<ul>
<li>
<p><a href="https://nodejs.org/en/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></p>
</li>
<li>
<p><a href="https://nodejs.org/en/docs/" target="_blank" rel="noopener noreferrer">Node.js 最新文档</a></p>
</li>
<li>
<p><a href="https://nodejs.org/dist/latest-v14.x/docs/api/" target="_blank" rel="noopener noreferrer">Node.js 最新 API 文档</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>模块</title>
      <link>https://shimonzhan.com/code/node-js/module.html</link>
      <guid>https://shimonzhan.com/code/node-js/module.html</guid>
      <source url="https://shimonzhan.com/rss.xml">模块</source>
      <description>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。
为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 .js 文件就称之为一个模块(module)。
使用模块有什么好处?
最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。
使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。
</description>
      <category>Node.js</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>
<p>使用模块有什么好处?</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>

<p>在上一节，我们编写了一个 hello.js 文件，这个 hello.js 文件就是一个模块，模块的名字就是文件名(去掉.js 后缀)，所以 hello.js 文件就是名为 hello 的模块。</p>
<p>我们把 hello.js 改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>", "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>函数 <code>greet()</code> 是我们在 hello 模块中定义的，您可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数 <code>greet</code> 作为模块的输出暴露出去，这样其他模块就可以使用 <code>greet</code> 函数了。</p>
<p>问题是其他模块怎么使用 hello 模块的这个 <code>greet</code> 函数呢? 我们再编写一个 <code>main.js</code> 文件，调用 <code>hello</code> 模块的 <code>greet</code> 函数:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>// 引入hello模块:</span>
<span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>

<span>const</span> s <span>=</span> <span>"Michael"</span><span>;</span>

<span>greet</span><span>(</span>s<span>)</span><span>;</span> <span>// Hello, Michael!</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意到引入 <code>hello</code> 模块用 Node.js 提供的 <code>require</code> 函数:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>引入的模块作为变量保存在 <code>greet</code> 变量中，那 greet 变量到底是什么东西? 其实变量 <code>greet</code> 就是在 <code>hello.js</code> 中我们用 <code>module.exports = greet;</code> 输出的 <code>greet</code> 函数。所以，<code>main.js</code> 就成功地引用了 <code>hello.js</code> 模块中定义的 <code>greet()</code> 函数，接下来就可以直接使用它了。</p>
<p>在使用 <code>require()</code> 引入模块的时候，请注意模块的相对路径。因为 main.js 和 hello.js 位于同一个目录，所以我们用了当前目录.:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span> <span>// 不要忘了写相对目录!</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果只写模块名:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>则 Node.js 会依次在内置模块、全局模块和当前模块下查找 hello.js，您很可能会得到一个错误:</p>
<div><pre><code>module<span>.</span>js
    <span>throw</span> err<span>;</span>
          <span>^</span>
<span>Error</span><span>:</span> Cannot find module <span>'hello'</span>
    at Function<span>.</span>Module<span>.</span>_resolveFilename
    at Function<span>.</span>Module<span>.</span>_load
    <span>...</span>
    at Function<span>.</span>Module<span>.</span>_load
    at Function<span>.</span>Module<span>.</span>runMain
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>遇到这个错误，您要检查:</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h2 id="commonjs-规范" tabindex="-1"> CommonJS 规范</h2>
<p>这种模块加载机制被称为 <code>CommonJS</code> 规范。在这个规范下，每个 <code>.js</code> 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code> 和 <code>main.js</code> 都申明了全局变量 <code>const s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量(函数也是变量)，可以用 <code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用 <code>const ref = require('module_name');</code> 就拿到了引用模块的变量。</p>
<h2 id="总结" tabindex="-1"> 总结</h2>
<p>要在模块中对外输出变量，用:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> variable<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用:</p>
<div><pre><code><span>const</span> foo <span>=</span> <span>require</span><span>(</span><span>"other_module"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h2 id="深入了解模块原理" tabindex="-1"> 深入了解模块原理</h2>
<p>如果您想详细地了解<strong>CommonJS</strong>的模块实现原理，请继续往下阅读。如果不想了解，请结束阅读。</p>
<p>当我们编写 JavaScript 代码时，我们可以申明全局变量:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"global"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在浏览器中，大量使用全局变量可不好。如果您在 <code>a.js</code> 中使用了全局变量 s，那么，在 <code>b.js</code> 中也使用全局变量 s，将造成冲突，<code>b.js</code> 中对 s 赋值会改变 <code>a.js</code> 的运行逻辑。</p>
<p>也就是说，JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那 Node.js 是如何实现这一点的?</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js 也并不会增加任何 JavaScript 语法。实现“模块”功能的奥妙就在于 JavaScript 是一种函数式编程语言，它支持闭包。如果我们把一段 JavaScript 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的 <code>hello.js</code> 代码是这样的:</p>
<div><pre><code><span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
<span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>Node.js 加载了 hello.js 后，它可以把代码包装一下，变成这样执行:</p>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>const</span> s <span>=</span> <span>"Hello"</span><span>;</span>
  <span>const</span> name <span>=</span> <span>"world"</span><span>;</span>

  console<span>.</span><span>log</span><span>(</span>s <span>+</span> <span>" "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>// hello.js代码结束</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这样一来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。如果 Node.js 继续加载其他模块，这些模块中定义的“全局”变量 <code>s</code> 也互不干扰。</p>
<p>所以，Node.js 利用 JavaScript 的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出 <code>module.exports</code> 怎么实现?</p>
<p>这个也很容易实现，Node.js 可以先准备一个对象 <code>module</code>:</p>
<div><pre><code><span>// 准备module对象:</span>
<span>const</span> module <span>=</span> <span>{</span>
  <span>id</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
<span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>module</span><span>)</span> <span>{</span>
  <span>// 读取的hello.js代码:</span>
  <span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
  <span>}</span>

  module<span>.</span>exports <span>=</span> greet<span>;</span>
  <span>// hello.js代码结束</span>
  <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>
<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>)</span><span>;</span>
<span>// 保存module:</span>
<span>save</span><span>(</span>module<span>,</span> exported<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，变量 module 是 Node.js 在加载 js 文件前准备的一个变量，并将其传入加载函数，我们在 <code>hello.js</code> 中可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>通过把参数 <code>module</code> 传递给 <code>load()</code> 函数，<code>hello.js</code> 就顺利地把一个变量传递给了 Node.js 执行环境，Node.js 会把 module 变量保存到某个地方。</p>
<p>由于 Node.js 保存了所有导入的 module，当我们用 <code>require()</code> 获取 module 时，Node.js 找到对应的 module，把这个 module 的 <code>exports</code> 变量返回，这样，另一个模块就顺利拿到了模块的输出:</p>
<div><pre><code><span>const</span> greet <span>=</span> <span>require</span><span>(</span><span>"./hello"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>以上是 Node.js 实现 JavaScript 模块的一个简单的原理介绍。</p>
<h2 id="module-exports-vs-exports" tabindex="-1"> module.exports vs exports</h2>
<p>很多时候，您会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量:</p>
<p>方法一: 对 module.exports 赋值:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>hello</span><span>:</span> hello<span>,</span>
  <span>greet</span><span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>方法二: 直接使用 exports:</p>
<div><pre><code><span>// hello.js</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>greet</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, "</span> <span>+</span> name <span>+</span> <span>"!"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>hello</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"Hello, world!"</span><span>)</span><span>;</span>
<span>}</span>

exports<span>.</span>hello <span>=</span> hello<span>;</span>
exports<span>.</span>greet <span>=</span> greet<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>但是您不可以直接对 exports 赋值:</p>
<div><pre><code><span>// 代码可以执行，但是模块并没有输出任何变量:</span>
exports <span>=</span> <span>{</span>
  <span>hello</span><span>:</span> hello<span>,</span>
  <span>greet</span><span>:</span> greet<span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您对上面的写法感到十分困惑，不要着急，我们来分析 Node.js 的加载机制:</p>
<p>首先，Node.js 会把整个待加载的 hello.js 文件放入一个包装函数 load 中执行。在执行这个 load()函数前，Node.js 准备好了 module 变量:</p>
<div><pre><code><span>const</span> module <span>=</span> <span>{</span>
  <span>id</span><span>:</span> <span>"hello"</span><span>,</span>
  <span>exports</span><span>:</span> <span>{</span><span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>load()</code> 函数最终返回 <code>module.exports</code>:</p>
<div><pre><code><span>const</span> <span>load</span> <span>=</span> <span>function</span> <span>(</span><span>exports<span>,</span> module</span><span>)</span> <span>{</span>
    <span>// hello.js的文件内容</span>
    <span>...</span>
    <span>// load函数返回:</span>
    <span>return</span> module<span>.</span>exports<span>;</span>
<span>}</span><span>;</span>

<span>const</span> exported <span>=</span> <span>load</span><span>(</span>module<span>.</span>exports<span>,</span> module<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，默认情况下，Node.js 准备的 <code>exports</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code>，于是，我们可以写:</p>
<div><pre><code>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也可以写:</p>
<div><pre><code>module<span>.</span>exports<span>.</span><span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
module<span>.</span>exports<span>.</span><span>bar</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"bar"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>换句话说，Node.js 默认给您准备了一个空对象 <code>{}</code>，这样您可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>给 <code>exports</code> 赋值是无效的，因为赋值后，<code>module.exports</code> 仍然是空对象 <code>{}</code>。</p>
<h2 id="结论" tabindex="-1"> 结论</h2>
<p>如果要输出一个键值对象 <code>{}</code>，可以利用 <code>exports</code> 这个已存在的空对象 <code>{}</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对 <code>module.exports</code> 对象赋值。</p>
<p>所以我们可以得出结论: 直接对 <code>module.export</code>s 赋值，可以应对任何情况:</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>"foo"</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>或者:</p>
<div><pre><code>module<span>.</span><span>exports</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"foo"</span><span>;</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>最终，我们强烈建议使用 <code>module.exports = xxx</code> 的方式来输出模块变量，这样，您只需要记忆一种方法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第一个 Node 程序</title>
      <link>https://shimonzhan.com/code/node-js/program.html</link>
      <guid>https://shimonzhan.com/code/node-js/program.html</guid>
      <source url="https://shimonzhan.com/rss.xml">第一个 Node 程序</source>
      <description>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。
从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。
</description>
      <category>Node.js</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>

<p>那么问题来了: 文本编辑器到底哪家强?</p>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="/code/windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>如果您的电脑上已经安装了<strong>Sublime Text</strong>，或者<strong>Notepad++</strong>，也可以用来编写 JavaScript 代码，注意用 UTF-8 格式保存。</p>
<p>最方便的，当然是 Shimon Zhan 强力安利的 VS Code 了。</p>
<p>输入以下代码:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>"Hello, world."</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>第一行总是写上 <code>'use strict';</code> 是因为我们总是以严格模式运行 JavaScript 代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如 <code>C:\Workspace</code>，把文件保存为 <code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到 hello.js 所在目录，然后输入以下命令运行这个程序了:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
Hello, world.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>也可以保存为别的名字，比如 <code>first.js</code>，但是必须要以 <code>.js</code> 结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有 <code>hello.js</code> 这个文件，运行 <code>node hello.js</code> 就会报错:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node hello.js
module.js:338
    throw err<span>;</span>
          ^
Error: Cannot <span>find</span> module <span>'C:\Workspace\hello.js'</span>
    at Function.Module._resolveFilename
    at Function.Module._load
    at Function.Module.runMain
    at startup
    at node.js
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>报错的意思就是，没有找到 <code>hello.js</code> 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h2 id="命令行模式和-node-js-交互模式" tabindex="-1"> 命令行模式和 Node.js 交互模式</h2>
<p>请注意区分命令行模式和 Node.js 交互模式。</p>
<p>看到类似 <code>C:\&gt;</code> 是在 Windows 提供的命令行模式:</p>
<p><img src="@source/code/node-js/assets/run-node-hello.png" alt="run-node-hello" loading="lazy"></p>
<p>在命令行模式下，可以执行 Node.js 进入 Node.js 交互式环境，也可以执行 Node.js <code>hello.js</code> 运行一个 <code>.js</code> 文件。</p>
<p>看到<code>&gt;</code> 是在 Node.js 交互式环境下:</p>
<p><img src="@source/code/node-js/assets/node-interactive-env.png" alt="node-interactive-env" loading="lazy"></p>
<p>在 Node.js 交互式环境下，我们可以输入 JavaScript 代码并立刻执行。</p>
<p>此外，在命令行模式运行.js 文件和在 Node.js 交互式环境下直接运行 JavaScript 代码有所不同。Node.js 交互式环境会把每一行 JavaScript 代码的结果自动打印出来，但是，直接运行 JavaScript 文件却不会。</p>
<p>例如，在 Node.js 交互式环境下，输入:</p>
<div><pre><code><span>></span> <span>100</span> + <span>200</span> + <span>300</span><span>;</span>
<span>600</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>直接可以看到结果 600。</p>
<p>但是，写一个 <code>calc.js</code> 的文件，内容如下:</p>
<div><pre><code><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后在命令行模式下执行:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
</code></pre><div aria-hidden="true"><div></div></div></div><p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用 <code>console.log()</code> 打印出来。把 <code>calc.js</code> 改造一下:</p>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>100</span> <span>+</span> <span>200</span> <span>+</span> <span>300</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>再执行，就可以看到结果:</p>
<div><pre><code>C:<span>\</span>Workspace<span>></span>node calc.js
<span>600</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="使用严格模式" tabindex="-1"> 使用严格模式</h2>
<p>如果在 JavaScript 文件开头写上 <code>'use strict';</code>，那么 Node.js 在执行该 JavaScript 时将使用严格模式。但是，在服务器环境下，如果有很多 JavaScript 文件，每个文件都写上 <code>'use strict';</code> 很麻烦。我们可以给 Node.js 传递一个参数，让 Node.js 直接为所有 js 文件开启严格模式:</p>
<div><pre><code><span>node</span> --use_strict calc.js
</code></pre><div aria-hidden="true"><div></div></div></div><p>后续代码，如无特殊说明，我们都会直接给 Node.js 传递 <code>--use_strict</code> 参数来开启严格模式。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<p>用文本编辑器写 JavaScript 程序，然后保存为后缀为 <code>.js</code> 的文件，就可以用 Node.js 直接运行这个程序了。</p>
<p>Node.js 的交互模式和直接运行 <code>.js</code> 文件有什么区别呢?</p>
<p>直接输入 Node.js 进入交互模式，相当于启动了 Node.js 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行 <code>node hello.js</code> 文件相当于启动了 Node.js 解释器，然后一次性把 <code>hello.js</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>
<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node.js 交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27 寸的超大显示器!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js</title>
      <link>https://shimonzhan.com/code/vue/</link>
      <guid>https://shimonzhan.com/code/vue/</guid>
      <source url="https://shimonzhan.com/rss.xml">Vue.js</source>
      <category>基础</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>注意</p>
<p>目前此部分为 Vue 2 的文档，待 Vue 3 出官方中文文档后，本博客会进行跟进。</p>
</div>
<p>Vue.js 是世界上主流的渐近式 JavaScript 框架。其生态比较繁荣，且很多组件都由官方进行维护、同步更新。相比 React 虽然第三方组件及支持少一些，但是其各模块之间兼容性良好，不会发生冲突。</p>
<h2 id="介绍视频" tabindex="-1"> 介绍视频</h2>
<ul>
<li><a href="https://v.youku.com/v_show/id_XMzMwMTYyODMyNA==.html?refer=shipinyunPC_operation.liuliling_bofangqi_1244000_fQZ7Fj_18101900" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h2 id="学习视频" tabindex="-1"> 学习视频</h2>
<ul>
<li><a href="https://learning.dcloud.io/#/" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h2 id="vue-js-教程目录" tabindex="-1"> Vue.js 教程目录</h2>
<ul>
<li>
<p><a href="/code/vue/install.html">开发环境安装</a></p>
</li>
<li>
<p><a href="/code/vue/get-started.html">起步上手</a></p>
</li>
<li>
<p><a href="/code/vue/vue.html">Vue 单文件组件说明</a></p>
</li>
<li>
<p><a href="/code/vue/ts-decorator.html">使用 TypeScript 进行 Vue 开发</a></p>
</li>
</ul>
<h2 id="vue-生态" tabindex="-1"> Vue 生态</h2>
<h3 id="vue-router" tabindex="-1"> Vue Router</h3>
<ul>
<li>
<p><a href="/code/vue/router/">Vue Router 讲解</a></p>
</li>
<li>
<p><a href="/code/vue/router/demo.html">Vue Router Demo</a></p>
</li>
</ul>
<h3 id="vuex" tabindex="-1"> Vuex</h3>
<ul>
<li>
<p><a href="/code/vue/vuex/">Vuex 讲解</a></p>
</li>
<li>
<p><a href="/code/vue/vuex/demo.html">Vuex Demo</a></p>
</li>
</ul>
<h3 id="vue-cli" tabindex="-1"> Vue Cli</h3>
<ul>
<li>
<p><a href="/code/vue/cli/intro.html">Vue Cli 介绍</a></p>
</li>
<li>
<p><a href="/code/vue/cli/quick-dev.html">使用 Vue Cli 进行快速开发</a></p>
</li>
<li>
<p><a href="/code/vue/cli/file.html">Vue Cli 文件处理</a></p>
</li>
</ul>
<h3 id="其他-vue-生态" tabindex="-1"> 其他 Vue 生态</h3>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/basic/vuepress/" target="_blank" rel="noopener noreferrer">VuePress</a>: 静态站点生成器；</li>
<li><a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener noreferrer">Ant Design Vue</a>: 阿里的一套 UI 组件库；</li>
<li><a href="https://bootstrap-vue.js.org/" target="_blank" rel="noopener noreferrer">BootstrapVue</a></li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue.js 介绍</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer">Vue.js API</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://cli.vuejs.org/zh/guide/cli-service.html" target="_blank" rel="noopener noreferrer">Vue CLI 3 介绍</a></p>
</li>
<li>
<p><a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener noreferrer">Vue CLI 3 配置</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="noopener noreferrer">Vue Router 介绍</a></p>
</li>
<li>
<p><a href="https://cli.vuejs.org/zh/config/" target="_blank" rel="noopener noreferrer">Vue Router 配置</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://vuex.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">Vuex 介绍</a></p>
</li>
<li>
<p><a href="https://vuex.vuejs.org/zh/api/" target="_blank" rel="noopener noreferrer">Vuex 配置</a></p>
</li>
</ul>
<h2 id="其他文档" tabindex="-1"> 其他文档</h2>
<ul>
<li>
<p><a href="/code/vue/component.html">各组件使用说明</a></p>
</li>
<li>
<p><a href="/code/vue/compare.html">Vue 与小程序的异同</a></p>
</li>
<li>
<p>VueConf 视频</p>
<ul>
<li>
<p><a href="https://www.yuque.com/vueconf/2019/qg1yms" target="_blank" rel="noopener noreferrer">Vue Beyond Vue Loader</a></p>
</li>
<li>
<p><a href="https://www.yuque.com/vueconf/2019/gwn1z0" target="_blank" rel="noopener noreferrer">尤雨溪演讲视频</a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/VueConf2019SH_Evan.pdf" target="_blank" rel="noopener noreferrer">尤雨溪演讲 PPT</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/intro-to-vuepres-1.x.pdf" target="_blank" rel="noopener noreferrer">VuePress 介绍</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.pdf" target="_blank" rel="noopener noreferrer">Vue 单元测试</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/%E4%BD%BF%E7%94%A8Vue%E5%AE%9E%E7%8E%B00%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92-winter.pdf" target="_blank" rel="noopener noreferrer">使用 Vue 实现 0 代码交互</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%20%E5%BC%80%E5%8F%91%20ECharts%20%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener noreferrer">Echart 与 Vue</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Vue%20Beyond%20Vue%20Loader.pdf" target="_blank" rel="noopener noreferrer">Vue Loader</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/vue/Mars%E6%A1%86%E6%9E%B6%E5%88%86%E4%BA%AB-vueconf.pdf" target="_blank" rel="noopener noreferrer">基于 Vue 的多端框架</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 与小程序的异同</title>
      <link>https://shimonzhan.com/code/vue/compare.html</link>
      <guid>https://shimonzhan.com/code/vue/compare.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Vue 与小程序的异同</source>
      <description>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。
</description>
      <category>Vue</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue-cli 提供的 vue 单文件语法与小程序基本相似，甚至可以说小程序是改变自 Vue 与 React 框架的。</p>

<h2 id="优缺点比较" tabindex="-1"> 优缺点比较</h2>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>小程序</td>
<td>小程序底层由微信框架驱动，每个界面是单独的 JS 文件，页面切换以及全局生命周期丰富完善。小程序具有相当完备的 API。</td>
<td>小程序是由 JSCore 驱动逻辑层，视图层采用 Webview，故没有 DOM 节点的概念，只有渲染出的虚拟节点，所以无法动态删除或添加节点，无法使用一切 DOM 相关 API。小程序组件生命周期不够强大。小程序的 Webview 渲染存在一定的性能问题。小程序视图层与逻辑层通过 Jsbridge 连接，数据传输及渲染有延时。</td>
</tr>
<tr>
<td>vue</td>
<td>Vue 的实质是动态监测并托管 DOM 节点。由于 Vue 是网页开发，拥有 DOM 树，可以使用 DOM 相关 API。Vue 组件拥有更全面的生命周期，同时可以动态渲染组件。Vue 的组件传递数据方式默认为单向绑定</td>
<td>由于 Vue 的组件本质是监测 DOM 树，故其组件只能有一个根节点。同时 Vue 的界面路由依赖于 History API，其界面切换周期与逻辑不够强大。</td>
</tr>
</tbody>
</table>
<h2 id="代码区别" tabindex="-1"> 代码区别</h2>
<p>小程序与 Vue 在代码写法上极其相似，但稍有不同。</p>
<h3 id="数据绑定" tabindex="-1"> 数据绑定</h3>
<h4 id="小程序数据绑定" tabindex="-1"> 小程序数据绑定</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span>class</span><span><span>=</span><span>"</span>text1 {{a}} {{b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span>}}<span>"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div>
<p>小程序在所有内容上都使用 Muscle 语法 (<code>{{Javascript表达式}}</code>) 的写法。</p>
</div>
<h4 id="vue-数据绑定" tabindex="-1"> Vue 数据绑定</h4>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>text1<span>"</span></span> <span>:class</span><span><span>=</span><span>"</span>a+<span>'</span> <span>'</span>+ b?:<span>'</span>b为真<span>'</span>:<span>'</span>b为假<span>'</span><span>"</span></span><span>></span></span>{{text}}<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>Vue 在标签名属性用 <code>v-bind:prop=&quot;Javascript表达式&quot;</code> 的写法、其简写为 <code>:prop=&quot;&quot;</code>，在标签内容处使用 Muscle 语法。</p>
</div>
<h3 id="条件渲染" tabindex="-1"> 条件渲染</h3>
<h4 id="小程序条件渲染" tabindex="-1"> 小程序条件渲染</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>if</span><span><span>=</span><span>"</span>{{condition1}}<span>"</span></span><span>></span></span>板块只有 condition1 为 true 时才会渲染<span><span><span>&lt;/</span>view</span><span>></span></span>


<span><span><span>&lt;</span>block</span> <span><span>wx:</span>if</span><span><span>=</span><span>"</span>{{condition2}}<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>内容1<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>内容2<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>
    <span><span><span>&lt;</span>view</span><span>></span></span>内容3<span><span><span>&lt;/</span>view</span><span>></span></span>
    <span><span><span>&lt;</span>view</span><span>></span></span>内容4<span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;/</span>view</span><span>></span></span>
  <span><span><span>&lt;</span>view</span><span>></span></span>
    这是一个拥有很多兄弟标签的代码块.
    虚拟标签 block 会把其当作一个整体用作条件渲染。
  <span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;/</span>block</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html" target="_blank" rel="noopener noreferrer">小程序条件渲染文档</a></p>
</div>
<h4 id="vue-条件渲染" tabindex="-1"> Vue 条件渲染</h4>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>condition<span>"</span></span><span>></span></span>板块只有 condition 为 true 时才会渲染<span><span><span>&lt;/</span>div</span><span>></span></span>

<span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>{{condition2}}<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>内容1<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>内容2<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>内容3<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>内容4<span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    Vue 没有相关虚拟标签，且只能监听一个标签。所以只能建立一个没有样式的 div
    标签将多个并列标签抱起来。这样 Vue 就会因监听最外层 div
    会把其当作一个整体用作条件渲染。
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 条件渲染文档</a></p>
</div>
<h3 id="循环渲染" tabindex="-1"> 循环渲染</h3>
<h4 id="小程序循环渲染" tabindex="-1"> 小程序循环渲染</h4>
<div><pre><code><span><span><span>&lt;</span>view</span> <span><span>wx:</span>for</span><span><span>=</span><span>"</span>{{array}}<span>"</span></span> <span><span>wx:</span>for-item</span><span><span>=</span><span>"</span>element<span>"</span></span> <span><span>wx:</span>for-index</span><span><span>=</span><span>"</span>index<span>"</span></span><span>></span></span>
  {{index}} is {{element}}
<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>实际渲染结果为:</p>
<div><pre><code><span><span><span>&lt;</span>view</span><span>></span></span>1<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>2<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>3<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>4<span><span><span>&lt;/</span>view</span><span>></span></span>
<span><span><span>&lt;</span>view</span><span>></span></span>5<span><span><span>&lt;/</span>view</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html" target="_blank" rel="noopener noreferrer">小程序循环渲染文档</a></p>
</div>
<h4 id="vue-循环渲染" tabindex="-1"> Vue 循环渲染</h4>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>v-for</span><span><span>=</span><span>"</span>(element,index) in array<span>"</span></span><span>></span></span>
       {{index}} is {{ element }}
    <span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 循环渲染文档</a></p>
</div>
<h2 id="生命周期" tabindex="-1"> 生命周期</h2>
<h3 id="页面生命周期" tabindex="-1"> 页面生命周期</h3>
<h4 id="小程序生命周期" tabindex="-1"> 小程序生命周期</h4>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" alt="小程序页面生命周期" loading="lazy"></p>
<h4 id="vue-页面生命周期" tabindex="-1"> Vue 页面生命周期</h4>
<p><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">Vue 页面生命周期</a></p>
<h3 id="组件生命周期" tabindex="-1"> 组件生命周期</h3>
<h4 id="小程序组件生命周期" tabindex="-1"> 小程序组件生命周期</h4>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html" target="_blank" rel="noopener noreferrer">小程序组件生命周期</a></p>
<h4 id="vue-组件生命周期" tabindex="-1"> Vue 组件生命周期</h4>
<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue组件生命周期" loading="lazy"></p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" type="image/png"/>
    </item>
    <item>
      <title>组件使用说明</title>
      <link>https://shimonzhan.com/code/vue/component.html</link>
      <guid>https://shimonzhan.com/code/vue/component.html</guid>
      <source url="https://shimonzhan.com/rss.xml">组件使用说明</source>
      <description>Shimon Zhan 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。
</description>
      <category>Vue</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Shimon Zhan 已为 inNENU Website 开发了一些常规组件。本文介绍了这些组件的配置。</p>

<h2 id="常规组件" tabindex="-1"> 常规组件</h2>
<div><p>提示</p>
<p>所有以 <code>Base</code> 开头的组件都包含如下属性:</p>
<p>| 属性 | 必填 |       类型       | 内容      |
| ---- | :--: | :--------------: | --------- | --- |
| myId |  是  | Number 或 String | 组件的 ID |     |</p>
</div>
<p>以下是项目中中常用的组件。</p>
<h3 id="basehead" tabindex="-1"> BaseHead</h3>
<p>页面标题文字</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>页面选项卡文字</td>
</tr>
</tbody>
</table>
<h3 id="basetitle" tabindex="-1"> BaseTitle</h3>
<p>段落间大标题</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>标题文字</td>
<td></td>
</tr>
<tr>
<td>myStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
</tbody>
</table>
<h3 id="basep" tabindex="-1"> BaseP</h3>
<p>段落文字(可带图)</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>段落的文字</td>
<td>可以识别连续的空格，使用 <code>\n</code> 表示回车，也可直接使用 <code>&lt;br /&gt;</code> 换行</td>
</tr>
<tr>
<td>head</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>段落的标题</td>
<td></td>
</tr>
<tr>
<td>headStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
<tr>
<td>myStyle</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Style</td>
<td>标题自定义样式</td>
<td>填入任意 css 样式</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td>会在段落后渲染一张图片</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的描述文字</td>
<td>会自动在文字前加 <code>▲</code></td>
</tr>
</tbody>
</table>
<h3 id="baseimg" tabindex="-1"> BaseImg</h3>
<p>图片</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片的描述文字</td>
<td>会自动在文字前加 ▲</td>
</tr>
</tbody>
</table>
<h3 id="baselist" tabindex="-1"> BaseList</h3>
<p>列表</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>列表内容</td>
<td></td>
</tr>
<tr>
<td>head</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Boolean</td>
<td>列表的标题</td>
<td>默认为 <code>''</code>，设置 <code>false</code> 取消显示列表标题，否则即使不设置也会显示一个空标题</td>
</tr>
<tr>
<td>foot</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>列表的页脚文字</td>
<td>默认为 <code>''</code>,不显示页脚</td>
</tr>
</tbody>
</table>
<h3 id="basegrid" tabindex="-1"> BaseGrid</h3>
<p>九宫格</p>
<p>| 属性    | 必填 |       类型        | 内容             |
| ------- | :--: | :---------------: | ---------------- | ------------------------------------------------------------------------------ |
| content |  是  |    GirdItem[]     | 九宫格单元内容   |
| head    |  否  | String 或 Boolean | 九宫格的标题     | 默认为 <code>''</code>，设置 <code>false</code> 取消显示九宫格标题，否则即使不设置也会显示一个空标题 |
| foot    |  否  |      String       | 九宫格的页脚文字 | 默认为 <code>''</code>,不显示页脚                                                         |</p>
<ul>
<li><strong>GirdItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>icon</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图标地址</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>文字</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>跳转链接</td>
</tr>
</tbody>
</table>
<h3 id="basefoot" tabindex="-1"> BaseFoot</h3>
<p>页脚</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>页脚额外描述文字</td>
<td></td>
</tr>
<tr>
<td>author</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>作者</td>
<td>默认为 <code>Shimon Zhan</code>，如需取消请传入 <code>''</code></td>
</tr>
<tr>
<td>time</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>最后编辑时间</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basecarousel" tabindex="-1"> BaseCarousel</h3>
<p>轮播图</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center">CarouselItem[]</td>
<td>轮播图组件内容</td>
<td></td>
</tr>
<tr>
<td>vertical</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否竖直显示</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>autoplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否支持自动播放</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>autoplaySpeed</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Number</td>
<td>自动播放时间间隔</td>
<td>默认为 <code>3000</code></td>
</tr>
<tr>
<td>speed</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Number</td>
<td>切换速度</td>
<td>默认为 <code>500</code></td>
</tr>
<tr>
<td>dotDisplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否显示指示点</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>arrowDisplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否显示切换箭头</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>easing</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>切换动画</td>
<td>默认为 <code>easeInOutQuart</code></td>
</tr>
</tbody>
</table>
<ul>
<li><strong>CarouselItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>caption</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>轮播图的主标题</td>
<td>请填入核心内容</td>
</tr>
<tr>
<td>subCaption</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>轮播图的副标题</td>
<td>主标题的进一步解释</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>图片的路径</td>
<td>所有轮播图图片长宽比例应该相同，推荐值 <code>16: 9</code></td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>轮播图点击时的跳转路径</td>
<td>支持相对路径绝对路径以及 http、https 链接</td>
</tr>
<tr>
<td>enSubhead</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>轮播图的英文副标题</td>
<td></td>
</tr>
<tr>
<td>alt</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>图片失效时的显示文字</td>
<td>不填会默认初始化为文字 <code>轮播图背景</code></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>页面右下角补充说明</td>
<td>仅在 large 及以上屏幕上显示</td>
</tr>
<tr>
<td>black</td>
<td style="text-align:center">否</td>
<td style="text-align:center">Boolean</td>
<td>是否采用黑色文字</td>
<td>默认文字色为白色</td>
</tr>
</tbody>
</table>
<h3 id="basephone" tabindex="-1"> BasePhone</h3>
<p>生成拨打电话提示，该组件仅为兼容小程序。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>number</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String 或 Number</td>
<td>电话号码</td>
</tr>
</tbody>
</table>
<h2 id="以下是以便复用的不常用组件" tabindex="-1"> 以下是以便复用的不常用组件</h2>
<h3 id="nav-组件" tabindex="-1"> Nav 组件</h3>
<p>网页导航栏</p>
<h3 id="slide-组件" tabindex="-1"> Slide 组件</h3>
<p>网页侧边栏</p>
<h3 id="footer-组件" tabindex="-1"> Footer 组件</h3>
<p>网页页脚</p>
<h3 id="basemenu-组件" tabindex="-1"> BaseMenu 组件</h3>
<p>生成竖直菜单</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>list</td>
<td style="text-align:center">是</td>
<td style="text-align:center">MenuItem[]</td>
<td>菜单内容</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>MenuItem</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>菜单项的标识符</td>
<td>不可重复</td>
</tr>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>菜单的文字</td>
<td></td>
</tr>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String 或 Boolean</td>
<td>菜单的图标</td>
<td>填入 <code>true</code> 不显示图标但是图标区留空</td>
</tr>
<tr>
<td>children</td>
<td style="text-align:center">否</td>
<td style="text-align:center">MenuItem[]</td>
<td>子菜单</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basepage-组件" tabindex="-1"> BasePage 组件</h3>
<p>用于渲染小程序 json 生成页面</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>pagedata</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>小程序页面 json 的字符串</td>
</tr>
</tbody>
</table>
<h3 id="docview-组件" tabindex="-1"> DocView 组件</h3>
<p>用于自动渲染转码的 HTML</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>docContent</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>Markdown 转 HTML 内容</td>
</tr>
</tbody>
</table>
<h3 id="basecard-组件" tabindex="-1"> BaseCard 组件</h3>
<p>卡片样式。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>卡片的标题</td>
<td></td>
</tr>
<tr>
<td>price</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Number</td>
<td>价格</td>
<td></td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Array</td>
<td>卡片详情</td>
<td>数组的每一项是卡片详情的每一项内容，支持 rawHtml</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>卡片跳转的地址</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="basetimeaxis-组件" tabindex="-1"> BaseTimeAxis 组件</h3>
<p>生成时间轴</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>timeList</td>
<td style="text-align:center">是</td>
<td style="text-align:center">TimeListItem[]</td>
<td>Markdown 转 HTML 内容</td>
</tr>
</tbody>
</table>
<div><p>注意</p>
<p>※ 必须将该组件直接放置在 <code>div.container</code> 中! 否则会造成显示错乱。</p>
</div>
<ul>
<li><strong>TimeListItem</strong>:</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>时间线的标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>时间线的段落文字</td>
<td>可输入 rawhtml，支持 <code>\n</code> 与连续空格</td>
</tr>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>时间线的图标</td>
<td>可输入 rawhtml</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>点击当前选项卡跳转的地址</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="mydoc-组件" tabindex="-1"> MyDoc 组件</h3>
<p>用于自动生成 HTML 页面</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>baselength</td>
<td style="text-align:center">是</td>
<td style="text-align:center">Number</td>
<td>MarkDown 基准路径字符数</td>
</tr>
</tbody>
</table>
<h3 id="backtop-组件" tabindex="-1"> BackTop 组件</h3>
<p>一个返回顶部按钮，当滚动距离超过 300px 时显示会显示在右下角</p>
<h3 id="loadingicon" tabindex="-1"> LoadingIcon</h3>
<p>一个自定义的齿轮加载图标</p>
<h3 id="passwordmodal" tabindex="-1"> PasswordModal</h3>
<p>密码弹出框</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">类型</th>
<th>内容</th>
<th>补充说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center">String</td>
<td>验证地址</td>
<td>填入绝对路径，不需要填写 php 文件后缀名</td>
</tr>
<tr>
<td>userNameKey</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>用户名的自动填充键值</td>
<td>填写后会提示输入用户名，默认不输入</td>
</tr>
<tr>
<td>passwordKey</td>
<td style="text-align:center">否</td>
<td style="text-align:center">String</td>
<td>密码的自动填充键值</td>
<td>默认为 <code>password</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>快速上手 Vue.js</title>
      <link>https://shimonzhan.com/code/vue/get-started.html</link>
      <guid>https://shimonzhan.com/code/vue/get-started.html</guid>
      <source url="https://shimonzhan.com/rss.xml">快速上手 Vue.js</source>
      <category>Vue</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="vue-js-是什么" tabindex="-1"> Vue.js 是什么</h2>
<p><a href="https://learning.dcloud.io/#/?vid=0" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<h2 id="起步" tabindex="-1"> 起步</h2>
<p><a href="https://learning.dcloud.io/#/?vid=1" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<div><p>提示</p>
<p>您应当已了解关于 HTML、CSS 和 JavaScript 的中级知识。</p>
</div>
<p><a href="https://cn.vuejs.org/v2/guide/installation.html" target="_blank" rel="noopener noreferrer">安装</a></p>
<p>尝试 Vue.js 最简单的方法是使用 <a href="https://jsfiddle.net/chrisvfritz/50wL7mdz/" target="_blank" rel="noopener noreferrer">JSFiddle 上的 Hello World 例子</a>。您可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者您也可以创建一个 <code>.html</code> 文件，然后通过如下方式引入 Vue:</p>
<div><pre><code><span>&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/npm/vue/dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>或者:</p>
<div><pre><code><span>&lt;!-- 生产环境版本，优化了尺寸和速度 --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/npm/vue<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>注意</p>
<p>请注意 Shimon Zhan <strong>不推荐</strong> 新手直接使用 <code>vue-cli</code>，尤其是在您还不熟悉基于 Node.js 的构建工具时。</p>
</div>
<h2 id="声明式渲染" tabindex="-1"> 声明式渲染</h2>
<p><a href="https://learning.dcloud.io/#/?vid=3" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue!"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们已经成功创建了第一个 Vue 应用! 现在数据和 DOM 已经被建立了关联，所有东西都是<strong>响应式的</strong>。也就是说如果 <code>data</code> 中的 <code>message</code> 值被改变，那么视图层中的 <code>message</code> 马上会更新。</p>
<p>除了文本插值，我们还可以像这样来绑定元素特性:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-2<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>span</span> <span><span>v-bind:</span>title</span><span><span>=</span><span>"</span>message<span>"</span></span><span>></span></span>
    鼠标悬停几秒钟查看此处动态绑定的提示信息!
  <span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app2 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-2"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"页面加载于 "</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toLocaleString</span><span>(</span><span>)</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里我们遇到了一点新东西。您看到的 <code>v-bind</code> 特性被称为<strong>指令</strong>。指令带有前缀 <code>v-</code>，以表示它们是 Vue 提供的特殊特性。可能您已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是: “将这个元素节点的 <code>title</code> 特性和 Vue 实例的 <code>message</code> 属性保持一致”。</p>
<h2 id="条件与循环" tabindex="-1"> 条件与循环</h2>
<p><a href="https://learning.dcloud.io/#/?vid=8" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>控制切换一个元素是否显示也相当简单:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-3<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-if</span><span><span>=</span><span>"</span>seen<span>"</span></span><span>></span></span>现在您看到我了<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app3 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-3"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>seen</span><span>:</span> <span>true</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果您改变 <code>seen</code> 的值，文字的显示与否(也就是 <code>&lt;p&gt;</code> 标签的存在与否)也会进行切换。</p>
<p>这个例子演示了我们不仅可以把数据绑定到 DOM 文本或特性，还可以绑定到 DOM <strong>结构</strong>。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用<a href="https://cn.vuejs.org/v2/guide/transitions.html" target="_blank" rel="noopener noreferrer">过渡效果</a>。</p>
<p>还有其它很多指令，每个都有特殊的功能。例如，<code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-4<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ol</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>todo in todos<span>"</span></span><span>></span></span>{{ todo.text }}<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app4 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-4"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>todos</span><span>:</span> <span>[</span>
      <span>{</span> <span>text</span><span>:</span> <span>"学习 JavaScript"</span> <span>}</span><span>,</span>
      <span>{</span> <span>text</span><span>:</span> <span>"学习 Vue"</span> <span>}</span><span>,</span>
      <span>{</span> <span>text</span><span>:</span> <span>"整个牛项目"</span> <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="处理用户输入" tabindex="-1"> 处理用户输入</h2>
<p><a href="https://learning.dcloud.io/#/?vid=11" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>为了让用户和您的应用进行交互，我们可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-5<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>reverseMessage<span>"</span></span><span>></span></span>反转消息<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app5 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-5"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue.js!"</span><span>,</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>reverseMessage</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>message <span>=</span> <span>this</span><span>.</span>message<span>.</span><span>split</span><span>(</span><span>""</span><span>)</span><span>.</span><span>reverse</span><span>(</span><span>)</span><span>.</span><span>join</span><span>(</span><span>""</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意在 <code>reverseMessage</code> 方法中，每次点击按钮的时候，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，您编写的代码只需要关注逻辑层面即可。</p>
<p>Vue 还提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定。</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-6<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;</span>input</span> <span>v-model</span><span><span>=</span><span>"</span>message<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>const</span> app6 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-6"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>message</span><span>:</span> <span>"Hello Vue!"</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也就是说，在输入框做出的更改会同步到 js 的数据中。</p>
<h2 id="组件化应用构建" tabindex="-1"> 组件化应用构建</h2>
<p><a href="https://learning.dcloud.io/#/?vid=12" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树:</p>
<p><img src="@source/code/vue/assets/components.png" alt="Component Tree" loading="lazy"></p>
<p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单:</p>
<div><pre><code><span>// 定义名为 todo-item 的新组件</span>
Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>template</span><span>:</span> <span>"&lt;li>这是个待办项&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>现在您可以用它构建另一个组件模板:</p>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span>&lt;!-- 创建一个 todo-item 组件的实例 --></span>
  <span><span><span>&lt;</span>todo-ite</span> <span>/></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener noreferrer">prop</a>:</p>
<div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>// todo-item 组件现在接受一个</span>
  <span>// "prop"，类似于一个自定义特性。</span>
  <span>// 这个 prop 名为 todo。</span>
  <span>props</span><span>:</span> <span>[</span><span>"todo"</span><span>]</span><span>,</span>
  <span>template</span><span>:</span> <span>"&lt;li>{{ todo.text }}&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app-7<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>ol</span><span>></span></span>
    <span>&lt;!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    --></span>
    <span><span><span>&lt;</span>todo-item</span>
      <span>v-for</span><span><span>=</span><span>"</span>item in groceryList<span>"</span></span>
      <span><span>v-bind:</span>todo</span><span><span>=</span><span>"</span>item<span>"</span></span>
      <span><span>v-bind:</span>key</span><span><span>=</span><span>"</span>item.id<span>"</span></span>
    <span>/></span></span>
  <span><span><span>&lt;/</span>ol</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>Vue<span>.</span><span>component</span><span>(</span><span>"todo-item"</span><span>,</span> <span>{</span>
  <span>props</span><span>:</span> <span>[</span><span>"todo"</span><span>]</span><span>,</span>
  <span>template</span><span>:</span> <span>"&lt;li>{{ todo.text }}&lt;/li>"</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>const</span> app7 <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app-7"</span><span>,</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>groceryList</span><span>:</span> <span>[</span>
      <span>{</span> <span>id</span><span>:</span> <span>0</span><span>,</span> <span>text</span><span>:</span> <span>"蔬菜"</span> <span>}</span><span>,</span>
      <span>{</span> <span>id</span><span>:</span> <span>1</span><span>,</span> <span>text</span><span>:</span> <span>"奶酪"</span> <span>}</span><span>,</span>
      <span>{</span> <span>id</span><span>:</span> <span>2</span><span>,</span> <span>text</span><span>:</span> <span>"随便其它什么人吃的东西"</span> <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。</p>
<p>在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">后续教程</a>中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>app-nav</span> <span>/></span></span>
  <span><span><span>&lt;</span>app-view</span><span>></span></span>
    <span><span><span>&lt;</span>app-sidebar</span> <span>/></span></span>
    <span><span><span>&lt;</span>app-content</span> <span>/></span></span>
  <span><span><span>&lt;/</span>app-view</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="与自定义元素的关系" tabindex="-1"> 与自定义元素的关系</h3>
<p>您可能已经注意到 Vue 组件非常类似于<strong>自定义元素</strong>——它是 <a href="https://www.w3.org/wiki/WebComponents/" target="_blank" rel="noopener noreferrer">Web 组件规范</a>的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md" target="_blank" rel="noopener noreferrer">Slot API</a> 与 <code>is</code> 特性。但是，还是有几个关键差别:</p>
<ol>
<li>
<p>Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。</p>
</li>
<li>
<p>Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。</p>
</li>
</ol>
<p>虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，<a href="https://custom-elements-everywhere.com/#vue" target="_blank" rel="noopener noreferrer">依然有很好的互操作性</a>。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。</p>
<h2 id="创建一个-vue-实例" tabindex="-1"> 创建一个 Vue 实例</h2>
<p><a href="https://learning.dcloud.io/#/?vid=2" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的:</p>
<div><pre><code><span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>// 选项</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM" target="_blank" rel="noopener noreferrer">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<p>当创建一个 Vue 实例时，您可以传入一个<strong>选项对象</strong>。这篇教程主要描述的就是如何使用这些选项来创建您想要的行为。作为参考，您也可以在 <a href="https://cn.vuejs.org/v2/api/" target="_blank" rel="noopener noreferrer">API 文档</a> 中浏览完整的选项列表。</p>
<p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的:</p>
<div><pre><code>根实例
└─ TodoList
├─ TodoItem
│ ├─ DeleteTodoButton
│ └─ EditTodoButton
└─ TodoListFooter
├─ ClearTodosButton
└─ TodoListStatistics
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们会在稍后的<a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener noreferrer">组件系统</a>章节具体展开。不过现在，您只需要明白所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)。</p>
<h2 id="数据与方法" tabindex="-1"> 数据与方法</h2>
<p><a href="https://learning.dcloud.io/#/?vid=3" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的属性加入到 Vue 的<strong>响应式系统</strong>中。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<div><pre><code><span>// 我们的数据对象</span>
<span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>

<span>// 该对象被加入到一个 Vue 实例中</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> data<span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>// 获得这个实例上的属性</span>
<span>// 返回源数据中对应的字段</span>
vm<span>.</span>a <span>==</span> data<span>.</span>a<span>;</span> <span>// => true</span>

<span>// 设置属性也会影响到原始数据</span>
vm<span>.</span>a <span>=</span> <span>2</span><span>;</span>
data<span>.</span>a<span>;</span> <span>// => 2</span>

<span>// ……反之亦然</span>
data<span>.</span>a <span>=</span> <span>3</span><span>;</span>
vm<span>.</span>a<span>;</span> <span>// => 3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的属性才是<strong>响应式</strong>的。也就是说如果您添加一个新的属性，比如:</p>
<div><pre><code>vm<span>.</span>b <span>=</span> <span>"hi"</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果您知道您会在晚些时候需要一个属性，但是一开始它为空或不存在，那么您仅需要设置一些初始值。比如:</p>
<div><pre><code><span>data</span><span>:</span> <span>{</span>
  <span>newTodoText</span><span>:</span> <span>''</span><span>,</span>
  <span>visitCount</span><span>:</span> <span>0</span><span>,</span>
  <span>hideCompletedTodos</span><span>:</span> <span>false</span><span>,</span>
  <span>todos</span><span>:</span> <span>[</span><span>]</span><span>,</span>
  <span>error</span><span>:</span> <span>null</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的属性，也意味着响应系统无法再<em>追踪</em>变化。</p>
<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>
  <span>foo</span><span>:</span> <span>"bar"</span><span>,</span>
<span>}</span><span>;</span>

Object<span>.</span><span>freeze</span><span>(</span>obj<span>)</span><span>;</span>

<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#app"</span><span>,</span>
  <span>data</span><span>:</span> obj<span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span><span>></span></span>{{ foo }}<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span>&lt;!-- 这里的 `foo` 不会更新!  --></span>
  <span><span><span>&lt;</span>button</span> <span><span>v-on:</span>click</span><span><span>=</span><span>"</span>foo = <span>'</span>baz<span>'</span><span>"</span></span><span>></span></span>Change it<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 <code>$</code>，以便与用户定义的属性区分开来。例如:</p>
<div><pre><code><span>const</span> data <span>=</span> <span>{</span> <span>a</span><span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>el</span><span>:</span> <span>"#example"</span><span>,</span>
  <span>data</span><span>:</span> data<span>,</span>
<span>}</span><span>)</span><span>;</span>

vm<span>.</span>$data <span>===</span> data<span>;</span> <span>// => true</span>
vm<span>.</span>$el <span>===</span> document<span>.</span><span>getElementById</span><span>(</span><span>"example"</span><span>)</span><span>;</span> <span>// => true</span>

<span>// $watch 是一个实例方法</span>
vm<span>.</span><span>$watch</span><span>(</span><span>"a"</span><span>,</span> <span>function</span> <span>(</span><span>newValue<span>,</span> oldValue</span><span>)</span> <span>{</span>
  <span>// 这个回调将在 `vm.a` 改变后调用</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以后您可以在 <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener noreferrer">API 参考</a>中查阅到完整的实例属性和方法的列表。</p>
<h2 id="实例生命周期钩子" tabindex="-1"> 实例生命周期钩子</h2>
<p><a href="https://learning.dcloud.io/#/?vid=4" target="_blank" rel="noopener noreferrer">观看本节视频讲解</a></p>
<p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 <a href="https://cn.vuejs.org/v2/api/#created" target="_blank" rel="noopener noreferrer"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码:</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
  <span>data</span><span>:</span> <span>{</span>
    <span>a</span><span>:</span> <span>1</span><span>,</span>
  <span>}</span><span>,</span>
  <span>created</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// `this` 指向 vm 实例</span>
    console<span>.</span><span>log</span><span>(</span><span>"a is: "</span> <span>+</span> <span>this</span><span>.</span>a<span>)</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
<span>// => "a is: 1"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted" target="_blank" rel="noopener noreferrer"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated" target="_blank" rel="noopener noreferrer"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed" target="_blank" rel="noopener noreferrer"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<div><p>提示</p>
<p>不要在选项属性或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener noreferrer">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch('a', newValue =&gt; this.myMethod())</code>。因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
</div>
<h2 id="生命周期图示" tabindex="-1"> 生命周期图示</h2>
<p>下图展示了实例的生命周期。您不需要立马弄明白所有的东西，不过随着您的不断学习和使用，它的参考价值会越来越高。</p>
<p><img src="@source/code/vue/assets/lifecycle.png" alt="Vue 实例生命周期" loading="lazy"></p>
]]></content:encoded>
    </item>
    <item>
      <title>开发环境安装</title>
      <link>https://shimonzhan.com/code/vue/install.html</link>
      <guid>https://shimonzhan.com/code/vue/install.html</guid>
      <source url="https://shimonzhan.com/rss.xml">开发环境安装</source>
      <category>Vue</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="环境准备" tabindex="-1"> 环境准备</h2>
<h3 id="vs-code-安装" tabindex="-1"> VS Code 安装</h3>
<ul>
<li><a href="/software/vscode/install.html">安装 VS Code</a></li>
</ul>
<h4 id="开发指南" tabindex="-1"> 开发指南</h4>
<ol>
<li>
<p>使用 VS Code 打开项目文件夹。</p>
<div><p>提示</p>
<p>请打开 VS Code 选择菜单栏中的 “文件-打开文件夹”，或在文件夹上 “右键——使用 VS Code 打开” 或在文件夹内部空白处 “右键——使用 VS Code 打开”。</p>
</div>
</li>
<li>
<p>打开终端(快捷键 <code>Ctrl +</code> ` )。(反引号为 ` )</p>
</li>
<li>
<p>在终端中输入相关指令即可执行相关功能。</p>
</li>
</ol>
<h3 id="git-安装" tabindex="-1"> Git 安装</h3>
<ul>
<li><a href="/software/git/install.html">安装 Git</a></li>
</ul>
<h3 id="node-js-环境安装" tabindex="-1"> Node.js 环境安装</h3>
<p>请先安装 Node.js 并将 npm 与 Node.js 添加至 path。</p>
<ul>
<li>
<p><a href="/code/node-js/install.html">安装 Node.js</a></p>
</li>
<li>
<p><a href="/code/windows/add-path.html">添加到 path</a></p>
</li>
</ul>
<h2 id="初始化版本库、下载网页代码并安装-npm-模块" tabindex="-1"> 初始化版本库、下载网页代码并安装 npm 模块</h2>
<ol>
<li>
<p>打开文件管理器窗口找到合适位置，并在地址栏输入 cmd，以在当前界面打开终端。</p>
</li>
<li>
<p>使用 <code>git clone git@github.com:Mister-Hope/vue-template.git</code> 克隆模板。</p>
</li>
<li>
<p>使用 VS Code 打开刚刚克隆出来的文件夹，按下 <code>Ctrl + `</code> 打开终端。</p>
</li>
<li>
<p>使用 <code>npm install</code> 命令安装模块。</p>
</li>
</ol>
<div><p>提示</p>
<p>npm 模块介绍</p>
<p>此处待补充。</p>
</div>
<h2 id="开发工具安装" tabindex="-1"> 开发工具安装</h2>
<p>Vue 官方提供的浏览器插件 VueTools 可以更好的帮助开发。</p>
<p>使用 VPN 用 Chrome 打开<a href="https://chrome.google.com/webstore/detail/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener noreferrer">安装网址</a>，安装 VueTools 开发工具</p>
<div><p>提示</p>
<p>VPN 可以使用赛风 3 或 Betternet。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>在 Vue 中使用 Typescript</title>
      <link>https://shimonzhan.com/code/vue/ts-decorator.html</link>
      <guid>https://shimonzhan.com/code/vue/ts-decorator.html</guid>
      <source url="https://shimonzhan.com/rss.xml">在 Vue 中使用 Typescript</source>
      <category>基础</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用-typescript-进行-vue-开发" tabindex="-1"> 使用 TypeScript 进行 Vue 开发</h2>
<p>在使用 <code>Typescript</code> 进行 Vue2.X 版本开发时，需要引入 <code>vue-property-decorator</code> 这个包进行开发。</p>
<p>本质上就是写法上与 <code>js</code> 有所不同，而且需要额外注明变量的类型。</p>
<h2 id="用法" tabindex="-1"> 用法</h2>
<p>有 7 个装饰器和 1 个功能(Mixin):</p>
<ul>
<li>@Emit</li>
<li>@Inject</li>
<li>@Model</li>
<li>@Prop</li>
<li>@Provide</li>
<li>@Watch</li>
<li>@Component(由 <code>vue-class-component</code> 提供)</li>
<li>Mixins(mixins 由 <code>vue-class-component</code> 提供的辅助函数)</li>
</ul>
<h2 id="prop-decorator" tabindex="-1"> @Prop() decorator</h2>
<p><code>prop</code> 属性的装饰器</p>
<div><pre><code><span>import</span> <span>{</span> Vue<span>,</span> Component<span>,</span> Prop <span>}</span> <span>from</span> <span>"vue-property-decorator"</span><span>;</span>

<span><span>@</span><span>Component</span></span>
<span>export</span> <span>default</span> <span>class</span> <span>YourComponent</span> <span>extends</span> <span>Vue</span> <span>{</span>
  <span><span>@</span><span>Prop</span></span><span>(</span>Number<span>)</span> <span>private</span> <span>readonly</span> propA<span>!</span><span>:</span> <span>number</span><span>;</span>

  <span><span>@</span><span>Prop</span></span><span>(</span><span>{</span> <span>default</span><span>:</span> <span>"default value"</span> <span>}</span><span>)</span> <span>private</span> <span>readonly</span> propB<span>!</span><span>:</span> <span>string</span><span>;</span>

  <span><span>@</span><span>Prop</span></span><span>(</span><span>[</span>String<span>,</span> Boolean<span>]</span><span>)</span> <span>private</span> <span>readonly</span> propC<span>!</span><span>:</span> <span>string</span> <span>|</span> <span>boolean</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>相当于</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>props</span><span>:</span> <span>{</span>
    <span>propA</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> Number<span>,</span>
    <span>}</span><span>,</span>
    <span>propB</span><span>:</span> <span>{</span>
      <span>default</span><span>:</span> <span>"default value"</span><span>,</span>
    <span>}</span><span>,</span>
    <span>propC</span><span>:</span> <span>{</span>
      <span>type</span><span>:</span> <span>[</span>String<span>,</span> Boolean<span>]</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>需要在装饰器的参数中填入 <code>js</code> 写法中对应 prop 的值。</p>
<p>在后方使用 <code>private readonly</code> 标识符表示这是一个私有且只读的属性，它与 props 的性质相同。</p>
<p>在 prop 的名称后面使用 <code>!: &lt;类型&gt;</code> 再次声明该属性的定义类型。</p>
<p>注意:</p>
<p>每个 prop 的默认值需要定义为与上面显示的示例代码相同。</p>
<p>不支持以下的形式:</p>
<div><pre><code>  <span><span>@</span><span>Prop</span></span><span>(</span><span>)</span> prop <span>=</span> <span>'default value'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="watch-decorator" tabindex="-1"> @Watch() decorator</h2>
<p><code>watch</code> 属性的装饰器。</p>
<div><pre><code><span>import</span> <span>{</span> Vue<span>,</span> Component<span>,</span> Watch <span>}</span> <span>from</span> <span>"vue-property-decorator"</span><span>;</span>

<span><span>@</span><span>Component</span></span>
<span>export</span> <span>default</span> <span>class</span> <span>YourComponent</span> <span>extends</span> <span>Vue</span> <span>{</span>
  <span><span>@</span><span>Watch</span></span><span>(</span><span>"child"</span><span>)</span>
  <span>onChildChanged</span><span>(</span>val<span>:</span> <span>string</span><span>,</span> oldVal<span>:</span> <span>string</span><span>)</span> <span>{</span><span>}</span>

  <span><span>@</span><span>Watch</span></span><span>(</span><span>"person"</span><span>,</span> <span>{</span> immediate<span>:</span> <span>true</span><span>,</span> deep<span>:</span> <span>true</span> <span>}</span><span>)</span>
  <span>onPersonChanged1</span><span>(</span>val<span>:</span> Person<span>,</span> oldVal<span>:</span> Person<span>)</span> <span>{</span><span>}</span>

  <span><span>@</span><span>Watch</span></span><span>(</span><span>"person"</span><span>)</span>
  <span>onPersonChanged2</span><span>(</span>val<span>:</span> Person<span>,</span> oldVal<span>:</span> Person<span>)</span> <span>{</span><span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>相当于</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>watch</span><span>:</span> <span>{</span>
    <span>'child'</span><span>:</span> <span>[</span>
      <span>{</span>
        <span>handler</span><span>:</span> <span>'onChildChanged'</span><span>,</span>
        <span>immediate</span><span>:</span> <span>false</span><span>,</span>
        <span>deep</span><span>:</span> <span>false</span>
      <span>}</span>
    <span>]</span><span>,</span>
    <span>'person'</span><span>:</span> <span>[</span>
      <span>{</span>
        <span>handler</span><span>:</span> <span>'onPersonChanged1'</span><span>,</span>
        <span>immediate</span><span>:</span> <span>true</span><span>,</span>
        <span>deep</span><span>:</span> <span>true</span>
      <span>}</span><span>,</span>
      <span>{</span>
        <span>handler</span><span>:</span> <span>'onPersonChanged2'</span><span>,</span>
        <span>immediate</span><span>:</span> <span>false</span><span>,</span>
        <span>deep</span><span>:</span> <span>false</span>
      <span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>onChildChanged</span><span>(</span><span>val<span>,</span> oldVal</span><span>)</span> <span>{</span> <span>}</span><span>,</span>
    <span>onPersonChanged1</span><span>(</span><span>val<span>,</span> oldVal</span><span>)</span> <span>{</span> <span>}</span>
    <span>onPersonChanged2</span><span>(</span><span>val<span>,</span> oldVal</span><span>)</span> <span>{</span> <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>主要使用以上两个装饰器。</p>
<hr>
<p>以下装饰器很少使用:</p>
<h2 id="model-decorator" tabindex="-1"> @Model() decorator</h2>
<p><code>model</code> 属性的装饰器</p>
<div><pre><code><span>import</span> <span>{</span> Vue<span>,</span> Component<span>,</span> Model <span>}</span> <span>from</span> <span>"vue-property-decorator"</span><span>;</span>

<span><span>@</span><span>Component</span></span>
<span>export</span> <span>default</span> <span>class</span> <span>YourComponent</span> <span>extends</span> <span>Vue</span> <span>{</span>
  <span><span>@</span><span>Model</span></span><span>(</span><span>"change"</span><span>,</span> <span>{</span> type<span>:</span> Boolean <span>}</span><span>)</span> <span>readonly</span> checked<span>!</span><span>:</span> <span>boolean</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>相当于</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  model<span>:</span> <span>{</span>
    prop<span>:</span> <span>"checked"</span><span>,</span>
    event<span>:</span> <span>"change"</span><span>,</span>
  <span>}</span><span>,</span>
  props<span>:</span> <span>{</span>
    checked<span>:</span> <span>{</span>
      type<span>:</span> Boolean<span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="emit-decorator" tabindex="-1"> @Emit() decorator</h2>
<p>由 <code>@Emit $emit</code> 返回值修饰的函数后跟其原始参数。如果返回值是 promise，则在发出之前将其解析。</p>
<p>如果未通过 event 参数提供事件的名称，则使用函数名称。在这种情况下， camelCase 名称将转换为 kebab-case。</p>
<div><pre><code><span>import</span> <span>{</span> Vue<span>,</span> Component<span>,</span> Emit <span>}</span> <span>from</span> <span>"vue-property-decorator"</span><span>;</span>

<span><span>@</span><span>Component</span></span>
<span>export</span> <span>default</span> <span>class</span> <span>YourComponent</span> <span>extends</span> <span>Vue</span> <span>{</span>
  count <span>=</span> <span>0</span><span>;</span>

  <span><span>@</span><span>Emit</span></span><span>(</span><span>)</span>
  <span>addToCount</span><span>(</span>n<span>:</span> <span>number</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>count <span>+=</span> n<span>;</span>
  <span>}</span>

  <span><span>@</span><span>Emit</span></span><span>(</span><span>"reset"</span><span>)</span>
  <span>resetCount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>count <span>=</span> <span>0</span><span>;</span>
  <span>}</span>

  <span><span>@</span><span>Emit</span></span><span>(</span><span>)</span>
  <span>returnValue</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>10</span><span>;</span>
  <span>}</span>

  <span><span>@</span><span>Emit</span></span><span>(</span><span>)</span>
  <span>promise</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span><span>Promise</span></span><span>(</span><span>(</span>resolve<span>)</span> <span>=></span> <span>{</span>
      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>resolve</span><span>(</span><span>20</span><span>)</span><span>;</span>
      <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>相当于</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>count</span><span>:</span> <span>0</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
  <span>methods</span><span>:</span> <span>{</span>
    <span>addToCount</span><span>(</span><span>n</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>count <span>+=</span> n<span>;</span>
      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>"add-to-count"</span><span>,</span> n<span>)</span><span>;</span>
    <span>}</span><span>,</span>
    <span>resetCount</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>count <span>=</span> <span>0</span><span>;</span>
      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>"reset"</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
    <span>returnValue</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>$emit</span><span>(</span><span>"return-value"</span><span>,</span> <span>10</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
    <span>promise</span><span>(</span><span>)</span> <span>{</span>
      <span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>resolve</span><span>(</span><span>20</span><span>)</span><span>;</span>
        <span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>

      promise<span>.</span><span>then</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>
        <span>this</span><span>.</span><span>$emit</span><span>(</span><span>"promise"</span><span>,</span> value<span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="provide-decorator" tabindex="-1"> @Provide() decorator</h2>
<div><pre><code><span>import</span> <span>{</span> Component<span>,</span> Inject<span>,</span> Provide<span>,</span> Vue <span>}</span> <span>from</span> <span>"vue-property-decorator"</span><span>;</span>

<span>const</span> <span>symbol</span> <span>=</span> <span>Symbol</span><span>(</span><span>"baz"</span><span>)</span><span>;</span>

<span><span>@</span><span>Component</span></span>
<span>export</span> <span>class</span> <span>MyComponent</span> <span>extends</span> <span>Vue</span> <span>{</span>
  <span><span>@</span><span>Inject</span></span><span>(</span><span>)</span> <span>readonly</span> foo<span>!</span><span>:</span> <span>string</span><span>;</span>
  <span><span>@</span><span>Inject</span></span><span>(</span><span>"bar"</span><span>)</span> <span>readonly</span> bar<span>!</span><span>:</span> <span>string</span><span>;</span>
  <span><span>@</span><span>Inject</span></span><span>(</span><span>{</span> from<span>:</span> <span>"optional"</span><span>,</span> <span>default</span><span>:</span> <span>"default"</span> <span>}</span><span>)</span> <span>readonly</span> optional<span>!</span><span>:</span> <span>string</span><span>;</span>
  <span><span>@</span><span>Inject</span></span><span>(</span><span>symbol</span><span>)</span> <span>readonly</span> baz<span>!</span><span>:</span> <span>string</span><span>;</span>

  <span><span>@</span><span>Provide</span></span><span>(</span><span>)</span> foo <span>=</span> <span>"foo"</span><span>;</span>
  <span><span>@</span><span>Provide</span></span><span>(</span><span>"bar"</span><span>)</span> baz <span>=</span> <span>"bar"</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>相当于</p>
<div><pre><code><span>const</span> symbol <span>=</span> <span>Symbol</span><span>(</span><span>"baz"</span><span>)</span><span>;</span>

<span>export</span> <span>const</span> MyComponent <span>=</span> Vue<span>.</span><span>extend</span><span>(</span><span>{</span>
  <span>inject</span><span>:</span> <span>{</span>
    <span>foo</span><span>:</span> <span>"foo"</span><span>,</span>
    <span>bar</span><span>:</span> <span>"bar"</span><span>,</span>
    <span>optional</span><span>:</span> <span>{</span> <span>from</span><span>:</span> <span>"optional"</span><span>,</span> <span>default</span><span>:</span> <span>"default"</span> <span>}</span><span>,</span>
    <span>[</span>symbol<span>]</span><span>:</span> symbol<span>,</span>
  <span>}</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>foo</span><span>:</span> <span>"foo"</span><span>,</span>
      <span>baz</span><span>:</span> <span>"bar"</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
  <span>provide</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      <span>foo</span><span>:</span> <span>this</span><span>.</span>foo<span>,</span>
      <span>bar</span><span>:</span> <span>this</span><span>.</span>baz<span>,</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="ts-组件案例" tabindex="-1"> TS 组件案例</h2>
<ul>
<li><a href="/code/vue/ts-demo.html">点击此处</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>TypeScript 组件 Demo</title>
      <link>https://shimonzhan.com/code/vue/ts-demo.html</link>
      <guid>https://shimonzhan.com/code/vue/ts-demo.html</guid>
      <source url="https://shimonzhan.com/rss.xml">TypeScript 组件 Demo</source>
      <category>基础</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="typescript-组件-demo" tabindex="-1"> TypeScript 组件 Demo</h1>
<p>BaseList.vue 组件:</p>
<div><pre><code><span>&lt;!--
 * @Author: Shimon Zhan
 * @LastEditors: Shimon Zhan
 * @Description: 基础列表
 * @Date: 2019-03-25 12:39:59
 * @LastEditTime: 2020-03-22 22:50:34
--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>:id</span><span><span>=</span><span>"</span>myId<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>Ctn<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>template</span> <span>v-if</span><span><span>=</span><span>"</span>head !== false<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>d-block d-lg-none commonhead<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>head<span>"</span></span><span>/></span></span>
      <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>d-none d-lg-block myH3<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>head<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>Lctn<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>template</span> <span>v-for</span><span><span>=</span><span>"</span>List in listItem<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>div</span>
          <span>:class</span><span><span>=</span><span>"</span>List.url || List.aim ? <span>'</span>btn btn-light <span>'</span> : <span>'</span><span>'</span><span>"</span></span>
          <span>:id</span><span><span>=</span><span>"</span>List.id<span>"</span></span>
          <span>:key</span><span><span>=</span><span>"</span>List.text<span>"</span></span>
          <span>class</span><span><span>=</span><span>"</span>listCtn<span>"</span></span>
          <span>v-if</span><span><span>=</span><span>"</span>List.display !== false &amp;&amp; (List.url || List.aim)<span>"</span></span>
        <span>></span></span>
          <span><span><span>&lt;</span>div</span> <span>@click</span><span><span>=</span><span>"</span>navigate(List.aim)<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>list-Container<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>List.aim<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>img</span> <span>:src</span><span><span>=</span><span>"</span>`/img${List.icon}`<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>listIcon<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>List.icon<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>LinkText<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>List.text<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>linkDesciption access<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>List.desc<span>"</span></span><span>/></span></span>
          <span><span><span>&lt;/</span>div</span><span>></span></span>
          <span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>"</span>List.url<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>list-Container<span>"</span></span> <span>v-else-if</span><span><span>=</span><span>"</span>List.url<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>img</span> <span>:src</span><span><span>=</span><span>"</span>List.icon<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>listIcon<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>List.icon<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>LinkText<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>List.text<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>linkDesciption access<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>List.desc<span>"</span></span><span>/></span></span>
          <span><span><span>&lt;/</span>router-link</span><span>></span></span>
          <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>list-Container<span>"</span></span> <span>v-else</span><span>></span></span>
            <span><span><span>&lt;</span>img</span> <span>:src</span><span><span>=</span><span>"</span>`/img${List.icon}`<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>listIcon<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>List.icon<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>LinkText<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>List.text<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>linkDesciption<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>List.desc<span>"</span></span><span>/></span></span>
          <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span>
          <span>:class</span><span><span>=</span><span>"</span>List.icon ? <span>'</span>listIconDivline<span>'</span> : <span>'</span><span>'</span><span>"</span></span>
          <span>:key</span><span><span>=</span><span>"</span>List.textKey<span>"</span></span>
          <span>class</span><span><span>=</span><span>"</span>link-divline<span>"</span></span>
          <span>v-if</span><span><span>=</span><span>"</span>List.display !== false<span>"</span></span>
        <span>/></span></span>
      <span><span><span>&lt;/</span>template</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>commonfoot<span>"</span></span> <span>v-if</span><span><span>=</span><span>"</span>foot<span>"</span></span> <span>v-text</span><span><span>=</span><span>"</span>foot<span>"</span></span><span>/></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span> <span>lang</span><span><span>=</span><span>"</span>ts<span>"</span></span><span>></span></span>
import { Component, Prop, Vue } from 'vue-property-decorator';

interface List {
  [propName: string]: string;
}

@Component
export default class BaseList extends Vue {
  // Component ID
  @Prop(Number) private readonly myId!: number;

  // List content
  @Prop({ type: Array, required: true }) private readonly content!: List[];

  // List head text
  @Prop({ type: [String, Boolean], default: '' }) private readonly head!: string | boolean;

  // List footer text
  @Prop({ type: [String, Boolean], default: '' }) private readonly foot!: string | boolean;

  private get listItem() {
    // create a copy of @Prop('content)
    const listItem = JSON.parse(JSON.stringify(this.content));

    // Add key and item for the listitem in the copy
    listItem.forEach((element: List, index: number) => {
      if (this.myId) element.id = `list${this.myId}-${index}`;
      element.textKey = `${element.text}Key`;
    });

    return listItem;
  }

  // Navigate when clicking on a link
  private navigate(aim: string) {
    this.$router.push(`/handbook/${aim}`);
  }
}
<span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>style</span> <span>scope</span><span>></span></span>
.Ctn {
  margin: 0 -15px;
  width: auto;
}

.myH3 {
  width: 100%;
  max-width: 600px;
  text-align: left;
  font-weight: 500;
  padding: 12px 18px 6px 18px;
  min-height: 18px;
  font-size: 18px;
  max-width: 600px;
  margin: 0 auto;
}

@media (min-width: 768px) {
  .Ctn {
    margin: 0 auto;
  }
}

.commonfoot,
.commonhead {
  font-size: 13px;
  color: #666;
  margin: 0 auto;
}

.commonhead {
  min-height: 9px;
  padding: 23px 15px 5px 15px;
}

.commonfoot {
  padding: 5px 15px 0 15px;
}

@media (min-width: 992px) {
  .commonfoot {
    font-size: 14px;
    padding: 12px 5% 4px 5%;
    max-width: 600px;
  }
}

.nm .commonhead {
  color: #fff;
}

.LinkText,
.commonhead,
.commonfoot {
  text-align: left;
}

.Lctn {
  background-color: #fefefe;
  width: 100%;
  position: relative;
}

.Lctn:after,
.Lctn:before {
  content: ' ';
  position: absolute;
  left: 0;
  right: 0;
  height: 1px;
  color: #cac9ce;
}

.Lctn:after {
  bottom: 0;
  border-bottom: 1px solid #cac9ce;
  -webkit-transform-origin: 0 100%;
  transform-origin: 0 100%;
  -webkit-transform: scaleY(0.4);
  transform: scaleY(0.4);
}

.Lctn:before {
  top: 0;
  border-top: 1px solid #cac9ce;
  -webkit-transform-origin: 0 0;
  transform-origin: 0 0;
  -webkit-transform: scaleY(0.4);
  transform: scaleY(0.4);
}

@media (min-width: 600px) {
  .Lctn:before {
    top: 0;
    right: auto;
    left: 0;
    width: 200%;
    height: 200%;
    border: 1px solid #cac9ce;
    -webkit-transform-origin: 0 0;
    transform-origin: 0 0;
    -webkit-transform: scale(0.5);
    transform: scale(0.5);
  }

  .Lctn:after {
    display: none;
  }
}

.nm .Lctn:after,
.nm .Lctn:before {
  border-color: #353631;
}

.listCtn {
  width: 100%;
  padding: 0 15px;
  font-size: 17px;
  line-height: 1.45;
  border-radius: 0;
  border: none;
  color: #000;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.listCtn:active {
  background-color: #ececec;
}

.listCtn:empty {
  padding: 0;
}

.nm .listCtn {
  background-color: #000;
  color: #fff !important;
}

.LinkText {
  padding: 10px 0;
  line-height: 1.5;
}

.listIcon {
  width: 26px;
  height: 26px;
  margin-right: 10px;
}

.list-Container {
  position: relative;
  display: -webkit-flex;
  display: flex;
  -webkit-align-items: center;
  align-items: center;
}

.list-Container,
.LinkText {
  -webkit-flex: 1;
  flex: 1;
}

.linkDesciption {
  color: #999 !important;
  text-align: right;
}

.access {
  padding-right: 15px;
  position: relative;
}

.access:after {
  content: ' ';
  display: inline-block;
  width: 7px;
  height: 7px;
  border-width: 2px 2px 0 0;
  border-style: solid;
  -webkit-transform: matrix(0.71, 0.71, -0.71, 0.71, 0, 0);
  transform: matrix(0.71, 0.71, -0.71, 0.71, 0, 0);
  position: absolute;
  top: 50%;
  margin-top: -5px;
  right: 2px;
  border-color: #c7c7cc;
}

.nm .access:after {
  border-color: #383833;
}

.link-divline {
  position: relative;
}

.link-divline:after {
  content: ' ';
  position: absolute;
  left: 15px;
  bottom: 0;
  right: 0;
  height: 1px;
  color: #cac9ce;
  border-bottom: 1px solid #cac9ce;
  -webkit-transform-origin: 0 100%;
  transform-origin: 0 100%;
  -webkit-transform: scaleY(0.4);
  transform: scaleY(0.4);
}

.listIcon.link-divline {
  width: 100%;
  height: 0;
}

.listIcon.link-divline:after {
  left: 50px;
}

.nm .link-divline:after {
  border-color: #353631;
}

.link-divline:last-child:after {
  display: none;
}

.nm .Lctn {
  background-color: #000;
  color: #fff;
}

.nm .LinkText {
  color: #fff;
}

.btn-fix {
  color: #212529;
  background-color: #f8f9fa;
  border-color: #f8f9fa;
}
<span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在本组件中，js 里 <code>props</code> 的写法变成了 <code>@Prop()</code>，同时 <code>compute</code> 属性变成了 <code>get</code>，<code>methods</code> 和生命周期一同直接写在了类中。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 单文件组件说明</title>
      <link>https://shimonzhan.com/code/vue/vue.html</link>
      <guid>https://shimonzhan.com/code/vue/vue.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Vue 单文件组件说明</source>
      <category>Vue</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="vue-单文件组件说明" tabindex="-1"> Vue 单文件组件说明</h1>
<p>Vue 文件即是一个组件文件，组件文件既可以成为其他 vue 文件的一个组件，又可以添加到 router 中成为一个页面视图。</p>
<p>Vue 文件主要由三部分构成:</p>
<ul>
<li>
<p><code>template</code> 对应网站视图树，即 HTML 部分</p>
</li>
<li>
<p><code>script</code> 对应网站的脚本。即 js 部分，默认为 Javascript，可以添加 <code>lang=&quot;ts&quot;</code> 来指定页面脚本文件为 <code>Typescript</code></p>
</li>
<li>
<p><code>style</code> 对应网站的样式，即 CSS 部分，可以通过添加 <code>scoped</code> 属性来指定样式只在当前文件生效。</p>
</li>
</ul>
<p>在脚本部分中，如有需要，需要使用 <code>export default{}</code> 向外暴露一个对象以供 Router 或其他 Vue 文件引用。</p>
<p>在 HTML 标签中，由于页面都被 Router 托管，如需要跳转到本网站的其他视图上去，需要使用 <code>&lt;route-link to=&quot;内部url地址&quot;&gt;链接文字&lt;/route-link&gt;</code></p>
<hr>
<p>下面是学校公众号界面</p>
<div><pre><code><span>&lt;</span>template<span>></span>
  <span>&lt;</span>div <span>class</span><span>=</span><span>"container"</span><span>></span>
    <span>&lt;</span>h2 <span>class</span><span>=</span><span>"px-3 pt-3"</span><span>></span>学院微信<span>&lt;</span><span>/</span>h2<span>></span>
    <span>&lt;</span>hr <span>class</span><span>=</span><span>"mx-3"</span> <span>/</span><span>></span>
    <span>&lt;</span>div <span>class</span><span>=</span><span>"row px-3"</span><span>></span>
      <span>&lt;</span>a
        <span>:</span>href<span>=</span><span>"item.url"</span>
        <span>:</span>key<span>=</span><span>"item.text"</span>
        <span>class</span><span>=</span><span>"col-4 col-sm-3 col-md-2 col-lg-1 col-fix"</span>
        v<span>-</span><span>for</span><span>=</span><span>"item in gzh"</span>
      <span>></span>
        <span>&lt;</span>img
          <span>:</span>src<span>=</span><span>"require(`@/icon/function/schoolGzh/${item.src}.jpg`)"</span>
          <span>class</span><span>=</span><span>"img-thumbnail mt-1 img-fix"</span>
          style<span>=</span><span>"border-radius:50%;"</span>
        <span>/</span><span>></span>
        <span>&lt;</span>p <span>class</span><span>=</span><span>"mx-1 my-2 gzhName"</span><span>></span><span>{</span><span>{</span> item<span>.</span>text <span>}</span><span>}</span><span>&lt;</span><span>/</span>p<span>></span>
      <span>&lt;</span><span>/</span>a<span>></span>
    <span>&lt;</span><span>/</span>div<span>></span>
  <span>&lt;</span><span>/</span>div<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>
<span>&lt;</span>script<span>></span>
<span>export</span> <span>default</span> <span>{</span>
  <span>name</span><span>:</span> <span>"SchoolGzh"</span><span>,</span>
  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span>
    <span>gzh</span><span>:</span> <span>[</span>
      <span>{</span>
        <span>url</span><span>:</span>
          <span>"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzA3NTM3MTkzOQ==&amp;scene=110#wechat_redirect"</span><span>,</span>
        <span>text</span><span>:</span> <span>"美术学院"</span><span>,</span>
        <span>src</span><span>:</span> <span>"art"</span>
      <span>}</span><span>,</span>
      <span>// ...中间的学院数据在此省略</span>
      <span>{</span>
        <span>url</span><span>:</span>
          <span>"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzIwMzI0NTE0NQ==#wechat_webview_type=1&amp;wechat_redirect"</span><span>,</span>
        <span>text</span><span>:</span> <span>"纽瓦克学院"</span><span>,</span>
        <span>src</span><span>:</span> <span>"runin"</span>
      <span>}</span>
    <span>]</span>
  <span>}</span><span>)</span>
<span>}</span><span>;</span>
<span>&lt;</span><span>/</span>script<span>></span>
<span>&lt;</span>style scoped<span>></span>
<span>.</span>col<span>-</span>fix <span>{</span>
  <span>padding</span><span>:</span> <span>0</span> 5px<span>;</span>
<span>}</span>
<span>.</span>img<span>-</span>fix <span>{</span>
  <span>width</span><span>:</span> <span>90</span><span>%</span><span>;</span>
  <span>margin</span><span>:</span> <span>0</span><span>.</span>25rem <span>5</span><span>%</span> <span>0</span> <span>5</span><span>%</span><span>;</span>
<span>}</span>
<span>.</span>gzhName <span>{</span>
  text<span>-</span>align<span>:</span> center<span>;</span>
  <span>color</span><span>:</span> #<span>000</span><span>;</span>
  font<span>-</span>size<span>:</span> 14px<span>;</span>
<span>}</span>
<span>&lt;</span><span>/</span>style<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是网站的 404 页面</p>
<div><pre><code><span>&lt;</span>template<span>></span>
  <span>&lt;</span>div <span>class</span><span>=</span><span>"container"</span><span>></span>
    <span>&lt;</span>h1 mt<span>-</span><span>1</span><span>></span>Page not found<span>&lt;</span><span>/</span>h1<span>></span>
    <span>&lt;</span>p<span>></span>
      很抱歉并未找到您打开的界面，可能是您输入的路径有误，网页尚未制作或者出现了一个bug。
    <span>&lt;</span><span>/</span>p<span>></span>
    <span>&lt;</span>p<span>></span>
      您可以反馈给
      <span>&lt;</span>router<span>-</span>link
        to<span>=</span><span>"http://wpa.qq.com/msgrd?v=3&amp;amp;uin=1178522294&amp;amp;site=qq&amp;amp;menu=yes"</span>
        <span>></span>Shimon Zhan<span>&lt;</span><span>/</span>router<span>-</span>link
      <span>></span>
    <span>&lt;</span><span>/</span>p<span>></span>
  <span>&lt;</span><span>/</span>div<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>
<span>&lt;</span>script<span>></span>
<span>export</span> <span>default</span><span>{</span>
  <span>name</span><span>:</span> <span>"Page404"</span>
<span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>网页入门</title>
      <link>https://shimonzhan.com/code/website/</link>
      <guid>https://shimonzhan.com/code/website/</guid>
      <source url="https://shimonzhan.com/rss.xml">网页入门</source>
      <description>网页需要三件套: HTML、CSS 和 JavaScript。

HTML 定义了网页的内容
CSS 描述了网页的样式
JavaScript 编写网页的行为

</description>
      <category>前端</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>

<div><p>提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用三大框架(、、)搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如、等。</p>
</div>
<div><p>网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2 id="html" tabindex="-1"> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="/code/website/html/">HTML 教程</a></li>
</ul>
<h2 id="css" tabindex="-1"> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="/code/website/css/">CSS 教程</a></li>
</ul>
<h2 id="emmet" tabindex="-1"> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="/code/website/emmet/">Emmet 用法介绍</a></li>
</ul>
<h2 id="javascript" tabindex="-1"> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="/code/website/js.html">JS 教程</a></li>
</ul>
<h3 id="typescript" tabindex="-1"> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="/code/language/typescript/">TypeScript 教程</a></li>
</ul>
<h2 id="node-js" tabindex="-1"> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="/code/node-js/">Node.js 教程</a></li>
</ul>
<h2 id="历史前端框架" tabindex="-1"> 历史前端框架</h2>
<h3 id="jquery" tabindex="-1"> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 MVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="/code/website/jQuery/">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="bootstrap4" tabindex="-1"> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2 id="现代前端框架" tabindex="-1"> 现代前端框架</h2>
<h3 id="vue" tabindex="-1"> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<p>Vue 与 React、Angular 一起合称前端三大框架。</p>
<ul>
<li>
<p><a href="/code/vue/">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3 id="react" tabindex="-1"> React</h3>
<ul>
<li><a href="/code/react/">React 教程</a></li>
</ul>
<h3 id="angular" tabindex="-1"> Angular</h3>
<ul>
<li><a href="/code/angular/">Angular 教程</a></li>
</ul>
<h2 id="其他文档" tabindex="-1"> 其他文档</h2>
<ul>
<li><a href="/code/website/https.html">HTTPS 介绍</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Http 与 Https 介绍</title>
      <link>https://shimonzhan.com/code/website/https.html</link>
      <guid>https://shimonzhan.com/code/website/https.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Http 与 Https 介绍</source>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是-http-协议" tabindex="-1"> 什么是 HTTP 协议</h2>
<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>
<p><img src="@source/code/website/assets/http1.jpg" alt="Http 漫画" loading="lazy"></p>
<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>
<p><img src="@source/code/website/assets/http2.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>
<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>
<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>
<p><img src="@source/code/website/assets/http3.jpg" alt="Http 漫画" loading="lazy"></p>
<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>
<p><img src="@source/code/website/assets/http4.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http5.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http6.jpg" alt="Http 漫画" loading="lazy"></p>
<p>如何进行加密呢?</p>
<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p><img src="@source/code/website/assets/http7.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http8.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这样做是不是就绝对安全了呢? 并不是。</p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<p><img src="@source/code/website/assets/http9.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>
<p><img src="@source/code/website/assets/http10.jpg" alt="Http 漫画" loading="lazy"></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>
<p><img src="@source/code/website/assets/http11.jpg" alt="Http 漫画" loading="lazy"></p>
<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>
<p><img src="@source/code/website/assets/http12.jpg" alt="Http 漫画" loading="lazy"></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>
<p><img src="@source/code/website/assets/http13.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http14.jpg" alt="Http 漫画" loading="lazy"></p>
<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>
<p><img src="@source/code/website/assets/http15.jpg" alt="Http 漫画" loading="lazy"></p>
<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>
<p><img src="@source/code/website/assets/http16.jpg" alt="Http 漫画" loading="lazy"></p>
<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>
<p><img src="@source/code/website/assets/http17.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http18.jpg" alt="Http 漫画" loading="lazy"></p>
<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>
<p>到底什么是证书呢? 证书包含如下信息:</p>
<p><img src="@source/code/website/assets/http19.jpg" alt="Http 漫画" loading="lazy"></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下:</p>
<ol>
<li>
<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>
<p><img src="@source/code/website/assets/http20.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>
<p><img src="@source/code/website/assets/http21.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p><img src="@source/code/website/assets/http22.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>
<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>
<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>
<p><img src="@source/code/website/assets/http23.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>
<p><img src="@source/code/website/assets/http24.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
<li>
<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>
<p><img src="@source/code/website/assets/http25.jpg" alt="Http 漫画" loading="lazy"></p>
</li>
</ol>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>
<p><img src="@source/code/website/assets/http26.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http27.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http28.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http29.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http30.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http31.jpg" alt="Http 漫画" loading="lazy"></p>
<p><img src="@source/code/website/assets/http32.jpg" alt="Http 漫画" loading="lazy"></p>
<div><p>相关信息</p>
<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 教程</title>
      <link>https://shimonzhan.com/code/website/js.html</link>
      <guid>https://shimonzhan.com/code/website/js.html</guid>
      <source url="https://shimonzhan.com/rss.xml">JavaScript 教程</source>
      <category>JavaScript</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="初学者教程" tabindex="-1"> 初学者教程</h2>
<ul>
<li><a href="/code/language/js/guide/">快速上手</a></li>
</ul>
<h3 id="javascript-手册" tabindex="-1"> JavaScript 手册</h3>
<ul>
<li><a href="/code/language/js/">JavaScript 学习教程</a></li>
</ul>
<h3 id="在线教程" tabindex="-1"> 在线教程</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3 id="es6" tabindex="-1"> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="/code/language/js/es6/">ES6 教程</a></li>
</ul>
<div><p>提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="/code/language/js/guide/">JS 快速入门章节</a> 了解 JavaScript，或 <a href="/code/language/js/">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Git</title>
      <link>https://shimonzhan.com/software/git/</link>
      <guid>https://shimonzhan.com/software/git/</guid>
      <source url="https://shimonzhan.com/rss.xml">Git</source>
      <description>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。
交互式学习
如果您觉得本文太枯燥，这里有一个 交互式的分支演示与学习网站。您可以在这里领略 Git 的魅力。
但 Shimon Zhan 仍建议您操作完再系统的学习并阅读以下内容。

</description>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>
<div><p>交互式学习</p>
<p>如果您觉得本文太枯燥，这里有一个 <a href="http://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">交互式的分支演示与学习网站</a>。您可以在这里领略 Git 的魅力。</p>
<p>但 Shimon Zhan 仍建议您操作完再系统的学习并阅读以下内容。</p>
</div>

<h2 id="git-安装" tabindex="-1"> Git 安装</h2>
<ul>
<li><a href="/software/git/install.html">安装教程</a></li>
</ul>
<h2 id="git-教程" tabindex="-1"> Git 教程</h2>
<ul>
<li>
<p><a href="/software/git/intro.html">Git 介绍</a></p>
</li>
<li>
<p><a href="/software/git/create-repo.html">创建版本库</a></p>
</li>
<li>
<p><a href="/software/git/status.html">纵向查看</a></p>
</li>
<li>
<p><a href="/software/git/recall.html">撤销操作</a></p>
</li>
<li>
<p><a href="/software/git/reset.html">版本回退</a></p>
</li>
<li>
<p><a href="/software/git/working-directory.html">工作区和暂存区</a></p>
</li>
<li>
<p><a href="/software/git/change.html">修改管理</a></p>
</li>
<li>
<p><a href="/software/git/remote.html">远程仓库</a></p>
</li>
<li>
<p><a href="/software/git/branch.html">分支管理</a></p>
</li>
<li>
<p><a href="/software/git/tag.html">标签管理</a></p>
</li>
<li>
<p><a href="/software/git/ignore.html">忽略特殊文件</a></p>
</li>
</ul>
<h2 id="深入-git" tabindex="-1"> 深入 Git</h2>
<ul>
<li>
<p><a href="/software/git/working.html">Git 原理</a></p>
</li>
<li>
<p><a href="/software/git/custom.html">自定义 Git</a></p>
</li>
<li>
<p><a href="/software/git/gitLFS.html">大文件管理存储</a></p>
</li>
<li>
<p><a href="/software/git/server.html">搭建 Git 服务器</a></p>
</li>
</ul>
<h2 id="扩展阅读" tabindex="-1"> 扩展阅读</h2>
<ul>
<li>
<p><a href="https://git-scm.com/doc" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/git/gitCheatSheet.pdf" target="_blank" rel="noopener noreferrer">Git-cheatSheet</a> (PDF)</p>
</li>
<li>
<p><a href="https://mrhope.site/file/git/progit_v2.1.45.pdf" target="_blank" rel="noopener noreferrer">Pro Git</a> (PDF)</p>
</li>
</ul>
<div><p>TODO</p>
<ol>
<li>完善分支合并部分，加入更多命令介绍。如 <code>cherry-pick</code> <code>squash-merge</code>。</li>
<li>介绍 Git Hook</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>分支管理</title>
      <link>https://shimonzhan.com/software/git/branch.html</link>
      <guid>https://shimonzhan.com/software/git/branch.html</guid>
      <source url="https://shimonzhan.com/rss.xml">分支管理</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="概述" tabindex="-1"> 概述</h2>
<p>分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN!</p>
<p><img src="@source/software/git/assets/learn-branches.png" alt="Learn branches" loading="lazy"></p>
<p>分支在实际中有什么用呢? 假设您准备开发一个新功能，但是需要两周才能完成，第一周您写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。您创建了一个属于您自己的分支，别人看不到，还继续在原来的分支上正常工作，而您在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如 SVN 等都有分支管理，但是用过之后您会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成! 无论您的版本库是 1 个文件还是 1 万个文件。</p>
<h2 id="创建与合并分支" tabindex="-1"> 创建与合并分支</h2>
<p>在版本回退里，您已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 <code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<code>HEAD</code> 指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点:</p>
<p><img src="@source/software/git/assets/git6.png" alt="示意图" loading="lazy"></p>
<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着您不断提交，<code>master</code> 分支的线也越来越长:</p>
<p>当我们创建新的分支，例如 dev 时，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前分支在 dev 上:</p>
<p><img src="@source/software/git/assets/git7.png" alt="示意图" loading="lazy"></p>
<p>您看，Git 创建一个分支很快，因为除了增加一个 <code>dev</code> 指针，改改 <code>HEAD</code> 的指向，工作区的文件都没有任何变化!</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，<code>dev</code> 指针往前移动一步，而 <code>master</code> 指针不变:</p>
<p><img src="@source/software/git/assets/git8.png" alt="示意图" loading="lazy"></p>
<p>假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。Git 怎么合并呢? 最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并:</p>
<p><img src="@source/software/git/assets/git9.png" alt="示意图" loading="lazy"></p>
<p>所以 Git 合并分支也很快! 就改改指针，工作区内容也不变!</p>
<p>合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删掉，删掉后，我们就剩下了一条 master 分支:</p>
<p><img src="@source/software/git/assets/git10.png" alt="示意图" loading="lazy"></p>
<p>下面开始实战。首先，我们创建 dev 分支，然后切换到 dev 分支:</p>
<div><pre><code>$ <span>git</span> checkout -b dev
Switched to a new branch <span>'dev'</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令:</p>
<div><pre><code>$ <span>git</span> branch dev
<span># nothing</span>
$ <span>git</span> checkout dev
Switched to branch <span>'dev'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>然后，用 <code>git branch</code> 命令查看当前分支:</p>
<div><pre><code>$ <span>git</span> branch
* dev
  master
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个 <code>*</code> 号。</p>
<p>然后，我们就可以在 dev 分支上正常提交，比如对 <code>readme.txt</code> 做个修改，加上一行:</p>
<div><pre><code>Creating a new branch is quick.
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"branch test"</span>
<span>[</span>dev b17d20e<span>]</span> branch <span>test</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，dev 分支的工作完成，我们就可以切换回 master 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>切换回 master 分支后，再查看一个 <code>readme.txt</code> 文件，刚才添加的内容不见了! 因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变:</p>
<p><img src="@source/software/git/assets/git11.png" alt="示例图" loading="lazy"></p>
<p>现在，我们把 dev 分支的工作成果合并到 master 分支上:</p>
<div><pre><code>$ <span>git</span> merge dev
Updating d46f35e<span>..</span>b17d20e
Fast-forward
 readme.txt <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><code>git merge</code> 命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。</p>
<p>注意到上面的 <code>Fast-forward</code> 信息，Git 告诉我们，这次合并是 “快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 <code>Fast-forward</code>。合并完成后，就可以放心地删除 dev 分支了:</p>
<div><pre><code>$ <span>git</span> branch -d dev
Deleted branch dev <span>(</span>was b17d20e<span>)</span>.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>删除后，查看 <code>branch</code>，就只剩下 <code>master</code> 分支了:</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>因为创建、合并和删除分支非常快，所以 Git 鼓励您使用分支完成某个任务，合并后再删掉分支，这和直接在 <code>master</code> 分支上工作效果是一样的，但过程更安全。</p>
<h3 id="分支小结" tabindex="-1"> 分支小结</h3>
<ul>
<li>
<p>查看分支: <code>git branch</code></p>
</li>
<li>
<p>创建分支: <code>git branch &lt;name&gt;</code></p>
</li>
<li>
<p>切换分支: <code>git checkout &lt;name&gt;</code></p>
</li>
<li>
<p>创建+切换分支: <code>git checkout -b &lt;name&gt;</code></p>
</li>
<li>
<p>合并某分支到当前分支: <code>git merge &lt;name&gt;</code></p>
</li>
<li>
<p>删除分支: <code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<hr>
<h2 id="冲突" tabindex="-1"> 冲突</h2>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的 <code>feature1</code> 分支，继续我们的新分支开发:</p>
<div><pre><code>$ <span>git</span> checkout -b feature1
Switched to a new branch <span>'feature1'</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>修改 readme.txt 最后一行，改为:</p>
<div><pre><code>Creating a new branch is quick AND simple.
</code></pre><div aria-hidden="true"><div></div></div></div><p>在 <code>feature1</code> 分支上提交:</p>
<div><pre><code>git add readme.txt

\$ git commit -m "AND simple"
[feature1 14096d0] AND simple
1 file changed, 1 insertion(+), 1 deletion(-)
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>切换到 <code>master</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>1</span> commit.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>Git 还会自动提示我们当前 <code>master</code> 分支比远程的 <code>master</code> 分支要超前 1 个提交。</p>
<p>在 <code>master</code> 分支上把 readme.txt 文件的最后一行改为:</p>
<div><pre><code>Creating a new branch is quick &amp; simple.
</code></pre><div aria-hidden="true"><div></div></div></div><p>提交:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
$ <span>git</span> commit -m <span>"&amp; simple"</span>
<span>[</span>master 5dc6824<span>]</span> <span>&amp;</span> simple
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支各自都分别有新的提交，变成了这样:</p>
<p><img src="@source/software/git/assets/git12.png" alt="示例图" loading="lazy"></p>
<p>这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看:</p>
<div><pre><code>$ <span>git</span> merge feature1
Auto-merging readme.txt
CONFLICT <span>(</span>content<span>)</span>: Merge conflict <span>in</span> readme.txt
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>果然冲突了! Git 告诉我们，<code>readme.txt</code> 文件存在冲突，必须手动解决冲突后再提交。<code>git status</code> 也可以告诉我们冲突的文件:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is ahead of <span>'origin/master'</span> by <span>2</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

You have unmerged paths.
  <span>(</span>fix conflicts and run <span>"git commit"</span><span>)</span>
  <span>(</span>use <span>"git merge --abort"</span> to abort the merge<span>)</span>

Unmerged paths:
  <span>(</span>use <span>"git add &lt;file>..."</span> to mark resolution<span>)</span>

    both modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们可以直接查看 readme.txt 的内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
<span><span>&lt;</span><span>&lt;&lt;&lt;&lt;&lt;&lt; HEAD
</span></span>Creating a new branch is quick &amp; simple.
=======
Creating a new branch is quick AND simple.
<span><span>></span><span>>>>>>> feature1
</span></span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Git 用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容，我们修改如下后保存:</p>
<div><pre><code>Creating a new branch is quick and simple.
</code></pre><div aria-hidden="true"><div></div></div></div><p>再提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"conflict fixed"</span>
<span>[</span>master cf810e4<span>]</span> conflict fixed
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支变成了下图所示:</p>
<p><img src="@source/software/git/assets/git13.png" alt="示例图" loading="lazy"></p>
<p>用带参数的 <code>git log</code> 也可以看到分支的合并情况:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   cf810e4 <span>(</span>HEAD -<span>></span> master<span>)</span> conflict fixed
<span>|</span><span>\</span>
<span>|</span> * 14096d0 <span>(</span>feature1<span>)</span> AND simple
* <span>|</span> 5dc6824 <span>&amp;</span> simple
<span>|</span>/
* b17d20e branch <span>test</span>
* d46f35e <span>(</span>origin/master<span>)</span> remove test.txt
* b84166e <span>add</span> test.txt
* 519219b <span>git</span> tracks changes
* e43a48b understand how stage works
* 1094adb append GPL
* e475afc <span>add</span> distributed
* eaadf4e wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最后，删除 feature1 分支:</p>
<div><pre><code>$ <span>git</span> branch -d feature1
Deleted branch feature1 <span>(</span>was 14096d0<span>)</span>.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="冲突小结" tabindex="-1"> 冲突小结</h3>
<ul>
<li>
<p>当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。</p>
</li>
<li>
<p>用 <code>git log --graph</code> 命令可以看到分支合并图。</p>
</li>
</ul>
<h2 id="分支管理策略" tabindex="-1"> 分支管理策略</h2>
<p>通常，合并分支时，如果可能，Git 会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>
<p>实战一下 <code>--no-ff</code> 方式的 <code>git merge</code>。首先，仍然创建并切换 <code>dev</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout -b dev
Switched to a new branch <span>'dev'</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>修改 readme.txt 文件，并提交一个新的 <code>commit</code>:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> commit -m <span>"add merge"</span>
<span>[</span>dev f52c633<span>]</span> <span>add</span> merge
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，我们切换回 <code>master</code>:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>准备合并 <code>dev</code> 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>:</p>
<div><pre><code>$ <span>git</span> merge --no-ff -m <span>"merge with no-ff"</span> dev
Merge made by the <span>'recursive'</span> strategy.
 readme.txt <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>因为本次合并要创建一个新的 <code>commit</code>，所以加上 <code>-m</code> 参数，把 <code>commit</code> 描述写进去。</p>
<p>合并后，我们用 <code>git log</code> 看看分支历史:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   e1e9c68 <span>(</span>HEAD -<span>></span> master<span>)</span> merge with no-ff
<span>|</span><span>\</span>
<span>|</span> * f52c633 <span>(</span>dev<span>)</span> <span>add</span> merge
<span>|</span>/
*   cf810e4 conflict fixed
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，不使用 <code>Fast forward</code> 模式，<code>merge</code> 后就像这样:</p>
<p><img src="@source/software/git/assets/git14.png" alt="示例图" loading="lazy"></p>
<h3 id="分支管理惯例" tabindex="-1"> 分支管理惯例</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理:</p>
<p>首先，<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢? 干活都在 <code>dev</code> 分支上，也就是说，<code>dev</code> 分支是不稳定的，到某个时候，比如 <code>1.0</code> 版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在 <code>master</code> 分支发布 <code>1.0</code> 版本；</p>
<p>您和您的小伙伴们每个人都在 <code>dev</code> 分支上干活，每个人都有自己的分支，时不时地往 <code>dev</code> 分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样:</p>
<p><img src="@source/software/git/assets/git15.png" alt="示例图" loading="lazy"></p>
<h3 id="分支管理小结" tabindex="-1"> 分支管理小结</h3>
<ul>
<li>
<p>Git 分支十分强大，在团队开发中应该充分应用。</p>
</li>
<li>
<p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 <code>fast forward</code> 合并就看不出来曾经做过合并。</p>
</li>
</ul>
<hr>
<h2 id="bug-分支" tabindex="-1"> Bug 分支</h2>
<p>软件开发中，bug 就像家常便饭一样。有了 bug 就需要修复，在 Git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当您接到一个修复一个代号 101 的 bug 的任务时，很自然地，您想创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 dev 上进行的工作还没有提交:</p>
<div><pre><code>$ <span>git</span> status
On branch dev
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   hello.py

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>并不是您不想提交，而是工作只进行到一半，还没法提交，预计完成还需 1 天时间。但是，必须在两个小时内修复该 bug，怎么办?</p>
<p>幸好，Git 还提供了一个 <code>stash</code> 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作:</p>
<div><pre><code>$ <span>git</span> stash
Saved working directory and index state WIP on dev: f52c633 <span>add</span> merge
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>现在，用 <code>git status</code> 查看工作区，就是干净的(除非有没有被 Git 管理的文件)，因此可以放心地创建分支来修复 bug。</p>
<p>首先确定要在哪个分支上修复 bug，假定需要在 master 分支上修复，就从 master 创建临时分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>6</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

$ <span>git</span> checkout -b issue-101
Switched to a new branch <span>'issue-101'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在修复 bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
$ <span>git</span> commit -m <span>"fix bug 101"</span>
<span>[</span>issue-101 4c805e2<span>]</span> fix bug <span>101</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>修复完成后，切换到 <code>master</code> 分支，并完成合并，最后删除 <code>issue-101</code> 分支:</p>
<div><pre><code>$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
Your branch is ahead of <span>'origin/master'</span> by <span>6</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

$ <span>git</span> merge --no-ff -m <span>"merged bug fix 101"</span> issue-101
Merge made by the <span>'recursive'</span> strategy.
 readme.txt <span>|</span> <span>2</span> +-
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>太棒了，原计划两个小时的 bug 修复只花了 5 分钟! 现在，是时候接着回到 <code>dev</code> 分支干活了!</p>
<div><pre><code>$ <span>git</span> checkout dev
Switched to branch <span>'dev'</span>

$ <span>git</span> status
On branch dev
nothing to commit, working tree clean
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>工作区是干净的，刚才的工作现场存到哪去了? 用 <code>git stash list</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> stash list
stash@<span>{</span><span>0</span><span>}</span>: WIP on dev: f52c633 <span>add</span> merge
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法:</p>
<p>一是用 <code>git stash apply</code> 恢复，但是恢复后，<code>stash</code> 内容并不删除，您需要用 <code>git stash drop</code> 来删除；</p>
<p>另一种方式是用 <code>git stash pop</code>，恢复的同时把 <code>stash</code> 内容也删了:</p>
<div><pre><code>$ <span>git</span> stash pop
On branch dev
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   hello.py

Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

Dropped refs/stash@<span>{</span><span>0</span><span>}</span> <span>(</span>5d677e2ee266f39ea296182fb2354265b91b3b2a<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再用 <code>git stash list</code> 查看，就看不到任何 stash 内容了。您可以多次 stash，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令:</p>
<div><pre><code><span>git</span> stash apply stash@<span>{</span><span>0</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="暂存小结" tabindex="-1"> 暂存小结</h3>
<ul>
<li>
<p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；</p>
</li>
<li>
<p>当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，回到工作现场。</p>
</li>
</ul>
<hr>
<h2 id="feature-分支" tabindex="-1"> Feature 分支</h2>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，您肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个 <code>feature</code> 分支，在上面开发，完成后，合并，最后，删除该 <code>feature</code> 分支。</p>
<p>现在，您终于接到了一个新任务: 开发代号为 <code>Vulcan</code> 的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发:</p>
<div><pre><code>$ <span>git</span> checkout -b feature-vulcan
Switched to a new branch <span>'feature-vulcan'</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>5 分钟后，开发完毕:</p>
<div><pre><code><span>git</span> <span>add</span> vulcan.py

$ <span>git</span> status
On branch feature-vulcan
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   vulcan.py

$ <span>git</span> commit -m <span>"add feature vulcan"</span>
<span>[</span>feature-vulcan 287773e<span>]</span> <span>add</span> feature vulcan
 <span>1</span> <span>file</span> changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> vulcan.py
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>切回 <code>dev</code>，准备合并:</p>
<div><pre><code><span>git</span> checkout dev
</code></pre><div aria-hidden="true"><div></div></div></div><p>一切顺利的话，feature 分支和 bug 分支是类似的，合并，然后删除。</p>
<p>但是!</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消!</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁:</p>
<div><pre><code>$ <span>git</span> branch -d feature-vulcan
error: The branch <span>'feature-vulcan'</span> is not fully merged.
If you are sure you want to delete it, run <span>'git branch -D feature-vulcan'</span><span>.</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>销毁失败。Git 友情提醒，feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的 <code>-D</code> 参数。。</p>
<p>现在我们强行删除:</p>
<div><pre><code>$ <span>git</span> branch -D feature-vulcan
Deleted branch feature-vulcan <span>(</span>was 287773e<span>)</span>.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>终于删除成功!</p>
<h3 id="删除小结" tabindex="-1"> 删除小结</h3>
<ul>
<li>
<p>开发一个新 feature，最好新建一个分支；</p>
</li>
<li>
<p>如果要丢弃一个没有被合并过的分支，可以通过 <code>git branch -D &lt;name&gt;</code> 强行删除。</p>
</li>
</ul>
<hr>
<h2 id="多人协作" tabindex="-1"> 多人协作</h2>
<p>当您从远程仓库克隆时，实际上 Git 自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了，并且，远程仓库的默认名称是 <code>origin</code>。</p>
<p>要查看远程库的信息，用 <code>git remote</code>:</p>
<div><pre><code>$ <span>git</span> remote
origin
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>或者，用 <code>git remote -v</code> 显示更详细的信息:</p>
<div><pre><code>$ <span>git</span> remote -v
origin  git@github.com:Hope-Studio/learngit.git <span>(</span>fetch<span>)</span>
origin  git@github.com:Hope-Studio/learngit.git <span>(</span>push<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面显示了可以抓取和推送的 <code>origin</code> 的地址。如果没有推送权限，就看不到 push 的地址。</p>
<h3 id="推送分支" tabindex="-1"> 推送分支</h3>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上:</p>
<div><pre><code><span>git</span> push origin master
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果要推送其他分支，比如 <code>dev</code>，就改成:</p>
<div><pre><code><span>git</span> push origin dev
</code></pre><div aria-hidden="true"><div></div></div></div><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢?</p>
<p><code>master</code> 分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p><code>bug</code> 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看您每周到底修复了几个 bug；</p>
<p><code>feature</code> 分支是否推到远程，取决于您是否和您的小伙伴合作在上面开发。</p>
<p>总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视您的心情而定!</p>
<h3 id="抓取分支" tabindex="-1"> 抓取分支</h3>
<p>多人协作时，大家都会往 <code>master</code> 和 <code>dev</code> 分支上推送各自的修改。</p>
<p>现在，模拟一个您的小伙伴，可以在另一台电脑 (注意要把 SSH Key 添加到 GitHub) 或者同一台电脑的另一个目录下克隆:</p>
<div><pre><code>$ <span>git</span> clone git@github.com:Hope-Studio/learngit.git
Cloning into <span>'learngit'</span><span>..</span>.
remote: Counting objects: <span>40</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>21</span>/21<span>)</span>, done.
remote: Total <span>40</span> <span>(</span>delta <span>14</span><span>)</span>, reused <span>40</span> <span>(</span>delta <span>14</span><span>)</span>, pack-reused <span>0</span>
Receiving objects: <span>100</span>% <span>(</span><span>40</span>/40<span>)</span>, done.
Resolving deltas: <span>100</span>% <span>(</span><span>14</span>/14<span>)</span>, done.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当您的小伙伴从远程库 clone 时，默认情况下，您的小伙伴只能看到本地的 <code>master</code> 分支。不信可以用 <code>git branch</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>现在，您的小伙伴要在 <code>dev</code> 分支上开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地 <code>dev</code> 分支:</p>
<div><pre><code><span>git</span> checkout -b dev origin/dev
</code></pre><div aria-hidden="true"><div></div></div></div><p>现在，他就可以在 <code>dev</code> 上继续修改，然后，时不时地把 <code>dev</code> 分支 push 到远程:</p>
<div><pre><code><span>git</span> <span>add</span> env.txt

$ <span>git</span> commit -m <span>"add env"</span>
<span>[</span>dev 7a5e5dd<span>]</span> <span>add</span> <span>env</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> env.txt

$ <span>git</span> push origin dev
Counting objects: <span>3</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, <span>308</span> bytes <span>|</span> <span>308.00</span> KiB/s, done.
Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
   f52c633<span>..</span>7a5e5dd  dev -<span>></span> dev
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>您的小伙伴已经向 <code>origin/dev</code> 分支推送了他的提交，想要获取他的工作，您可以执行 <code>git fetch origin dev</code>。</p>
<p>如果这时碰巧您也对同样的文件作了修改，并试图推送:</p>
<div><pre><code>$ <span>cat</span> env.txt
<span>env</span>

<span>git</span> <span>add</span> env.txt

$ <span>git</span> commit -m <span>"add new env"</span>
<span>[</span>dev 7bd91f1<span>]</span> <span>add</span> new <span>env</span>
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> env.txt

$ <span>git</span> push origin dev
To github.com:Hope-Studio/learngit.git
 <span>!</span> <span>[</span>rejected<span>]</span>        dev -<span>></span> dev <span>(</span>non-fast-forward<span>)</span>
error: failed to push some refs to <span>'git@github.com:Hope-Studio/learngit.git'</span>
hint: Updates were rejected because the tip of your current branch is behind
hint: its remote counterpart. Integrate the remote changes <span>(</span>e.g.
hint: <span>'git pull ...'</span><span>)</span> before pushing again.
hint: See the <span>'Note about fast-forwards'</span> <span>in</span> <span>'git push --help'</span> <span>for</span> details.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>推送失败，因为您的小伙伴的最新提交和您试图推送的提交有冲突，解决办法也很简单，Git 已经提示我们，先用 <code>git pull</code> 把最新的提交从 <code>origin/dev</code> 抓下来，然后，在本地合并，解决冲突，再推送:</p>
<div><pre><code>$ <span>git</span> pull
There is no tracking information <span>for</span> the current branch.
Please specify <span>which</span> branch you want to merge with.
See git-pull<span>(</span><span>1</span><span>)</span> <span>for</span> details.

    <span>git</span> pull <span>&lt;</span>remote<span>></span> <span>&lt;</span>branch<span>></span>

If you wish to <span>set</span> tracking information <span>for</span> this branch you can <span>do</span> so with:

    <span>git</span> branch --set-upstream-to<span>=</span>origin/<span>&lt;</span>branch<span>></span> dev
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>git pull</code> 也失败了，原因是没有指定本地 <code>dev</code> 分支与远程 <code>origin/dev</code> 分支的链接，根据提示，设置 <code>dev</code> 和 <code>origin/dev</code> 的链接:</p>
<div><pre><code>$ <span>git</span> branch --set-upstream-to<span>=</span>origin/dev dev
Branch <span>'dev'</span> <span>set</span> up to track remote branch <span>'dev'</span> from <span>'origin'</span><span>.</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>再 pull:</p>
<div><pre><code>$ <span>git</span> pull
Auto-merging env.txt
CONFLICT <span>(</span>add/add<span>)</span>: Merge conflict <span>in</span> env.txt
Automatic merge failed<span>;</span> fix conflicts and <span>then</span> commit the result.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>这回 <code>git pull</code> 成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再 push:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"fix env conflict"</span>
<span>[</span>dev 57c53ab<span>]</span> fix <span>env</span> conflict

$ <span>git</span> push origin dev
Counting objects: <span>6</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>4</span>/4<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>6</span>/6<span>)</span>, <span>621</span> bytes <span>|</span> <span>621.00</span> KiB/s, done.
Total <span>6</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
   7a5e5dd<span>..</span>57c53ab  dev -<span>></span> dev
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>因此，多人协作的工作模式通常是这样:</p>
<p>首先，可以试图用 <code>git push origin &lt;branch-name&gt;</code> 推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比您的本地更新，需要先用 <code>git pull</code> 试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用 <code>git push origin &lt;branch-name&gt;</code> 推送就能成功!</p>
<p>如果 <code>git pull</code> 提示 <code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3 id="多人协作小结" tabindex="-1"> 多人协作小结</h3>
<ul>
<li>
<p>查看远程库信息，使用 <code>git remote -v</code>；</p>
</li>
<li>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
</li>
<li>
<p>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</p>
</li>
<li>
<p>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
</li>
<li>
<p>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
</li>
<li>
<p>从远程拉取分支，使用 <code>git fetch</code>。</p>
</li>
<li>
<p><code>git pull</code>，相当于 <code>git fetch</code> + <code>git merge</code>，如果您的修改并没有和远程的修改发生冲突，两者会自动合并到您的本地，您可以直接推送上去。如果有冲突，要先处理冲突。</p>
</li>
</ul>
<hr>
<h2 id="rebase" tabindex="-1"> Rebase</h2>
<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后 <code>push</code> 的童鞋不得不先 <code>pull</code>，在本地合并，然后才能 <code>push</code> 成功。</p>
<p>每次合并再 <code>push</code> 后，分支变成了这样:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* d1be385 <span>(</span>HEAD -<span>></span> master, origin/master<span>)</span> init hello
*   e5e69f1 Merge branch <span>'dev'</span>
<span>|</span><span>\</span>
<span>|</span> *   57c53ab <span>(</span>origin/dev, dev<span>)</span> fix <span>env</span> conflict
<span>|</span> <span>|</span><span>\</span>
<span>|</span> <span>|</span> * 7a5e5dd <span>add</span> <span>env</span>
<span>|</span> * <span>|</span> 7bd91f1 <span>add</span> new <span>env</span>
<span>|</span> <span>|</span>/
* <span>|</span>   12a631b merged bug fix <span>101</span>
<span>|</span><span>\</span> <span>\</span>
<span>|</span> * <span>|</span> 4c805e2 fix bug <span>101</span>
<span>|</span>/ /
* <span>|</span>   e1e9c68 merge with no-ff
<span>|</span><span>\</span> <span>\</span>
<span>|</span> <span>|</span>/
<span>|</span> * f52c633 <span>add</span> merge
<span>|</span>/
*   cf810e4 conflict fixed
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>总之看上去很乱，有强迫症的童鞋会问: 为什么 Git 的提交历史不能是一条干净的直线? 其实是可以做到的!</p>
<p>Git 有一种称为 <code>rebase</code> 的操作，有人把它翻译成“变基”。</p>
<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>
<p>在和远程分支同步后，我们对 <code>hello.py</code> 这个文件做了两次提交。用 <code>git log</code> 命令看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 582d922 <span>(</span>HEAD -<span>></span> master<span>)</span> <span>add</span> author
* <span>8875536</span> <span>add</span> comment
* d1be385 <span>(</span>origin/master<span>)</span> init hello
*   e5e69f1 Merge branch <span>'dev'</span>
<span>|</span><span>\</span>
<span>|</span> *   57c53ab <span>(</span>origin/dev, dev<span>)</span> fix <span>env</span> conflict
<span>|</span> <span>|</span><span>\</span>
<span>|</span> <span>|</span> * 7a5e5dd <span>add</span> <span>env</span>
<span>|</span> * <span>|</span> 7bd91f1 <span>add</span> new <span>env</span>
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意到 Git 用 <code>(HEAD -&gt; master)</code> 和 <code>(origin/master)</code> 标识出当前分支的 <code>HEAD</code> 和远程 <code>origin</code> 的位置分别是 <code>582d922 add author</code> 和 <code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支:</p>
<div><pre><code>$ <span>git</span> push origin master
To github.com:Hope-Studio/learngit.git
 <span>!</span> <span>[</span>rejected<span>]</span>        master -<span>></span> master <span>(</span>fetch first<span>)</span>
error: failed to push some refs to <span>'git@github.com:Hope-Studio/learngit.git'</span>
hint: Updates were rejected because the remote contains work that you <span>do</span>
hint: not have locally. This is usually caused by another repository pushing
hint: to the same ref. You may want to first integrate the remote changes
hint: <span>(</span>e.g., <span>'git pull ...'</span><span>)</span> before pushing again.
hint: See the <span>'Note about fast-forwards'</span> <span>in</span> <span>'git push --help'</span> <span>for</span> details.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先 pull 一下:</p>
<div><pre><code>$ <span>git</span> pull
remote: Counting objects: <span>3</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>1</span>/1<span>)</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>1</span><span>)</span>, reused <span>3</span> <span>(</span>delta <span>1</span><span>)</span>, pack-reused <span>0</span>
Unpacking objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
From github.com:Hope-Studio/learngit
   d1be385<span>..</span>f005ed4  master     -<span>></span> origin/master
 * <span>[</span>new tag<span>]</span>         v1.0       -<span>></span> v1.0
Auto-merging hello.py
Merge made by the <span>'recursive'</span> strategy.
 hello.py <span>|</span> <span>1</span> +
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再用 <code>git status</code> 看看状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Your branch is ahead of <span>'origin/master'</span> by <span>3</span> commits.
  <span>(</span>use <span>"git push"</span> to publish your <span>local</span> commits<span>)</span>

nothing to commit, working tree clean
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>加上刚才合并的提交，现在我们本地分支比远程分支超前 3 个提交。</p>
<p>用 <code>git log</code> 看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
*   e0ea545 <span>(</span>HEAD -<span>></span> master<span>)</span> Merge branch <span>'master'</span> of github.com:Hope-Studio/learngit
<span>|</span><span>\</span>
<span>|</span> * f005ed4 <span>(</span>origin/master<span>)</span> <span>set</span> <span>exit</span><span>=</span><span>1</span>
* <span>|</span> 582d922 <span>add</span> author
* <span>|</span> <span>8875536</span> <span>add</span> comment
<span>|</span>/
* d1be385 init hello
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支 <code>push</code> 到远程，有没有问题?</p>
<p>有!</p>
<p>什么问题?</p>
<p>不好看!</p>
<p>有没有解决方法?</p>
<p>有!</p>
<p>这个时候，rebase 就派上了用场。我们输入命令 <code>git rebase</code> 试试:</p>
<div><pre><code>$ <span>git</span> rebase
First, rewinding <span>head</span> to replay your work on <span>top</span> of it<span>..</span>.
Applying: <span>add</span> comment
Using index info to reconstruct a base tree<span>..</span>.
M    hello.py
Falling back to patching base and <span>3</span>-way merge<span>..</span>.
Auto-merging hello.py
Applying: <span>add</span> author
Using index info to reconstruct a base tree<span>..</span>.
M    hello.py
Falling back to patching base and <span>3</span>-way merge<span>..</span>.
Auto-merging hello.py
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>输出了一大堆操作，到底是啥效果? 再用 <code>git log</code> 看看:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 7e61ed4 <span>(</span>HEAD -<span>></span> master<span>)</span> <span>add</span> author
* 3611cfe <span>add</span> comment
* f005ed4 <span>(</span>origin/master<span>)</span> <span>set</span> <span>exit</span><span>=</span><span>1</span>
* d1be385 init hello
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>原本分叉的提交现在变成一条直线了! 这种神奇的操作是怎么实现的? 其实原理非常简单。我们注意观察，发现 Git 把我们本地的提交“挪动”了位置，放到了 <code>f005ed4 (origin/master) set exit=1</code> 之后，这样，整个提交历史就成了一条直线。<code>rebase</code> 操作前后，最终的提交内容是一致的，但是，我们本地的 commit 修改内容已经变化了，它们的修改不再基于 <code>d1be385 init hello</code>，而是基于 <code>f005ed4 (origin/master) set exit=1</code>，但最后的提交 <code>7e61ed4</code> 内容是一致的。</p>
<p>这就是 <code>rebase</code> 操作的特点: 把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过 <code>push</code> 操作把本地分支推送到远程:</p>
<div><pre><code>Mac:~/learngit michael$ <span>git</span> push origin master
Counting objects: <span>6</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>5</span>/5<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>6</span>/6<span>)</span>, <span>576</span> bytes <span>|</span> <span>576.00</span> KiB/s, done.
Total <span>6</span> <span>(</span>delta <span>2</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
remote: Resolving deltas: <span>100</span>% <span>(</span><span>2</span>/2<span>)</span>, completed with <span>1</span> <span>local</span> object.
To github.com:Hope-Studio/learngit.git
   f005ed4<span>..</span>7e61ed4  master -<span>></span> master
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再用 <code>git log</code> 看看效果:</p>
<div><pre><code>$ <span>git</span> log --graph --pretty<span>=</span>oneline --abbrev-commit
* 7e61ed4 <span>(</span>HEAD -<span>></span> master, origin/master<span>)</span> <span>add</span> author
* 3611cfe <span>add</span> comment
* f005ed4 <span>set</span> <span>exit</span><span>=</span><span>1</span>
* d1be385 init hello
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>远程分支的提交历史也是一条直线。</p>
<h2 id="rebase-小结" tabindex="-1"> Rebase 小结</h2>
<ul>
<li>
<p><code>rebase</code> 操作可以把本地未 <code>push</code> 的分叉提交历史整理成直线；</p>
</li>
<li>
<p><code>rebase</code> 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>修改管理</title>
      <link>https://shimonzhan.com/software/git/change.html</link>
      <guid>https://shimonzhan.com/software/git/change.html</guid>
      <source url="https://shimonzhan.com/rss.xml">修改管理</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="管理修改" tabindex="-1"> 管理修改</h2>
<p>Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。</p>
<p>您会问，什么是修改? 比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说 Git 管理的是修改，而不是文件呢? 我们还是做实验。第一步，对 readme.txt 做一个修改，比如加一行内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，添加:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing</span>
$ <span>git</span> status
  On branch master
  Changes to be committed:
    <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>
        modified:   readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，再修改 readme.txt:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>提交:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"git tracks changes"</span>
<span>[</span>master 519219b<span>]</span> <span>git</span> tracks changes
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>提交后，再看看状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>怎么第二次的修改没有被提交? 我们回顾一下操作过程:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git commit</code></p>
<p>您看，我们前面讲了，Git 管理的是修改，当您用 <code>git add</code> 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code> 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用 <code>git diff HEAD -- readme.txt</code> 命令可以查看工作区和版本库里面最新版本的区别:</p>
<div><pre><code>$ <span>git</span> <span>diff</span> HEAD -- readme.txt
<span>diff</span> --git a/readme.txt b/readme.txt
index 76d770f<span>..</span>a9c5755 <span>100644</span>
--- a/readme.txt
+++ b/readme.txt
@@ -1,4 +1,4 @@
 Git is a distributed version control system.
 Git is <span>free</span> software distributed under the GPL.
 Git has a mutable index called stage.
-Git tracks changes.
+Git tracks changes of files.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢? 您可以继续 <code>git add</code> 再 <code>git commit</code>，也可以别着急提交第一次修改，先 <code>git add</code> 第二次修改，再 <code>git commit</code>，就相当于把两次修改合并后一块提交了:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git add</code> → <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<h3 id="管理小结" tabindex="-1"> 管理小结</h3>
<p>现在，您又理解了 Git 是如何跟踪修改的，每次修改，如果不用 <code>git add</code> 到暂存区，那就不会加入到 <code>commit</code> 中。</p>
<h2 id="撤消对文件的修改" tabindex="-1"> 撤消对文件的修改</h2>
<p>自然，您是不会犯错的。不过现在是凌晨两点，您正在赶一份工作报告，您在 readme.txt 中添加了一行:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在您准备提交前，一杯咖啡起了作用，您猛然发现了 <code>'stupid boss'</code> 可能会让您丢掉这个月的奖金!</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。您可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用 <code>git status</code> 查看一下:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>您可以发现，Git 会告诉您，<code>git checkout -- &lt;file&gt;</code> 可以丢弃工作区的修改:</p>
<div><pre><code><span>git</span> checkout -- readme.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况:</p>
<p>一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p>
<p>现在，看看 readme.txt 的文件内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code> 命令中的 <code>--</code> 很重要，没有 <code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到 <code>git checkout</code> 命令。</p>
<div><p>注意</p>
<p>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。您对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</p>
<p>除非您确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p>
</div>
<h2 id="取消暂存的文件" tabindex="-1"> 取消暂存的文件</h2>
<p>现在假定是凌晨 3 点，您不但写了一些胡话，还 <code>git add</code> 到暂存区了:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
Git has a mutable index called stage.
Git tracks changes of files.
My stupid boss still prefers SVN.

<span>git</span> <span>add</span> readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>庆幸的是，在 <code>commit</code> 之前，您发现了这个问题。用 <code>git status</code> 查看一下，修改只是添加到了暂存区，还没有提交:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    modified:   readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Git 同样告诉我们，用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区:</p>
<div><pre><code>$ <span>git</span> reset HEAD readme.txt
Unstaged changes after reset:
M    readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 <code>HEAD</code> 时，表示当前的指针(最新的版本)。</p>
<p>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>还记得如何丢弃工作区的修改吗?</p>
<div><pre><code><span>git</span> checkout -- readme.txt

$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>整个世界终于清静了!</p>
<div><p>提示</p>
<p>那么如果您想要丢弃工作区和暂存区全部更改呢? 不要忘了 <code>HEAD</code> 就是当前指针，所以</p>
<div><pre><code><span>git</span> reset --hard HEAD
</code></pre><div aria-hidden="true"><div></div></div></div><p>就是丢弃工作区与暂存区的全部文件啦。</p>
</div>
<p>现在，假设您不但改错了东西，还从暂存区提交到了版本库，怎么办呢? 还记得版本回退一节吗? 可以回退到上一个版本。不过，这是有条件的，就是您还没有把自己的本地版本库推送到远程。还记得 Git 是分布式版本控制系统吗? 我们后面会讲到远程版本库，一旦您把 <code>stupid boss</code> 提交推送到远程版本库，您就真的惨了……</p>
<h3 id="撤销小结" tabindex="-1"> 撤销小结</h3>
<p>场景 1: 当您改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p>
<p>场景 2: 当您不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景 1 操作。</p>
<p>场景 3: 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<hr>
<h2 id="删除文件" tabindex="-1"> 删除文件</h2>
<h3 id="如何删除文件" tabindex="-1"> 如何删除文件</h3>
<p>在 Git 中，删除也是一个修改操作，我们实战一下，先添加一个新文件 test.txt 到 Git 并且提交:</p>
<div><pre><code><span>git</span> <span>add</span> test.txt

$ <span>git</span> commit -m <span>"add test.txt"</span>
<span>[</span>master b84166e<span>]</span> <span>add</span> test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>
 create mode <span>100644</span> test.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>一般情况下，您通常直接在文件管理器中把没用的文件删了，或者用 <code>rm</code> 命令删了:</p>
<div><pre><code><span>rm</span> test.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个时候，Git 知道您删除了文件，因此，工作区和版本库就不一致了，<code>git status</code> 命令会立刻告诉您哪些文件被删除了:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add/rm &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    deleted:    test.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在您有两个选择，一是确实要从版本库中删除该文件，那就用命令 <code>git rm</code> 删掉，并且 <code>git commit</code>:</p>
<div><pre><code>$ <span>git</span> <span>rm</span> test.txt
<span>rm</span> <span>'test.txt'</span>

$ <span>git</span> commit -m <span>"remove test.txt"</span>
<span>[</span>master d46f35e<span>]</span> remove test.txt
 <span>1</span> <span>file</span> changed, <span>1</span> deletion<span>(</span>-<span>)</span>
 delete mode <span>100644</span> test.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，文件就从版本库中被删除了。</p>
<h3 id="撤销删除" tabindex="-1"> 撤销删除</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本:</p>
<div><pre><code><span>git</span> checkout -- test.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3 id="删除小结" tabindex="-1"> 删除小结</h3>
<p>命令 <code>git rm</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么您永远不用担心误删，但是要小心，您只能恢复文件到最新版本，您会丢失最近一次提交后您修改的内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Git 仓库</title>
      <link>https://shimonzhan.com/software/git/create-repo.html</link>
      <guid>https://shimonzhan.com/software/git/create-repo.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Git 仓库</source>
      <description>什么是仓库呢? 英文名repository，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。
</description>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>什么是仓库呢? 英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>

<h2 id="初始化仓库" tabindex="-1"> 初始化仓库</h2>
<p>创建一个仓库非常简单，首先，选择一个合适的地方，创建一个空目录:</p>
<div><pre><code><span># open shell (PowerShell on Windows) in a proper directory</span>
$ <span>mkdir</span> learngit
$ <span>cd</span> learngit
$ <span>pwd</span>
/users/hope-studio/learngit
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><code>pwd</code> 命令用于显示当前目录。</p>
<div><p>提示</p>
<ul>
<li>使用 Windows 系统时，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。</li>
<li>为了确保能够执行跨平台的命令，请在 Windows 上安装 PowerShell 并设置为 VS Code 的默认终端。</li>
</ul>
</div>
<p>第二步，通过 <code>git init</code> 命令把这个目录变成 Git 可以管理的仓库:</p>
<div><pre><code>$ <span>git</span> init
Initialized empty Git repository <span>in</span> /users/hope-studio/learngit/.git/
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>瞬间 Git 就把仓库建好了，而且告诉您是一个空的仓库(empty Git repository)，可以发现当前目录下多了一个.git 的目录，这个目录是 Git 来跟踪管理仓库的，如果这个目录里面的文件破坏了，Git 仓库也破坏了。</p>
<p>如果您没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p>
<p>也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。</p>
<div><p>警告</p>
<p>请不要用已经在使用的项目练习 Git!</p>
</div>
<h2 id="把文件添加到仓库" tabindex="-1"> 把文件添加到仓库</h2>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉您每次的改动，比如在第 5 行加了一个单词“Linux”，在第 8 行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。(Microsoft 的 Word 格式是二进制格式，所以很不幸) 所以要使用版本控制系统，就要以纯文本方式编写文件。</p>
<div><p>提示</p>
<p>因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<ul>
<li>具体详情请见 <a href="/code/basic/encoding.html">文件编码</a></li>
</ul>
</div>
<div><p>注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="/code/windows/notepad.html">记事本遗留问题</a></li>
</ul>
</div>
<p>现在编写一个 readme.txt 文件，内容如下:</p>
<div><pre><code>Git is a version control system.
Git is free software.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>一定要放到 <code>learngit</code> 目录下(子目录也行)，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。</p>
<p>把一个文件放到 Git 仓库只需要两步:</p>
<ol>
<li>
<p>用命令 <code>git add</code> 告诉 Git，把文件添加到仓库:</p>
<div><pre><code><span>git</span> <span>add</span> readme.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加成功。</p>
</li>
<li>
<p>用命令 <code>git commit</code> 告诉 Git，把文件提交到仓库:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"wrote a readme file"</span>
<span>[</span>master <span>(</span>root-commit<span>)</span> eaadf4e<span>]</span> wrote a readme <span>file</span>
 <span>1</span> <span>file</span> changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><code>git commit</code> 命令，<code>-m</code> 后面输入的是本次提交的说明，这样您就能从历史记录里方便地找到改动记录。</p>
<p><code>git commit</code> 命令执行成功后会告诉您，<code>1 file changed</code>: 1 个文件被改动(我们新添加的 readme.txt 文件)；<code>2 insertions</code>: 插入了两行内容(readme.txt 有两行内容)。</p>
</li>
</ol>
<p>为什么 Git 添加文件需要 <code>add</code>，<code>commit</code> 一共两步呢? 因为 <code>commit</code> 可以一次提交很多文件，所以您可以多次 <code>add</code> 不同的文件，比如:</p>
<div><pre><code><span>git</span> <span>add</span> file1.txt
<span>git</span> <span>add</span> file2.txt file3.txt
<span>git</span> commit -m <span>"add 3 files."</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>
<p>初始化一个 Git 仓库，使用 <code>git init</code> 命令。</p>
</li>
<li>
<p>添加文件到 Git 仓库，分两步:</p>
<ol>
<li>使用命令 <code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件；</li>
<li>使用命令 <code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>自定义 Git</title>
      <link>https://shimonzhan.com/software/git/custom.html</link>
      <guid>https://shimonzhan.com/software/git/custom.html</guid>
      <source url="https://shimonzhan.com/rss.xml">自定义 Git</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在安装 Git 一节中，我们已经配置了 <code>user.name</code> 和 <code>user.email</code>，实际上，Git 还有很多可配置项。</p>
<p>比如，让 Git 显示颜色，会让命令输出看起来更醒目:</p>
<div><pre><code><span>git</span> config --global color.ui <span>true</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样，Git 会适当地显示不同的颜色，比如 <code>git status</code> 命令，文件名就会标上颜色。</p>
<h2 id="配置别名" tabindex="-1"> 配置别名</h2>
<p>有没有经常敲错命令? 比如 <code>git status</code>? <code>status</code> 这个单词真心不好记。</p>
<p>如果敲 <code>git st</code> 就表示 <code>git status</code> 那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉 Git，以后 <code>st</code> 就表示 <code>status</code>:</p>
<div><pre><code><span>git</span> config --global alias.st status
</code></pre><div aria-hidden="true"><div></div></div></div><p>好了，现在敲 <code>git st</code> 看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用 <code>co</code> 表示 <code>checkout</code>，<code>ci</code> 表示 <code>commit</code>，<code>br</code> 表示 <code>branch</code>:</p>
<div><pre><code><span>git</span> config --global alias.co checkout
<span>git</span> config --global alias.ci commit
<span>git</span> config --global alias.br branch
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>以后提交就可以简写成:</p>
<div><pre><code><span>git</span> ci -m <span>"bala bala bala..."</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>--global</code> 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。既然是一个 <code>unstage</code> 操作，就可以配置一个 <code>unstage</code> 别名:</p>
<div><pre><code><span>git</span> config --global alias.unstage <span>'reset HEAD'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>当您敲入命令:</p>
<div><pre><code><span>git</span> unstage test.py
</code></pre><div aria-hidden="true"><div></div></div></div><p>实际上 Git 执行的是:</p>
<div><pre><code><span>git</span> reset HEAD test.py
</code></pre><div aria-hidden="true"><div></div></div></div><p>配置一个 <code>git last</code>，让其显示最后一次提交信息:</p>
<div><pre><code><span>git</span> config --global alias.last <span>'log -1'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样，用 <code>git last</code> 就能显示最近一次的提交:</p>
<div><pre><code>$ <span>git</span> last
commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2
Merge: bd6ae48 291bea8
Author: Shimon Zhan <span>&lt;</span>zhanxinming1999@gmail.com<span>></span>
Date:   Thu Aug <span>22</span> <span>22</span>:49:22 <span>2013</span> +0800

    merge <span>&amp;</span> fix hello.py
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>甚至还有人丧心病狂地把 <code>lg</code> 配置成了:</p>
<div><pre><code><span>git</span> config --global alias.lg <span>"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an>%Creset' --abbrev-commit"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>来看看 <code>git lg</code> 的效果:</p>
<p><img src="@source/software/git/assets/git16.png" alt="命令 git lg 示例图" loading="lazy"></p>
<p>为什么不早点告诉我? 别激动，咱不是为了多记几个英文单词嘛!</p>
<h2 id="配置文件" tabindex="-1"> 配置文件</h2>
<p>配置 Git 的时候，加上 <code>--global</code> 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了? 每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中:</p>
<div><pre><code>$ <span>cat</span> .git/config
<span>[</span>core<span>]</span>
    repositoryformatversion <span>=</span> <span>0</span>
    filemode <span>=</span> <span>true</span>
    bare <span>=</span> <span>false</span>
    logallrefupdates <span>=</span> <span>true</span>
    ignorecase <span>=</span> <span>true</span>
    precomposeunicode <span>=</span> <span>true</span>
<span>[</span>remote <span>"origin"</span><span>]</span>
    url <span>=</span> git@github.com:michaelliao/learngit.git
    fetch <span>=</span> +refs/heads/*:refs/remotes/origin/*
<span>[</span>branch <span>"master"</span><span>]</span>
    remote <span>=</span> origin
    merge <span>=</span> refs/heads/master
<span>[</span>alias<span>]</span>
    last <span>=</span> log -1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>别名就在 <code>[alias]</code> 后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中:</p>
<div><pre><code>$ <span>cat</span> .gitconfig
<span>[</span>alias<span>]</span>
    co <span>=</span> checkout
    ci <span>=</span> commit
    br <span>=</span> branch
    st <span>=</span> status
<span>[</span>user<span>]</span>
    name <span>=</span> Your Name
    email <span>=</span> your@email.com
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h3 id="别名小结" tabindex="-1"> 别名小结</h3>
<ul>
<li>给 Git 配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Git Large File Storage</title>
      <link>https://shimonzhan.com/software/git/gitLFS.html</link>
      <guid>https://shimonzhan.com/software/git/gitLFS.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Git Large File Storage</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="git-large-file-storage" tabindex="-1"> Git Large File Storage</h1>
<p>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p>
<h2 id="getting-started" tabindex="-1"> Getting Started</h2>
<ol>
<li>
<p>Download and install the Git command-line extension. Once downloaded and installed, set up Git LFS and its respective hooks by running:</p>
<div><pre><code><span>git</span> lfs <span>install</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>You’ll need to run this in your repository directory, once per repository.</p>
</li>
<li>
<p>Select the file types you’d like Git LFS to manage (or directly edit your .gitattributes). You can configure file extensions at anytime.</p>
<div><pre><code><span>git</span> lfs track <span>"*.psd"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Make sure to track <code>.gitattributes</code></p>
<div><pre><code><span>git</span> <span>add</span> .gitattributes
</code></pre><div aria-hidden="true"><div></div></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>忽略特殊文件</title>
      <link>https://shimonzhan.com/software/git/ignore.html</link>
      <guid>https://shimonzhan.com/software/git/ignore.html</guid>
      <source url="https://shimonzhan.com/rss.xml">忽略特殊文件</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次 <code>git status</code> 都会显示 <code>Untracked files</code> ...，有强迫症的童鞋心里肯定不爽。</p>
<p>好在 Git 考虑到了大家的感受，这个问题解决起来也很简单，在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code> 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。</p>
<p>忽略文件的原则是:</p>
<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 <code>.class</code> 文件；</li>
<li>忽略您自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
<p>举个例子:</p>
<p>假设您在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 <code>Desktop.ini</code> 文件，因此您需要忽略 Windows 自动生成的垃圾文件:</p>
<div><pre><code><span>Thumbs.db</span>
<span>ehthumbs.db</span>
<span>Desktop.ini</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>然后，继续忽略 Python 编译产生的 <code>.pyc</code>、<code>.pyo</code>、<code>dist</code> 等文件或目录:</p>
<div><pre><code><span>_.py<span>[cod]</span></span>
<span>_.so</span>
<span>_.egg</span>
<span>_.egg-info</span>
<span>dist</span>
<span>build</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>加上您自己定义的文件，最终得到一个完整的 <code>.gitignore</code> 文件，内容如下:</p>
<div><pre><code><span># Windows:</span>

<span>Thumbs.db</span>
<span>ehthumbs.db</span>
<span>Desktop.ini</span>

<span># Python:</span>

<span>_.py<span>[cod]</span></span>
<span>_.so</span>
<span>_.egg</span>
<span>_.egg-info</span>
<span>dist</span>
<span>build</span>

<span># My configurations:</span>

<span>db.ini</span>
<span>deploy_key_rsa</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最后一步就是把 <code>.gitignore</code> 也提交到 Git，就完成了! 当然检验 <code>.gitignore</code> 的标准是 <code>git status</code> 命令是不是说 <code>working directory clean</code>。</p>
<p>使用 Windows 的童鞋注意了，如果您在资源管理器里新建一个 <code>.gitignore</code> 文件，它会非常弱智地提示您必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 <code>.gitignore</code> 了。</p>
<p>有些时候，您想添加一个文件到 Git，但发现添加不了，原因是这个文件被 <code>.gitignore</code> 忽略了:</p>
<div><pre><code>$ <span>git</span> <span>add</span> App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f <span>if</span> you really want to <span>add</span> them.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>如果您确实想添加该文件，可以用 <code>-f</code> 强制添加到 Git:</p>
<div><pre><code><span>git</span> <span>add</span> -f App.class
</code></pre><div aria-hidden="true"><div></div></div></div><p>或者您发现，可能是 <code>.gitignore</code> 写得有问题，需要找出来到底哪个规则写错了，可以用 <code>git check-ignore</code> 命令检查:</p>
<div><pre><code>$ <span>git</span> check-ignore -v App.class
.gitignore:3:*.class    App.class
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>Git 会告诉我们，<code>.gitignore</code> 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h2 id="格式规范" tabindex="-1"> 格式规范</h2>
<ul>
<li>
<p>所有空行或者以 # 开头的行都会被 Git 忽略。</p>
</li>
<li>
<p>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)开头防止递归。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)结尾指定目录。</p>
</li>
<li>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上叹号(<code>!</code>)取反。</p>
</li>
</ul>
<div><p>glob 模式</p>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号(<code>*</code>)匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 (这个例子要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)； 问号(<code>?</code>)只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配(比如 <code>[0-9]</code> 表示匹配所有 <code>0</code> 到 <code>9</code> 的数字)。使用两个星号(<code>**</code>)表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、<code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
</div>
<p>一个具体的例子:</p>
<div><pre><code><span># 忽略所有的 .a 文件</span>
<span><span>*</span>.a</span>

<span># 但跟踪所有的 lib.a，即便您在前面忽略了 .a 文件</span>
<span><span>!</span>lib.a</span>

<span># 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span>
<span><span>/</span>TODO</span>

<span># 忽略任何目录下名为 build 的文件夹</span>
<span>build<span>/</span></span>

<span># 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span>
<span>doc<span>/</span><span>*</span>.txt</span>

<span># 忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span>
<span>doc<span>/</span><span>**</span><span>/</span><span>*</span>.pdf</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>提示</p>
<p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 您可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">https://github.com/github/gitignore</a> 找到它。</p>
</div>
<div><p>多个 .gitignore</p>
<p>在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。(Linux 内核的源码库拥有 206 个 .gitignore 文件。)</p>
</div>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>
<p>忽略某些文件时，需要编写 <code>.gitignore</code>；</p>
</li>
<li>
<p><code>.gitignore</code> 文件本身要放到版本库里，并且可以对 <code>.gitignore</code> 做版本管理!</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装与配置</title>
      <link>https://shimonzhan.com/software/git/install.html</link>
      <guid>https://shimonzhan.com/software/git/install.html</guid>
      <source url="https://shimonzhan.com/rss.xml">安装与配置</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="git-下载" tabindex="-1"> Git 下载</h2>
<p>官网在国外，网速较慢。在安装 Git 前推荐安装好 <a href="/software/vscode/">VS Code</a>。</p>
<ul>
<li><a href="https://git-scm.com/downloads/" target="_blank" rel="noopener noreferrer">官网下载</a></li>
</ul>
<h2 id="git-的安装" tabindex="-1"> Git 的安装</h2>
<ol>
<li>
<p>同意协议并选择安装位置 (不建议更改安装位置)</p>
<p><img src="@source/software/git/assets/install1.png" alt="安装协议" loading="lazy"></p>
<p><img src="@source/software/git/assets/install2.png" alt="安装位置" loading="lazy"></p>
</li>
<li>
<p>启用 LFS 支持，其他随意 (影响不大)</p>
<p><img src="@source/software/git/assets/install3.png" alt="组件选择" loading="lazy"></p>
</li>
<li>
<p>自行决定是否创建启动菜单</p>
<p><img src="@source/software/git/assets/install4.png" alt="是否创建启动菜" loading="lazy"></p>
</li>
<li>
<p>选择使用 VS Code 作为 git 的默认编辑器。</p>
<p><img src="@source/software/git/assets/install5.png" alt="设置默认编辑器" loading="lazy"></p>
</li>
<li>
<p>选择 Git 使用的默认分支名，GitHub 已经将默认分支名称改为 main。</p>
<p><img src="@source/software/git/assets/install6.png" alt="设置默认分支名称" loading="lazy"></p>
<div><p>相关信息</p>
<p>在 2020 年的黑人运动中，部分黑人认为 master 这个词是对它们的冒犯。</p>
</div>
</li>
<li>
<p>选择第二项，这将允许您在第三方工具中使用 Git，同时不会覆盖默认的 Windows 命令。</p>
<p><img src="@source/software/git/assets/install7.png" alt="Git 命令行" loading="lazy"></p>
</li>
<li>
<p>使用 OpenSSL Library</p>
<p><img src="@source/software/git/assets/install8.png" alt="Git SSL" loading="lazy"></p>
<div><p>提示</p>
<p>如果自己公司有 CA，或者在开发中需要 Git 承认某些自签 CA，则需要选择第二项。</p>
</div>
</li>
<li>
<p>务必选择最后一项 “原样检出与提交”</p>
<p><img src="@source/software/git/assets/install9.png" alt="Git 行尾设置" loading="lazy"></p>
</li>
<li>
<p>选择 Git 终端</p>
<p><img src="@source/software/git/assets/install10.png" alt="Git 终端" loading="lazy"></p>
<div><p>提示</p>
<p>如果您对 VS Code 和 PowerShell 还不熟悉，建议选择 MinTTY，以方便您接下来在学习中对 Git Bash 的临时使用。</p>
</div>
</li>
<li>
<p>选择 <code>git pull</code> 的默认行为，保持默认不要改动</p>
<p><img src="@source/software/git/assets/install11.png" alt="Git Pull Action" loading="lazy"></p>
</li>
<li>
<p>选择凭据储存管理器，请选择第一个跨平台管理器</p>
<p><img src="@source/software/git/assets/install12.png" alt="凭据储存管理器设置" loading="lazy"></p>
</li>
<li>
<p>额外的选项确认，均勾选即可</p>
<p><img src="@source/software/git/assets/install13.png" alt="额外选项" loading="lazy"></p>
</li>
<li>
<p>一些实验性的功能，通常不太稳定或有 bug，不同 Git 版本会有差异，可根据自身情况确定</p>
<p><img src="@source/software/git/assets/install14.png" alt="实验性功能" loading="lazy"></p>
</li>
</ol>
<h2 id="git-bash" tabindex="-1"> Git Bash</h2>
<p>安装完成后，您可以通过搜索找到“Git Bash” (Mac 上叫 Git Shell)，这是一个 Git 提供的命令窗口，您可以在这里运行 Git 命令。</p>
<p><img src="@source/software/git/assets/shell.png" alt="Git Bash" loading="lazy"></p>
<div><p>提示</p>
<p>如果您对 VS Code 和 PowerShell 还不熟悉，您可以在接下来的学习与操作中使用 Git Bash。</p>
</div>
<h2 id="git-的初次配置" tabindex="-1"> Git 的初次配置</h2>
<ol>
<li>
<p>为 Git 全局配置用户名和邮箱。</p>
<div><pre><code><span>git</span> config --global user.name <span>"Your Name"</span>
<span>git</span> config --global user.email <span>"email@example.com"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>将上方的字符串换成您自己的名字和邮箱。</p>
<p>如:</p>
<div><pre><code><span>git</span> config --global user.name <span>"Shimon Zhan"</span>
<span>git</span> config --global user.email <span>"zhanxinming1999@gmail.com"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>相关信息</p>
<p>由于 Git 是一个多人协作的版本控制系统，首先您应当设置您的身份。</p>
</div>
</li>
<li>
<p>创建 SSH Key。打开 Shell (Windows 下打开 cmd)，创建 SSH Key:</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
<div><p>提示</p>
<ul>
<li>
<p>ssh-keygen 用来生成一堆密钥，作为您的身份识别信息，您可以放心的把公钥交给别人，留下自己的私钥。</p>
</li>
<li>
<p><code>.ssh</code> 目录是默认隐藏的。Win10 查看隐藏文件详见 <a href="/code/windows/hidden-file.html">显示隐藏的文件</a></p>
</li>
</ul>
</div>
<div><p>RSA</p>
<p>RSA 是一种不对称加密，公钥的加密只能通过私钥解开，反之私钥的加密只能由公钥解开。也就是说当您给别人自己的公钥的时候，他们也无法冒充您。</p>
</div>
</li>
<li>
<p>打开 <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub</a> 并选择 &quot;Sign in&quot; 注册自己的账号。</p>
<p><img src="@source/software/git/assets/github.png" alt="GitHub 界面简介" loading="lazy"></p>
<p>登陆 GitHub 后，点击右上角头像，进入设置。</p>
<p>进入 &quot;安全设置&quot; 下的 &quot;SSH 公钥&quot; 界面。</p>
<p><img src="@source/software/git/assets/githubSSH.png" alt="GitHub 界面简介" loading="lazy"></p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中，设置一个标识此电脑的备注。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Git 介绍</title>
      <link>https://shimonzhan.com/software/git/intro.html</link>
      <guid>https://shimonzhan.com/software/git/intro.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Git 介绍</source>
      <description>Git 是什么?
Git 是目前世界上最先进的分布式版本控制系统(没有之一)。
</description>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 是什么?</p>
<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>

<h2 id="版本控制系统" tabindex="-1"> 版本控制系统</h2>
<p>什么是“版本控制”? 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。您可以对任何类型的文件进行版本控制。</p>
<ul>
<li>如果您是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本(这或许是您非常渴望拥有的功能)</li>
<li>如果您是一名作家，您可能需要保存您对作品的每一次修改以便将来如果随着情节发展需要变动可以撤销它们。</li>
<li>甚至您是一名学生，您的论文也可以进行版本控制。</li>
<li>哪怕您工作了，保存各种报表的各种版本也是没有坏处的。</li>
</ul>
<p>在很多情况下，采用版本控制系统(VCS)都是个明智的选择! 有了它您就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，您可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算您乱来一气把整个项目中的文件改的改删的删，您也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统" tabindex="-1"> 本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>
<p><img src="@source/software/git/assets/RCS.png" alt="本地版本控制系统" loading="lazy"></p>
<blockquote>
<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。RCS 的工作原理是在硬盘上保存补丁集(补丁是指文件修订前后的变化)；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
</blockquote>
<h3 id="集中化的版本控制系统" tabindex="-1"> 集中化的版本控制系统</h3>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作? 于是，集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p>集中式版本控制系统版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，您要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p><img src="@source/software/git/assets/intro.jpg" alt="Git示例图" loading="lazy"></p>
<p>CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>事分两面，有好有坏。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个 10M 的文件就需要 5 分钟。另外若中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3 id="分布式版本控制系统" tabindex="-1"> 分布式版本控制系统</h3>
<p>于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。</p>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，您工作的时候，就不需要联网了，因为版本库就在您自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢? 比方说您在自己电脑上改了文件 A，您的同事也在他的电脑上改了文件 A，这时，您们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p><img src="@source/software/git/assets/DVCS.png" alt="分布式版本控制系统" loading="lazy"></p>
<div><p>提示</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能您们俩不在一个局域网内，两台电脑互相访问不了，也可能今天您的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
</div>
<p>在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，您就可以在同一个项目中，分别和不同工作小组的人相互协作。您可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>撤销操作</title>
      <link>https://shimonzhan.com/software/git/recall.html</link>
      <guid>https://shimonzhan.com/software/git/recall.html</guid>
      <source url="https://shimonzhan.com/rss.xml">撤销操作</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在任何一个阶段，您都有可能想要撤消某些操作。这里，我们将会学习几个撤消您所做修改的基本工具。注
意，有些撤消操作是不可逆的。这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个
地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 <code>--amend</code> 选
项的提交命令来重新提交:</p>
<div><pre><code><span>git</span> commit --amend
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个命令会将暂存区中的文件提交。如果自上次提交以来您还未做任何修改(例如，在上次提交后马上执行了
此命令)， 那么快照会保持不变，而您所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p>
<p>例如，您提交后发现忘记了暂存某些需要的修改，可以像下面这样操作:</p>
<div><pre><code><span>git</span> commit -m <span>'initial commit'</span>
<span>git</span> <span>add</span> forgotten_file
<span>git</span> commit --amend
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>最终您只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<div><p>提示</p>
<p>当您在修补最后的提交时，并不是通过用改进后的提交 原位替换 掉旧有提交的方式来修复
的， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出
现在仓库的历史中。</p>
<p>修补提交最明显的价值是可以稍微改进您最后的提交，而不会让“啊，忘了添加一个文件”或
者 “小修补，修正笔误”这种提交信息弄乱您的仓库历史。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>远程仓库</title>
      <link>https://shimonzhan.com/software/git/remote.html</link>
      <guid>https://shimonzhan.com/software/git/remote.html</guid>
      <source url="https://shimonzhan.com/rss.xml">远程仓库</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="什么是远程仓库" tabindex="-1"> 什么是远程仓库</h2>
<p>Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢? 最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行 Git 的服务器，不过现阶段，为了学 Git 先搭个服务器绝对是小题大作。好在这个世界上有个叫 GitHub 的神奇的网站，从名字就可以看出，这个网站就是提供 Git 仓库托管服务的，所以，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册 GitHub 账号。由于您的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置:</p>
<ul>
<li>
<p>第 1 步: 创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell (Windows 下打开 Git Bash)，创建 SSH Key:</p>
<div><pre><code>ssh-keygen -t rsa -C <span>"youremail@example.com"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
</li>
<li>
<p>第 2 步: 登陆 GitHub，点击右上角头像，进入设置。</p>
<p>进入安全设置下的 SSH 公钥界面。</p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中。</p>
</li>
</ul>
<p>为什么 GitHub 需要 SSH Key 呢? 因为 GitHub 需要识别出您推送的提交确实是您推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了您的公钥，就可以确认只有您自己才能推送。</p>
<p>当然，GitHub 允许您添加多个 Key。假定您有若干电脑，您一会儿在公司提交，一会儿在家里提交，只要把每台电脑的 Key 都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。</p>
<p>最后友情提示，在 GitHub 上免费托管的 Git 仓库，任何人都可以看到喔(但只有您自己才能改)。所以，不要把敏感信息放进去。</p>
<p>如果您不想让别人看到 Git 库，一是让 GitHub 把公开的仓库变成私有的，这样别人就看不见了(不可读更不可写)。另一个办法是自己动手，搭一个 Git 服务器，因为是您自己的 Git 服务器，所以别人也是看不见的。</p>
<p>确保您拥有一个 GitHub 账号后，我们就即将开始远程仓库的学习。</p>
<h2 id="添加远程库" tabindex="-1"> 添加远程库</h2>
<p>现在的情景是，您已经在本地创建了一个 Git 仓库后，又想在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆 GitHub，然后，在右上角找到 “+” 按钮，点击 &quot;New Repository&quot;。</p>
<p>在项目填入 learngit，其他保持默认设置，点击“创建”按钮，就成功地创建了一个新的 Git 仓库:</p>
<p>目前，在 GitHub 上的这个 learngit 仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的 learngit 仓库下运行命令:</p>
<div><pre><code><span>git</span> remote <span>add</span> origin git@github.com:Hope-Studio/learngit.git
</code></pre><div aria-hidden="true"><div></div></div></div><p>请千万注意，把上面的 Hope-Studio 替换成您自己的 GitHub 账户名，否则，您在本地关联的就是希望工作室的远程库，关联没有问题，但是推送是推不上去的，因为您的 SSH Key 公钥不在希望工作室的账户列表中。</p>
<p>添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上:</p>
<div><pre><code>$ <span>git</span> push -u origin master
Counting objects: <span>20</span>, done.
Delta compression using up to <span>4</span> threads.
Compressing objects: <span>100</span>% <span>(</span><span>15</span>/15<span>)</span>, done.
Writing objects: <span>100</span>% <span>(</span><span>20</span>/20<span>)</span>, <span>1.64</span> KiB <span>|</span> <span>560.00</span> KiB/s, done.
Total <span>20</span> <span>(</span>delta <span>5</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
remote: Resolving deltas: <span>100</span>% <span>(</span><span>5</span>/5<span>)</span>, done.
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new branch<span>]</span>      master -<span>></span> master
Branch <span>'master'</span> <span>set</span> up to track remote branch <span>'master'</span> from <span>'origin'</span><span>.</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>把本地库的内容推送到远程，用 <code>git push</code> 命令，实际上是把当前分支 <code>master</code> 推送到远程。</p>
<p>由于远程库是空的，我们第一次推送 <code>master</code> 分支时，加上了 <code>-u</code> 参数，Git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样:</p>
<p>从现在起，只要本地作了提交，就可以通过命令:</p>
<div><pre><code><span>git</span> push origin master
</code></pre><div aria-hidden="true"><div></div></div></div><p>把本地 <code>master</code> 分支的最新修改推送至 GitHub，现在，您就拥有了真正的分布式版本库!</p>
<h2 id="ssh-警告" tabindex="-1"> SSH 警告</h2>
<p>当您第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告:</p>
<div><pre><code>The authenticity of <span>host</span> <span>'github.com (xx.xx.xx.xx)'</span> can't be established.
RSA key fingerprint is xx.xx.xx.xx.xx.
Are you sure you want to <span>continue</span> connecting <span>(</span>yes/no<span>)</span>?
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要您确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 <code>yes</code> 回车即可。</p>
<p>Git 会输出一个警告，告诉您已经把 GitHub 的 Key 添加到本机的一个信任列表里了:</p>
<div><pre><code>Warning: Permanently added 'github.com' (RSA) to the list of known hosts.
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果您实在担心有人冒充 GitHub 服务器，输入 <code>yes</code> 前可以对照 GitHub 的 RSA Key 的指纹信息是否与 SSH 连接给出的一致。</p>
<h3 id="关联小结" tabindex="-1"> 关联小结</h3>
<p>要关联一个远程库，使用命令 <code>git remote add origin git@&lt;server-name&gt;:&lt;path&gt;/&lt;repo-name&gt;.git</code>；</p>
<p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 master 分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的! 当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了!</p>
<h2 id="从远程库克隆" tabindex="-1"> 从远程库克隆</h2>
<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆 GitHub，创建一个新的仓库，名字叫 <code>gitskills</code>:</p>
<p>我们勾选使用 “readme 初始化项目”，这样 GitHub 会自动为我们创建一个 README.md 文件。创建完毕后，可以看到 README.md 文件。</p>
<p>现在，远程库已经准备好了，下一步是用命令 <code>git clone</code> 克隆一个本地库:</p>
<div><pre><code>$ <span>git</span> clone git@github.com:Hope-Studio/gitskills.git
Cloning into <span>'gitskills'</span><span>..</span>.
remote: Counting objects: <span>3</span>, done.
remote: Total <span>3</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, pack-reused <span>3</span>
Receiving objects: <span>100</span>% <span>(</span><span>3</span>/3<span>)</span>, done.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>提示</p>
<p>如果您使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。</p>
</div>
<p>注意把 Git 库的地址换成您自己的，然后进入 <code>gitskills</code> 目录看看，已经有 README.md 文件了:</p>
<div><pre><code>$ <span>cd</span> gitskills
$ <span>ls</span>
README.md
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>您也许还注意到，GitHub 给出的地址不止一个，还可以用 <a href="https://github.com/Hope-Studio/gitskills.git" target="_blank" rel="noopener noreferrer">https://github.com/Hope-Studio/gitskills.git</a> 这样的地址。实际上，Git 支持多种协议，默认的 <code>git://</code> 使用 ssh，但也可以使用 HTTPS 等其他协议。</p>
<p>使用 HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p>
<h3 id="克隆小结" tabindex="-1"> 克隆小结</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p>
<p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快。</p>
<h2 id="从远程仓库中抓取" tabindex="-1"> 从远程仓库中抓取</h2>
<p>从远程仓库中获得数据，可以执行:</p>
<div><pre><code><span>git</span> fetch <span>&lt;</span>remote<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个命令会访问远程仓库，从中拉取所有您还没有的数据。执行完成后，您将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p><code>git fetch origin</code> 会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意 <code>git fetch</code> 命令只会将数据下载到您的本地仓库——它并不会自动合并或修改您当前的工作。当准备好时您必须手动将其合并入您的工作。</p>
<h2 id="推送到远程仓库" tabindex="-1"> 推送到远程仓库</h2>
<p>当您想分享您的项目时，必须将其推送到上游。这个命令很简单: <code>git push &lt;remote&gt; &lt;branch&gt;</code>。当您
想要将 master 分支推送到 origin 服务器时(再次说明，克隆时通常会自动帮您设置好那两个名字)， 那么
运行这个命令就可以将您所做的备份到服务器:</p>
<div><pre><code><span>git</span> push origin master
</code></pre><div aria-hidden="true"><div></div></div></div><p>只有当您有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当您和其他人在同一时间克隆，他们先推送到上游然后您再推送到上游，您的推送就会毫无疑问地被拒绝。您必须先抓取他们的工作并将其合并进您的工作后才能推送。</p>
<h2 id="查看某个远程仓库" tabindex="-1"> 查看某个远程仓库</h2>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。如果想以一个特
定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息:</p>
<div><pre><code>$ <span>git</span> remote show origin
* remote origin
Fetch URL: https://github.com/schacon/ticgit
Push URL: https://github.com/schacon/ticgit
HEAD branch: master
Remote branches:
master tracked
dev-branch tracked
Local branch configured <span>for</span> <span>'git pull'</span><span>:</span>
master merges with remote master
Local ref configured <span>for</span> <span>'git push'</span><span>:</span>
master pushes to master <span>(</span>up to <span>date</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。这些信息非常有用，它告诉您正处于 master 分支，并且如果运行 <code>git pull</code>，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。它也会列出拉取到的所有远程引用。</p>
<h2 id="远程仓库的重命名与移除" tabindex="-1"> 远程仓库的重命名与移除</h2>
<p>您可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。例如，想要将 pb 重命名为 paul，可以用 <code>git remote rename</code> 这样做:</p>
<div><pre><code>$ <span>git</span> remote <span>rename</span> pb paul
$ <span>git</span> remote
origin
paul
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>值得注意的是这同样也会修改您所有远程跟踪的分支名字。那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——您已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code>:</p>
<div><pre><code>$ <span>git</span> remote remove paul
$ <span>git</span> remote
origin
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>一旦您使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
]]></content:encoded>
    </item>
    <item>
      <title>版本回退</title>
      <link>https://shimonzhan.com/software/git/reset.html</link>
      <guid>https://shimonzhan.com/software/git/reset.html</guid>
      <source url="https://shimonzhan.com/rss.xml">版本回退</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>修改 readme.txt 文件如下:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>然后尝试提交:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
<span># nothing displayed</span>
$ <span>git</span> commit -m <span>"append GPL"</span>
<span>[</span>master 1094adb<span>]</span> append GPL
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 <code>commit</code>。如果把文件改乱了，或者误删了文件，还可以从最近的一个 <code>commit</code> 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下 <code>readme.txt</code> 文件一共有几个版本被提交到 Git 仓库里了:</p>
<ul>
<li>版本 1: wrote a readme file</li>
</ul>
<div><pre><code>Git is a version control system.
Git is free software.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li>版本 2: add distributed</li>
</ul>
<div><pre><code>Git is a distributed version control system.
Git is free software.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ul>
<li>版本 3: append GPL</li>
</ul>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="查看版本信息" tabindex="-1"> 查看版本信息</h2>
<p>版本控制系统用 <code>git log</code> 命令可以告诉我们历史记录，在 Git 中，我们查看:</p>
<div><pre><code>$ <span>git</span> log
commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>HEAD -<span>></span> master<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:06:15 <span>2018</span> +0800

    append GPL

commit e475afc93c209a690c39c13a46716e8fa000c366
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:03:36 <span>2018</span> +0800

    <span>add</span> distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>20</span>:59:18 <span>2018</span> +0800

    wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>git log</code> 命令显示从最近到最远的提交日志，我们可以看到 3 次提交，最近的一次是 <code>append GPL</code>，上一次是 <code>add distributed</code>，最早的一次是 <code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <code>--pretty=oneline</code> 参数:</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>oneline
1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>HEAD -<span>></span> master<span>)</span> append GPL
e475afc93c209a690c39c13a46716e8fa000c366 <span>add</span> distributed
eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>一大串类似 <code>1094adb...</code> 的是 commit id (版本号)，和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，为什么 commit id 需要用这么一大串数字表示呢? 因为 Git 是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Git 历史，就可以更清楚地看到提交历史的时间线:</p>
<p><img src="@source/software/git/assets/timeline.jpg" alt="Git 时间线" loading="lazy"></p>
<div><p>更多选项</p>
<p>关于 <code>git log</code> 的更多选项，请见 <a href="/file/git/progit_v2.1.45.pdf">ProGit 书籍</a> 的 P43。</p>
</div>
<h2 id="回退版本" tabindex="-1"> 回退版本</h2>
<p>好了，现在准备把 readme.txt 回退到上一个版本，也就是 <code>add distributed</code> 的那个版本，怎么做呢?</p>
<p>首先，Git 必须知道当前版本是哪个版本，在 Git 中，用 <code>HEAD</code> 表示当前版本，也就是最新的提交 <code>1094adb...</code> (注意我的提交 ID 和您的肯定不一样)，上一个版本就是 <code>HEAD^</code>，上上一个版本就是 <code>HEAD^^</code>，当然往上 100 个版本写 100 个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code>。</p>
<p>现在，要把当前版本 <code>append GPL</code> 回退到上一个版本 <code>add distributed</code>，就可以使用 <code>git reset</code> 命令:</p>
<div><pre><code>$ <span>git</span> reset --hard HEAD^
HEAD is now at e475afc <span>add</span> distributed
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>看看 readme.txt 的内容是不是版本 add distributed:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>果然被还原了。</p>
<p>还可以继续回退到上一个版本 wrote a readme file，不过且慢，然我们用 <code>git log</code> 再看看现在版本库的状态:</p>
<div><pre><code>$ <span>git</span> log
commit e475afc93c209a690c39c13a46716e8fa000c366 <span>(</span>HEAD -<span>></span> master<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:03:36 <span>2018</span> +0800

    <span>add</span> distributed

commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>20</span>:59:18 <span>2018</span> +0800

    wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>最新的那个版本 append GPL 已经看不到了! 肿么办?</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，您就可以顺着往上找啊找啊，找到那个 append GPL 的 commit id 是 1094adb...，于是就可以指定回到未来的某个版本:</p>
<div><pre><code>$ <span>git</span> reset --hard 1094a
HEAD is now at 83b0afe append GPL
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看 readme.txt 的内容:</p>
<div><pre><code>$ <span>cat</span> readme.txt
Git is a distributed version control system.
Git is <span>free</span> software distributed under the GPL.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>果然，我胡汉三又回来了。</p>
<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 <code>HEAD</code> 指针，当您回退版本的时候，Git 仅仅是把 <code>HEAD</code> 从指向 append GPL:</p>
<p><img src="@source/software/git/assets/git1.jpg" alt="示例图4" loading="lazy"></p>
<p>改为指向 <code>add distributed</code>:</p>
<p><img src="@source/software/git/assets/git2.jpg" alt="示例图5" loading="lazy"></p>
<p>然后顺便把工作区的文件更新了。所以您让 <code>HEAD</code> 指向哪个版本号，您就把当前版本定位在哪。</p>
<h2 id="找回-commit-id" tabindex="-1"> 找回 commit id</h2>
<p>如果回退到了某个版本找不到新版本的 <code>commit id</code>，在 Git 中，就无法用 <code>$ git reset --hard HEAD^</code> 回退。</p>
<p>所以 Git 提供了一个命令 <code>git reflog</code> 用来记录您的每一次命令:</p>
<div><pre><code>$ <span>git</span> reflog
e475afc HEAD@<span>{</span><span>1</span><span>}</span>: reset: moving to HEAD^
1094adb <span>(</span>HEAD -<span>></span> master<span>)</span> HEAD@<span>{</span><span>2</span><span>}</span>: commit: append GPL
e475afc HEAD@<span>{</span><span>3</span><span>}</span>: commit: <span>add</span> distributed
eaadf4e HEAD@<span>{</span><span>4</span><span>}</span>: commit <span>(</span>initial<span>)</span>: wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>$ <span>git</span> reflog
e475afc HEAD@<span>{</span><span>1</span><span>}</span>: reset: moving to HEAD^
1094adb <span>(</span>HEAD -<span>></span> master<span>)</span> HEAD@<span>{</span><span>2</span><span>}</span>: commit: append GPL
e475afc HEAD@<span>{</span><span>3</span><span>}</span>: commit: <span>add</span> distributed
eaadf4e HEAD@<span>{</span><span>4</span><span>}</span>: commit <span>(</span>initial<span>)</span>: wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>终于舒了口气，从输出可知，append GPL 的 commit id 是 1094adb，现在，您又可以乘坐时光机回到未来了。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>
<p><code>HEAD</code> 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>。</p>
</li>
<li>
<p>用 <code>git log</code> 可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>用 <code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>服务器搭建</title>
      <link>https://shimonzhan.com/software/git/server.html</link>
      <guid>https://shimonzhan.com/software/git/server.html</guid>
      <source url="https://shimonzhan.com/rss.xml">服务器搭建</source>
      <description>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。
GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。
</description>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>
<p>GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</p>

<p>搭建 Git 服务器需要准备一台运行 Linux 的机器，强烈推荐用 Ubuntu 或 Debian，这样，通过几条简单的 <code>apt</code> 命令就可以完成安装。</p>
<ul>
<li>
<p><strong>Ubuntu</strong> 或 <strong>Debian</strong></p>
<p>假设您已经有 sudo 权限的用户账号，下面，正式开始安装。</p>
<ul>
<li>
<p>第一步，安装 git:</p>
<div><pre><code><span>sudo</span> <span>apt-get</span> <span>install</span> <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>第二步，创建一个 git 用户，用来运行 git 服务:</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>第三步，创建证书登录:</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的 <code>id_rsa.pub</code> 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
</li>
<li>
<p>第四步，初始化 Git 仓库:</p>
<p>先选定一个目录作为 Git 仓库，假定是 <code>/srv/sample.git</code>，在 <code>/srv</code> 目录下输入命令:</p>
<div><pre><code><span>sudo</span> <span>git</span> init --bare sample.git
</code></pre><div aria-hidden="true"><div></div></div></div><p>Git 就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把 owner 改为 git:</p>
<div><pre><code><span>sudo</span> <span>chown</span> -R git:git sample.git
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>第五步，禁用 shell 登录:</p>
<p>出于安全考虑，第二步创建的 git 用户不允许登录 shell，这可以通过编辑 <code>/etc/passwd</code> 文件完成。找到类似下面的一行:</p>
<div><pre><code>git:x:1001:1001:,,,:/home/git:/bin/bash
</code></pre><div aria-hidden="true"><div></div></div></div><p>改为:</p>
<div><pre><code>git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>
</li>
<li>
<p>第六步，克隆远程仓库:</p>
<p>现在，可以通过 <code>git clone</code> 命令克隆远程仓库了，在各自的电脑上运行:</p>
<div><pre><code>$ <span>git</span> clone git@server:/srv/sample.git
Cloning into <span>'sample'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>剩下的推送就简单了。</p>
</li>
</ul>
</li>
<li>
<p><strong>Centos</strong></p>
<ol>
<li>
<p>安装 Git</p>
<div><pre><code>yum <span>install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel
yum <span>install</span> <span>git</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>接下来创建一个 git 用户组和用户，用来运行 git 服务:</p>
<div><pre><code><span>groupadd</span> <span>git</span>
<span>useradd</span> <span>git</span> -g <span>git</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
<li>
<p>创建证书登录</p>
<p>收集所有需要登录的用户的公钥，公钥位于 <code>id_rsa.pub</code> 文件中，将公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
<p>如果没有该文件创建它:</p>
<div><pre><code><span>cd</span> /home/git/
<span>mkdir</span> .ssh
<span>chmod</span> <span>755</span> .ssh
<span>touch</span> .ssh/authorized_keys
<span>chmod</span> <span>644</span> .ssh/authorized_keys
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>初始化 Git 仓库</p>
<p>首先我们选定一个目录作为 Git 仓库，假定是 <code>/home/gitrepo/test.git</code>，在 <code>/home/gitrepo</code> 目录下输入命令:</p>
<div><pre><code>$ <span>cd</span> /home
$ <span>mkdir</span> gitrepo
$ <span>chown</span> git:git gitrepo/
$ <span>cd</span> gitrepo

$ <span>git</span> init --bare test.git
Initialized empty Git repository <span>in</span> /home/gitrepo/runoob.git/
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把仓库所属用户改为 git:</p>
<div><pre><code><span>chown</span> -R git:git runoob.git
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>克隆仓库</p>
</li>
</ol>
<div><pre><code>$ <span>git</span> clone git@192.168.45.4:/home/gitrepo/runoob.git
Cloning into <span>'runoob'</span><span>..</span>.
warning: You appear to have cloned an empty repository.
Checking connectivity<span>..</span>. done.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>192.168.45.4 为 Git 所在服务器 ip ，您需要将其修改为您自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>纵向查看</title>
      <link>https://shimonzhan.com/software/git/status.html</link>
      <guid>https://shimonzhan.com/software/git/status.html</guid>
      <source url="https://shimonzhan.com/rss.xml">纵向查看</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>现在，运行 <code>git status</code> 命令看看结果:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>git status</code> 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p>
<div><p>简介输出</p>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。Git 有一个选项可以帮您缩短状态命令的输出，这样可以以简洁的方式查看更改。如果您使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，您将得到一种格式更为紧凑的输出。</p>
<p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。</p>
<details><summary>案例</summary>
<div><pre><code>$ <span>git</span> status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的状态报告显示: <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。<code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
</details>
</div>
<p>Git 现在只告诉我们 readme.txt 被修改了，我们用 <code>git diff</code> 这个命令能看看具体修改了什么内容:</p>
<div><pre><code>$ <span>git</span> <span>diff</span> readme.txt
<span>diff</span> --git a/readme.txt b/readme.txt
index 46d49bf<span>..</span>9247db6 <span>100644</span>
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is <span>free</span> software.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>git diff</code> 顾名思义就是查看 difference，显示的格式正是 Unix 通用的 diff 格式，可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。</p>
<p>知道了对 readme.txt 作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是 <code>git add</code>:</p>
<div><pre><code>$ <span>git</span> <span>add</span> readme.txt
--no output --
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>同样没有任何输出。在执行第二步 <code>git commit</code> 之前，我们再运行 <code>git status</code> 看看当前仓库的状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    modified:   readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>git status</code> 告诉我们，将要被提交的修改包括 readme.txt，下一步，就可以放心地提交了:</p>
<div><pre><code>$ <span>git</span> commit -m <span>"add distributed"</span>
<span>[</span>master e475afc<span>]</span> <span>add</span> distributed
 <span>1</span> <span>file</span> changed, <span>1</span> insertion<span>(</span>+<span>)</span>, <span>1</span> deletion<span>(</span>-<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>提交后，我们再用 <code>git status</code> 命令看看仓库的当前状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>Git 告诉我们当前没有需要提交的修改，而且，工作目录是干净(working tree clean)的。</p>
<h2 id="小结" tabindex="-1"> 小结</h2>
<ul>
<li>
<p>要随时掌握工作区的状态，使用 <code>git status</code> 命令。</p>
</li>
<li>
<p>如果 <code>git status</code> 告诉您有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>标签管理</title>
      <link>https://shimonzhan.com/software/git/tag.html</link>
      <guid>https://shimonzhan.com/software/git/tag.html</guid>
      <source url="https://shimonzhan.com/rss.xml">标签管理</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="为什么要有-tag" tabindex="-1"> 为什么要有 tag</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签 (<code>tag</code>)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 <code>commit</code> 的指针(跟分支很像对不对? 但是分支可以移动，标签不能移动)，所以，创建和删除标签都是瞬间完成的。</p>
<p>Git 有 <code>commit</code>，为什么还要引入 <code>tag</code>?</p>
<p>“请把上周一的那个版本打包发布，<code>commit</code> 号是 6a5819e...”</p>
<p>“一串乱七八糟的数字不好找! ”</p>
<p>如果换一个办法:</p>
<p>“请把上周一的那个版本打包发布，版本号是 <code>v1.2</code>”</p>
<p>“好的，按照 <code>tag v1.2</code> 查找 <code>commit</code> 就行! ”</p>
<p>所以，<code>tag</code> 就是一个让人容易记住的有意义的名字，它跟某个 <code>commit</code> 绑在一起。</p>
<div><p>提示</p>
<p>推荐的标签规范是以小写字母 <code>v</code> 开头，后接 <code>x.x</code> 或 <code>x.x.x</code> 等若干位版本号。</p>
</div>
<h2 id="创建轻量标签" tabindex="-1"> 创建轻量标签</h2>
<p>在 Git 中打标签非常简单，首先，切换到需要打标签的分支上:</p>
<div><pre><code>$ <span>git</span> branch
* dev
  master
$ <span>git</span> checkout master
Switched to branch <span>'master'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，敲命令 <code>git tag &lt;name&gt;</code> 就可以打一个新标签:</p>
<div><pre><code>$ <span>git</span> tag v1.0
-- no output --
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>可以用命令 <code>git tag</code> 查看所有标签:</p>
<div><pre><code>$ <span>git</span> tag
v1.0
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>默认标签是打在最新提交的 <code>commit</code> 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办?</p>
<p>方法是找到历史提交的 <code>commit id</code>，然后打上就可以了:</p>
<div><pre><code>$ <span>git</span> log --pretty<span>=</span>oneline --abbrev-commit
12a631b <span>(</span>HEAD -<span>></span> master, tag: v1.0, origin/master<span>)</span> merged bug fix <span>101</span>
4c805e2 fix bug <span>101</span>
e1e9c68 merge with no-ff
f52c633 <span>add</span> merge
cf810e4 conflict fixed
5dc6824 <span>&amp;</span> simple
14096d0 AND simple
b17d20e branch <span>test</span>
d46f35e remove test.txt
b84166e <span>add</span> test.txt
519219b <span>git</span> tracks changes
e43a48b understand how stage works
1094adb append GPL
e475afc <span>add</span> distributed
eaadf4e wrote a readme <span>file</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>比方说要对 <code>add merge</code> 这次提交打标签，它对应的 <code>commit id</code> 是 <code>f52c633</code>，敲入命令:</p>
<div><pre><code>$ <span>git</span> tag v0.9 f52c633
--no output --
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>再用命令 <code>git tag</code> 查看标签:</p>
<div><pre><code>$ <span>git</span> tag
v0.9
v1.0
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息:</p>
<div><pre><code>$ <span>git</span> show v0.9
commit f52c63349bc3c1593499807e5c8e972b82c8f286 <span>(</span>tag: v0.9<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:56:54 <span>2018</span> +0800

    <span>add</span> merge

<span>diff</span> --git a/readme.txt b/readme.txt
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，<code>v0.9</code> 确实打在 <code>add merge</code> 这次提交上。</p>
<h2 id="附注标签" tabindex="-1"> 附注标签</h2>
<p>Git 还可以创建带有说明的标签，用 <code>-a</code> 指定标签名，<code>-m</code> 指定说明文字:</p>
<div><pre><code>$ <span>git</span> tag -a v0.1 -m <span>"version 0.1 released"</span> 1094adb
--no output --
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>用命令 <code>git show &lt;tagname&gt;</code> 可以看到说明文字:</p>
<div><pre><code>$ <span>git</span> show v0.1
tag v0.1
Tagger: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>22</span>:48:43 <span>2018</span> +0800

version <span>0.1</span> released

commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span>(</span>tag: v0.1<span>)</span>
Author: Michael Liao <span>&lt;</span>askxuefeng@gmail.com<span>></span>
Date:   Fri May <span>18</span> <span>21</span>:06:15 <span>2018</span> +0800

    append GPL

<span>diff</span> --git a/readme.txt b/readme.txt
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>提示</p>
<p>标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p>
</div>
<h3 id="添加小结" tabindex="-1"> 添加小结</h3>
<p>命令 <code>git tag &lt;tagname&gt;</code> 用于新建一个标签，默认为 <code>HEAD</code>，也可以指定一个 <code>commit id</code>；</p>
<p>命令 <code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code> 可以指定标签信息；</p>
<p>命令 <code>git tag</code> 可以查看所有标签。</p>
<h2 id="操作标签" tabindex="-1"> 操作标签</h2>
<p>如果标签打错了，也可以删除:</p>
<div><pre><code>$ <span>git</span> tag -d v0.1
Deleted tag <span>'v0.1'</span> <span>(</span>was f15b0dd<span>)</span><span>\</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code>:</p>
<div><pre><code>$ <span>git</span> push origin v1.0
Total <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new tag<span>]</span>         v1.0 -<span>></span> v1.0
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>或者，一次性推送全部尚未推送到远程的本地标签:</p>
<div><pre><code>$ <span>git</span> push origin --tags
Total <span>0</span> <span>(</span>delta <span>0</span><span>)</span>, reused <span>0</span> <span>(</span>delta <span>0</span><span>)</span>
To github.com:Hope-Studio/learngit.git
 * <span>[</span>new tag<span>]</span>         v0.9 -<span>></span> v0.9
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除:</p>
<div><pre><code>$ <span>git</span> tag -d v0.9
Deleted tag <span>'v0.9'</span> <span>(</span>was f52c633<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>然后，从远程删除。删除命令也是 push，但是格式如下:</p>
<div><pre><code>$ <span>git</span> push origin :refs/tags/v0.9
To github.com:Hope-Studio/learngit.git
 - <span>[</span>deleted<span>]</span>         v0.9
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。</p>
<h3 id="管理标签小结" tabindex="-1"> 管理标签小结</h3>
<ul>
<li>
<p>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</p>
</li>
<li>
<p>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>工作区和暂存区</title>
      <link>https://shimonzhan.com/software/git/working-directory.html</link>
      <guid>https://shimonzhan.com/software/git/working-directory.html</guid>
      <source url="https://shimonzhan.com/rss.xml">工作区和暂存区</source>
      <description>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。
</description>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>

<h2 id="工作区-working-directory" tabindex="-1"> 工作区(Working Directory)</h2>
<p>就是您在电脑里能看到的目录，比如 learngit 文件夹就是一个工作区:</p>
<h2 id="版本库-repository" tabindex="-1"> 版本库(Repository)</h2>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。</p>
<p>Git 的版本库里存了很多东西，其中最重要的就是称为 stage(或者叫 index)的暂存区，还有 Git 为我们自动创建的第一个分支 <code>master</code>，以及指向 master 的一个指针叫 <code>HEAD</code>。</p>
<p><img src="@source/software/git/assets/git3.jpg" alt="版本库图例" loading="lazy"></p>
<p>前面讲了我们把文件往 Git 版本库里添加的时候，提交更改，实际上就是把暂存区的所有内容提交到当前分支。我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 <code>master</code> 分支，所以，现在，<code>git commit</code> 就是往 master 分支上提交更改。</p>
<p>您可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>先对 readme.txt 做个修改，比如加上一行内容:</p>
<div><pre><code>Git is a distributed version control system.
Git is free software distributed under the GPL.
Git has a mutable index called stage.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>然后，在工作区新增一个 LICENSE 文本文件(内容随便写)。</p>
<p>先用 <code>git status</code> 查看一下状态:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes not staged <span>for</span> commit:
  <span>(</span>use <span>"git add &lt;file>..."</span> to update what will be committed<span>)</span>
  <span>(</span>use <span>"git checkout -- &lt;file>..."</span> to discard changes <span>in</span> working directory<span>)</span>

    modified:   readme.txt

Untracked files:
  <span>(</span>use <span>"git add &lt;file>..."</span> to include <span>in</span> what will be committed<span>)</span>

    LICENSE

no changes added to commit <span>(</span>use <span>"git add"</span> and/or <span>"git commit -a"</span><span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Git 非常清楚地告诉我们，readme.txt 被修改了，而 LICENSE 还从来没有被添加过，所以它的状态是 <code>Untracked</code>。</p>
<p>现在，使用两次命令 <code>git add</code>，把 readme.txt 和 LICENSE 都添加后，用 <code>git status</code> 再查看一下:</p>
<div><pre><code>$ <span>git</span> status
On branch master
Changes to be committed:
  <span>(</span>use <span>"git reset HEAD &lt;file>..."</span> to unstage<span>)</span>

    new file:   LICENSE
    modified:   readme.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>现在，暂存区的状态就变成这样了:</p>
<p><img src="@source/software/git/assets/git4.jpg" alt="状态示意图" loading="lazy"></p>
<p>所以，<code>git add</code> 命令实际上就是把要提交的所有修改放到暂存区(Stage)，然后，执行 <code>git commit</code> 就可以一次性把暂存区的所有修改提交到分支。</p>
<div><pre><code>$ <span>git</span> commit -m <span>"understand how stage works"</span>
<span>[</span>master e43a48b<span>]</span> understand how stage works
 <span>2</span> files changed, <span>2</span> insertions<span>(</span>+<span>)</span>
 create mode <span>100644</span> LICENSE
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>一旦提交后，如果您又没有对工作区做任何修改，那么工作区就是“干净”的:</p>
<div><pre><code>$ <span>git</span> status
On branch master
nothing to commit, working tree clean
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Git 原理</title>
      <link>https://shimonzhan.com/software/git/working.html</link>
      <guid>https://shimonzhan.com/software/git/working.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Git 原理</source>
      <category>Git</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 究竟是怎样的一个系统呢? 尽管 Git 用起来与其它的版本控制系统非常相似，但它在对信息的存储和认知方式上却有很大差异。</p>
<h2 id="直接记录快照-而非差异比较" tabindex="-1"> 直接记录快照，而非差异比较</h2>
<p>Git 和其它版本控制系统(包括 Subversion 和近似工具)的主要差别在于 Git 对待数据的方法。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统(CVS、Subversion、Perforce、Bazaar 等等)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 (它们通常称作 基于差异(delta-based) 的版本控制)。</p>
<p><img src="@source/software/git/assets/delta-based.png" alt="基于差异" loading="lazy"></p>
<p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。在 Git 中，每当您提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<p><img src="@source/software/git/assets/snapshot.png" alt="基于快照" loading="lazy"></p>
<h2 id="近乎所有操作都是本地执行" tabindex="-1"> 近乎所有操作都是本地执行</h2>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果您习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让您感到速度之神赐给了 Git 超凡的能量。因为您在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。您能立即看到项目历史。如果您想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>
<h2 id="git-保证完整性" tabindex="-1"> Git 保证完整性</h2>
<p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。若您在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列(hash，哈希)。这是一个由 40 个十六进制字符(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容或目录结构计算出来。Git 中使用这种哈希值的情况很多，您将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h2 id="git-一般只添加数据" tabindex="-1"> Git 一般只添加数据</h2>
<p>您执行的 Git 操作，几乎只往 Git 数据库中 添加 数据。您很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦您提交快照到 Git 中， 就难以再丢失数据，特别是如果您定期的推送数据库到其它仓库的话。</p>
<p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。</p>
<h2 id="三种状态" tabindex="-1"> 三种状态</h2>
<p>Git 有三种状态，您的文件可能处于其中之一: 已提交(committed)、已修改(modified) 和 已暂存(staged)。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段: 工作区、暂存区以及 Git 目录。</p>
<p>工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供您使用或修改。
暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。
Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。
基本的 Git 工作流程如下:</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将您想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。如果文件已修改并放入暂存区，就属于 已暂存 状态。如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub</title>
      <link>https://shimonzhan.com/software/github/</link>
      <guid>https://shimonzhan.com/software/github/</guid>
      <source url="https://shimonzhan.com/rss.xml">GitHub</source>
      <category>GitHub</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="快速上手" tabindex="-1"> 快速上手</h2>
<ul>
<li>
<p><a href="/software/github/intro.html">GitHub 介绍</a></p>
</li>
<li>
<p><a href="/software/github/pr.html">Pull Request</a></p>
</li>
<li>
<p><a href="/software/github/semantic.html">语义化提交</a></p>
</li>
<li>
<p><a href="/software/github/pages.html">GitHub Pages</a></p>
</li>
<li>
<p><a href="/software/github/speedup.html">利用 Gitee 加速 GitHub 克隆</a></p>
</li>
</ul>
<h2 id="官方文档" tabindex="-1"> 官方文档</h2>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github" target="_blank" rel="noopener noreferrer">全部文档</a></li>
</ul>
<h3 id="入门指南" tabindex="-1"> 入门指南</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github" target="_blank" rel="noopener noreferrer">查看详情</a></li>
</ul>
<h3 id="快速入门" tabindex="-1"> 快速入门</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/set-up-git" target="_blank" rel="noopener noreferrer">设置 Git</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/create-a-repo" target="_blank" rel="noopener noreferrer">创建仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/fork-a-repo" target="_blank" rel="noopener noreferrer">复刻仓库</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/be-social" target="_blank" rel="noopener noreferrer">社交化</a></li>
</ul>
<h3 id="了解-github" tabindex="-1"> 了解 GitHub</h3>
<ul>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/types-of-github-accounts" target="_blank" rel="noopener noreferrer">账户类型</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/access-permissions-on-github#%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E5%B8%90%E6%88%B7" target="_blank" rel="noopener noreferrer">GitHub 上的访问权限</a></li>
<li><a href="https://docs.github.com/cn/free-pro-team@latest/github/getting-started-with-github/github-glossary" target="_blank" rel="noopener noreferrer">GitHub 词汇表</a></li>
</ul>
<h2 id="生态系统" tabindex="-1"> 生态系统</h2>
<h3 id="github-cli" tabindex="-1"> GitHub Cli</h3>
<p>GitHub CLI 是用于在计算机上使用 GitHub 功能的命令行工具。</p>
<p>GitHub CLI 是用于从计算机的命令行使用 GitHub 的开源工具。从命令行操作时，您可以使用 GitHub CLI 来节省时间并避免切换上下文。</p>
<p>您可以将以下 GitHub 功能与 GitHub CLI 结合使用。</p>
<ul>
<li>查看、创建、克隆和复刻仓库</li>
<li>创建、关闭和列出议题和拉取请求</li>
<li>审查、差异和合并拉取请求</li>
<li>创建、编辑、列出和查看 Gist</li>
</ul>
<p>有关 GitHub CLI 用途的更多信息，请参阅 <a href="https://cli.github.com/manual" target="_blank" rel="noopener noreferrer">GitHub CLI 手册</a>。</p>
<h3 id="github-desktop" tabindex="-1"> GitHub Desktop</h3>
<p>GitHub Desktop 使用可视界面扩展并简化您的 Git 和 GitHub 工作流程。</p>
<p>GitHub Desktop 是一种开源工具，可帮助您提高工作效率。GitHub Desktop 鼓励您和您的团队使用最佳实践协作处理 Git 和 GitHub。</p>
<p>您可以使用 GitHub Desktop 执行许多任务，包括:</p>
<ul>
<li>以交互方式将更改添加到提交中</li>
<li>快速将合作作者提交到提交中</li>
<li>检出具有拉取请求的分支并查看 CI 状态</li>
<li>比较更改的图像</li>
</ul>
<p>有关 GitHub Desktop 的更多信息，请参阅 GitHub Desktop 文档中的 <a href="https://docs.github.com/cn/free-pro-team@latest/desktop/installing-and-configuring-github-desktop" target="_blank" rel="noopener noreferrer">安装和配置 GitHub Desktop</a>。</p>
<h3 id="手机版-github" tabindex="-1"> 手机版 GitHub</h3>
<p>从移动设备对 GitHub 上的工作进行分类、协作和管理。</p>
<p>手机版 GitHub 目前作为 Android 和 iOS app 提供给 GitHub.com 用户。</p>
<p>手机版 GitHub 为您提供随时随地快速高效使用 GitHub 的方式。手机版 GitHub 是通过可信的第一方客户端应用程序访问 GitHub 数据的安全可靠方式。</p>
<p>通过 手机版 GitHub，您可以:</p>
<ul>
<li>管理、分类和清除通知</li>
<li>阅读、审查及协作处理问题和拉取请求</li>
<li>搜索、浏览用户、仓库和组织以及与之交互</li>
<li>当有人提及您的用户名时收到推送通知</li>
</ul>
<h4 id="安装-手机版-github" tabindex="-1"> 安装 手机版 GitHub</h4>
<p>要安装 Android 或 iOS 版 手机版 GitHub，请参阅 <a href="https://github.com/mobile" target="_blank" rel="noopener noreferrer">手机版 GitHub</a>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>自动部署</title>
      <link>https://shimonzhan.com/software/github/deploy.html</link>
      <guid>https://shimonzhan.com/software/github/deploy.html</guid>
      <source url="https://shimonzhan.com/rss.xml">自动部署</source>
      <description>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。
</description>
      <category>GitHub</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文介绍如何利用 Git 和 GitHub Action，自动部署代码到服务器。</p>

<div><p>提示</p>
<p>由于 Centos 仍然是用 GitV1，本教程使用 Ubuntu 20.04 进行教学。</p>
</div>
<h2 id="服务器" tabindex="-1"> 服务器</h2>
<p>为了能供自动部署到服务器，我们需要让服务器的网站目录成为一个 Git 仓库，这样我们可以在 GitHub Actions 中，通过向服务器对应 GitHub 仓库推送网站内容，使服务器网站获得自动更新。下面是服务器侧的部署配置</p>
<h3 id="添加账户" tabindex="-1"> 添加账户</h3>
<p>为了安全，首先需要使用命令创建 Git 用户，为了安全请务必设置密码。</p>
<div><pre><code><span>sudo</span> adduser <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>之后，查看部署目录所在组，git 用户添加到组中。</p>
<div><pre><code><span>usermod</span> -a -G <span>&lt;</span>目录所在组<span>></span> <span>git</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后将部署目录的权限设置为 <code>775</code>，即允许同组访问。这样 git 就有权限访问部署目录。</p>
<h3 id="添加权限" tabindex="-1"> 添加权限</h3>
<p>创建 <code>~/.ssh/</code> 文件夹，生成 <code>authorized_keys</code> 文件，并设置其权限为 <code>600</code>。</p>
<div><pre><code><span>mkdir</span> -p ~/.ssh/

<span>touch</span> ~/.ssh/authorized_keys

<span>chmod</span> <span>600</span> ~/.ssh/authorized_keys
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>之后将需要赋予权限的用户公钥依次粘贴至该文件，这样相关用户即可以使用对应私钥，向服务器相关仓库推送代码。</p>
<h3 id="创建仓库" tabindex="-1"> 创建仓库</h3>
<p>回到 <code>/home/git/</code>，创建所需的文件夹:</p>
<div><pre><code><span>cd</span> ~
<span>mkdir</span> <span>&lt;</span>仓库名<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>进入文件夹，使用</p>
<div><pre><code><span>git</span> init --separate-git-dir<span>=</span>. <span>&lt;</span>部署位置<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>这会将 git 库保持在 <code>/home/git/&lt;仓库名&gt;</code> 下，同时将工作区设置到部署文件夹中。</p>
<p>接下来执行:</p>
<div><pre><code><span>git</span> config receive.denyCurrentBranch ignore
</code></pre><div aria-hidden="true"><div></div></div></div><p>这是由于 Git 默认拒绝外部对当前分支的推送操作，因为这可能会覆盖或变更工作区文件。</p>
<p>设置完毕后，Git 会允许外部对当前工作区分支进行推送操作。</p>
<h2 id="github-actions" tabindex="-1"> GitHub Actions</h2>
<p>在 GitHub 一侧，我们需要通过 GitHub Action，在新代码推送时自动构建网站，并部署到 GitHub 的 gh-pages 分支。之后，GitHub Action 将该分支的变动推送服务器的对应仓库，完成网站的自动部署。</p>
<p>之后只需要使用 GitHub Action 通过 Git 推送到 <code>git@&lt;domain&gt;:&lt;部署目录&gt; gh-pages</code> 即可。</p>
<div><pre><code><span># 自动部署的名称</span>
<span>name</span><span>:</span> GitHub pages deploy

<span># 自动部署的条件</span>
<span>on</span><span>:</span>
  <span>push</span><span>:</span>
    <span>branches</span><span>:</span>
      <span>-</span> master

<span>jobs</span><span>:</span>
  <span># 构建网站并部署到 GitHub Pages</span>
  <span>deploy-gh-pages</span><span>:</span>
    <span># 运行环境</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest

    <span># 步骤</span>
    <span>steps</span><span>:</span>
      <span># 第一步: 下载源码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span># action 配置详见 https://github.com/actions/checkout</span>
        <span>uses</span><span>:</span> actions/checkout@v3
        <span>with</span><span>:</span>
          <span># 如果本项目包含了子模块 (git submodules)，需要将此项设置为 true</span>
          <span># submodules: true</span>

          <span># 这是获取历史 commit 的深度，默认为 1，即只拉取最后一个 commit</span>
          <span># 这样可以加快拉取速度</span>
          <span>#</span>
          <span># 如果项目使用 VuePress，为了正确通过 Git 历史提交记录生成页面的最后更新时间</span>
          <span># 需要设置为 0 以拉取完整的 git 历史提交</span>
          <span># fetch-depth: 0</span>

          <span># 如果子模块包含私有仓库，需要设置 ssh key 或 token 以保证拥有拉取相应仓库的权限</span>
          <span># 您可以将 ssh-key 设置为 github 绑定公钥对应的私钥</span>
          <span># 也可以新建一个具有相关仓库访问权限的 github token</span>
          <span># token:</span>

      <span># 缓存 node_modules 以避免重复安装</span>
      <span>-</span> <span>uses</span><span>:</span> actions/cache@v3
        <span>id</span><span>:</span> node<span>-</span>modules
        <span>with</span><span>:</span>
          <span># 需要缓存的路径</span>
          <span>path</span><span>:</span> node_modules/
          <span># 缓存的 key</span>
          <span>key</span><span>:</span> $<span>{</span><span>{</span> runner.os <span>}</span><span>}</span><span>-</span>node<span>-</span>modules<span>-</span>$<span>{</span><span>{</span> hashFiles('yarn.lock') <span>}</span><span>}</span>
          <span># 恢复 key</span>
          <span>restore-keys</span><span>:</span> <span>|</span><span>
            ${{ runner.os }}-node-modules-</span>

      <span># 安装依赖</span>
      <span>-</span> <span>name</span><span>:</span> Install Deps
        <span># 只有没有命中缓存才会执行</span>
        <span>if</span><span>:</span> steps.node<span>-</span>modules.outputs.cache<span>-</span>hit <span>!=</span> 'true'
        <span># 严格按照 yarn.lock 安装依赖</span>
        <span>run</span><span>:</span> yarn install <span>-</span><span>-</span>frozen<span>-</span>lockfile

      <span># 构建项目</span>
      <span>-</span> <span>name</span><span>:</span> Build
        <span># 项目的构建命令</span>
        <span>run</span><span>:</span> yarn run build

      <span># 第四步，部署</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># action 配置详见 https://github.com/JamesIves/github-pages-deploy-action</span>
        <span>uses</span><span>:</span> JamesIves/github<span>-</span>pages<span>-</span>deploy<span>-</span>action@v4
        <span>with</span><span>:</span>
          <span># 部署到的分支</span>
          <span>branch</span><span>:</span> gh<span>-</span>pages
          <span># 需要部署的文件夹</span>
          <span>folder</span><span>:</span> dist

  <span># 部署到服务器</span>
  <span>deploy-server</span><span>:</span>
    <span>runs-on</span><span>:</span> ubuntu<span>-</span>latest
    <span># 确保在部署到 GitHub Pages 之后执行</span>
    <span>needs</span><span>:</span> deploy<span>-</span>gh<span>-</span>pages
    <span>steps</span><span>:</span>
      <span># 检出网站代码</span>
      <span>-</span> <span>name</span><span>:</span> Checkout
        <span>uses</span><span>:</span> actions/checkout@v3
        <span>with</span><span>:</span>
          <span># 检出 gh-pages 分支</span>
          <span>ref</span><span>:</span> gh<span>-</span>pages
          <span># 获取全部的历史提交</span>
          <span>fetch-depth</span><span>:</span> <span>0</span>

      <span># 配置环境</span>
      <span>-</span> <span>name</span><span>:</span> Configuration environment
        <span># 写入私钥、配置 Git 用户名，写入服务器地址</span>
        <span># 您需要自行将服务器的私钥写入 secrets 的 SSH_PRIVATE_KEY</span>
        <span>run</span><span>:</span> <span>|</span><span>
          mkdir -p ~/.ssh/
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan &lt;your domain> >> ~/.ssh/known_hosts
          git config --global user.name 'Your Name'
          git config --global user.email 'You email'</span>

      <span># 部署到服务器</span>
      <span>-</span> <span>name</span><span>:</span> Deploy
        <span># 使用 Git 将网站代码强制推送到远程的网站目录</span>
        <span># 并使用 SSH 连接服务器进入网站目录手动切换到最新提交</span>
        <span>run</span><span>:</span> <span>|</span><span>
          git push -f git@&lt;your domain>:&lt;deploy dir> gh-pages
          ssh git@&lt;your domain> "cd &lt;deploy dir> &amp;&amp; git reset --hard HEAD"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>GitHub 简介</title>
      <link>https://shimonzhan.com/software/github/intro.html</link>
      <guid>https://shimonzhan.com/software/github/intro.html</guid>
      <source url="https://shimonzhan.com/rss.xml">GitHub 简介</source>
      <category>GitHub</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="gayhub-github-是世界上最大的-同性交友-代码托管网站" tabindex="-1"> <s>Gayhub</s> GitHub 是世界上最大的 <s>同性交友</s> 代码托管网站</h2>
<p>😋当然在上面交友也是极好的(这是重点，圈起来要考的😎)。</p>
<h2 id="基本概念" tabindex="-1"> 基本概念</h2>
<h3 id="repository" tabindex="-1"> repository</h3>
<p>仓库。一个仓库即是一个项目。仓库是 GitHub 上的主要内容。每当您新建一个项目并想要在 GitHub。</p>
<h3 id="star" tabindex="-1"> Star</h3>
<p>收藏。在每一个仓库主页的上方可以看到 star 按钮。其上的数值为收藏该项目的人数。点击星星即可将当前仓库收藏到您的账号上。您可以收藏一些您比较喜欢，或者项目对您来说有很大价值的项目。同时，点击数字可以看到哪些人收藏了这个项目。</p>
<h3 id="fork" tabindex="-1"> fork</h3>
<p>复刻。在每一个仓库主页的上方可以看到 Fork 按钮。点击该按钮的作用是将当前项目复刻一份到自己的仓库中，这样，您就可以在此仓库仓库上查看当前、历史的版本，切换分支、或者是随心所欲的进行修改。原项目的新的推送、对历史版本的修改、甚至原作者删除了他的 repo，都不会对您 fork 的项目产生任何影响。</p>
<h3 id="issue" tabindex="-1"> issue</h3>
<p>议题。这是一个类似讨论区的地方。如果您在使用该项目的过程中遇到了问题，可以在相应项目的 Issue 板块按照项目的要求提出 Issue。在 Issue 中可以汇报一个 bug，或者是提出一个 Feature Request (功能请求)。项目的拥有者会针对您汇报的情况对您做出回复。同时，项目拥有者还可以为此 issue 增加 label (标签)，以帮助项目成员或是项目的其他使用者更好的理解您提出 issue。也可以将您的 issue assign (分派) 给特定的项目成员解决。</p>
<div><p>提示</p>
<p>为了 GitHub 的友好交流环境，请在汇报 bug 时永远带上 bug 的一个简易的复现流程，可以直接建立一个简单的 bug repository 并把链接放置在您提出的 issue 中。</p>
</div>
<h3 id="pull-request" tabindex="-1"> pull request</h3>
<p>发起推送请求，简称 <strong>PR</strong>。如果是您自己的项目，您可以从一个分支向另一个分支发起推送请求。如果您想对别人的(您无权进行推送)项目进行代码的推送请求的化，需要先 fork 这个仓库。在自己 fork 的项目上进行修改，然后提交到自己的项目上，之后，建立一个从自己仓库到对方仓库的 PR。如果对方觉得您的新改动很不错，在经过测试或者 review 后就会接受它，这样原有项目就可拥有这些新的代码了.</p>
<h3 id="watch" tabindex="-1"> watch</h3>
<p>关注，在每一个仓库主页的上方可以看到 Watch 按钮。如果您关注了某个项目,那么这个项目有了变化的时候,您就会得到通知.在您点击关注后，您还可以点击下拉列表进一步设置关注级别。您可以选择接受 Release (新发布) 通知，也可以选择 Watching 来监听所有的通知。当您选择 Ignore 的话，即使有人在这个仓库中 metion (提到) 了您，您也不会得到通知。</p>
<h3 id="review" tabindex="-1"> review</h3>
<p>审查。当项目收到 PR 时，项目的拥有成员可以对这份 PR 的代码改动进行审查，在 Review 的过程中，可以对代码的特定行或特定几行通过 comment(评论) 的方式来提出自己对代码改动的意见。</p>
<h2 id="主页" tabindex="-1"> 主页</h2>
<p><img src="@source/software/github/assets/mainPage.png" alt="个人主页" loading="lazy"></p>
<p><a href="https://github.com" target="_blank" rel="noopener noreferrer">https://github.com</a></p>
<p>主页，在您登陆后，屏幕的左侧会展示您和您加入团队的项目，以及您的团队详情。中部会显示您关注的项目、人的动态，右侧会根据算法展示一些您可能会感兴趣的 repo。</p>
<h2 id="个人主页" tabindex="-1"> 个人主页</h2>
<p><img src="@source/software/github/assets/profile.png" alt="个人主页" loading="lazy"></p>
<p><strong>地址:</strong> <code>https://github.com/&lt;您的用户名&gt;</code></p>
<p>个人主页会有几个主要面板:</p>
<h3 id="overview" tabindex="-1"> Overview</h3>
<p>个人概览，您可以在上方 pin(固定) 最多六个您想要展示给他人的仓库。</p>
<p>下方就是您过去一年里向 GitHub 的提交数量分布图，以及您在 GitHub 上的活动比例。</p>
<p>最下方是近几年您在 GitHub 上的活动记录。</p>
<h3 id="repositories" tabindex="-1"> Repositories</h3>
<p><img src="@source/software/github/assets/personalRepo.png" alt="个人仓库" loading="lazy"></p>
<p>仓库列表，该面板会按照最后更新时间的倒序，展示该用户拥有的所有 reo，同时也会在面板上展示项目的 Descript(描述)、Star 数、Fork 数、语言、协议、标签，以及过去一年内项目的 commit 分布数量。这些都能够帮助浏览者在不进入具体仓库页面的情况下大致了解每一个仓库的内容、欢迎程度与维护情况。</p>
<h3 id="projects" tabindex="-1"> Projects</h3>
<p>个人拥有的项目，在管理自己与团队跨仓库的活动日程时很有用。可以设置涉及到的仓库，提出任务、代办、时间表等。</p>
<h3 id="packages" tabindex="-1"> Packages</h3>
<p>个人在 GitHub 上拥有的包。目前较少人在 GitHub 上发布相关的包。</p>
<h3 id="stars" tabindex="-1"> Stars</h3>
<p>和仓库列表完全相同，只不过展示该用户收藏的 repo。</p>
<h3 id="followers-following" tabindex="-1"> Followers / Following</h3>
<p>关注您的人 / 关注的人。在个人主页的左侧就有 follow 按钮，follow 一个人意味着这个人在 GitHub 的的活动会出现在 GitHub 主页的 Activity List 上。</p>
<h2 id="仓库主页" tabindex="-1"> 仓库主页</h2>
<p><img src="@source/software/github/assets/repo.png" alt="仓库主页" loading="lazy"></p>
<p>仓库主页主要显示项目的信息。从左到右的面板依次是: Code(代码)，Issues (问题)、Pull Requests (提交请求)、Actions (自动流程)、 Projects (项目)、 Wiki (项目介绍)、 Security (项目安全)、 Insights (项目数据统计) 与 Settings (项目设置)。</p>
<p>在下方会展示代码文件以及项目说明 README.md 文件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Pages</title>
      <link>https://shimonzhan.com/software/github/pages.html</link>
      <guid>https://shimonzhan.com/software/github/pages.html</guid>
      <source url="https://shimonzhan.com/rss.xml">GitHub Pages</source>
      <description>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。
您可以将站点托管在 GitHub 的 github.io 域名或您自己的自定义域名上。
</description>
      <category>GitHub</category>
      <pubDate>Sat, 20 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>GitHub Pages 是静态站点托管服务，可直接从 GitHub 上的存储库中获取 HTML，CSS 和 JavaScript 文件，还可以选择在构建过程中运行这些文件并发布网站。</p>
<p>您可以将站点托管在 GitHub 的 <code>github.io</code> 域名或您自己的自定义域名上。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>GitHub Pages 站点共有三种类型: 项目，用户和组织。</p>
<p>项目站点连接到 GitHub 上托管的特定项目，而用户和组织站点已连接到特定的 GitHub 帐户。</p>
<ul>
<li>要发布用户站点，您必须创建一个名为的用户帐户拥有的存储库 <code>&lt;username&gt;.github.io</code>。</li>
<li>要发布组织站点，您必须创建一个名为的组织所拥有的存储库 <code>&lt;organization&gt;.github.io</code>。</li>
</ul>
<p>除非您使用自定义域名，否则用户站点和组织站点均位于 <code>http(s)://&lt;username&gt;.github.io</code> 或 <code>http(s)://&lt;organization&gt;.github.io</code>。</p>
<p>项目站点的源文件与其项目存储在同一存储库中。除非您使用自定义域，否则项目站点可在 <code>http(s)://&lt;username&gt;.github.io/&lt;repository&gt;</code> 或 <code>http(s)://&lt;organization&gt;.github.io/&lt;repository&gt;</code> 访问。</p>
<p>虽然您只能在 GitHub 上为每个帐户创建一个用户或组织站点。但无论是组织还是用户帐户拥有的项目站点都是无限的。</p>
<h2 id="发布源文件到-github-pages" tabindex="-1"> 发布源文件到 GitHub Pages</h2>
<div><p>警告</p>
<p>GitHub Pages 站点 默认在互联网上公开，即使站点的仓库是私有的。</p>
</div>
<p>如果您的存储库中存在默认发布源，则 GitHub Pages 将自动从该源发布网站。用户和组织站点的默认发布源是存储库的默认分支的根目录。项目站点的默认发布源是 gh-pages 分支的根目录。</p>
<p>您需要跳转到 Settings (设置) 选项卡，下来找到 GitHub Pages 的配置部分。</p>
<div><p>提示</p>
<p>您只能在根目录 (<code>/</code>) 和 文档目录 (<code>/docs</code>) 之间进行选择，而不能将仓库内的任意文件夹作为发布源。</p>
</div>
<h3 id="静态站点" tabindex="-1"> 静态站点</h3>
<p>GitHub Pages 发布您推送到存储库的所有静态文件，这意味它不支持服务器端语言，例如 PHP，Ruby 或 Python。也就是您只能通过 GitHub Pages 发布 “无后端” 的纯静态站点。</p>
<h3 id="限制" tabindex="-1"> 限制</h3>
<ul>
<li>
<p>GitHub Pages 网站不得超过 1 GB。</p>
</li>
<li>
<p>GitHub Pages 站点的带宽限制为每月 100GB。</p>
</li>
<li>
<p>GitHub Pages 站点限制为每小时最多构建 10 次。</p>
</li>
</ul>
<h3 id="子模块" tabindex="-1"> 子模块</h3>
<p>如果 GitHub Pages 站点的仓库包含子模块，则在构建站点时会自动拉取其内容。</p>
<p>只能使用指向公共仓库的子模块，因为 GitHub Pages 服务器无法访问私有仓库。</p>
<p>对子模块 (包括嵌套子模块) 使用 <code>https://</code> 只读 URL。 您可以在 .gitmodules 文件中进行此更改。</p>
<h2 id="取消发布" tabindex="-1"> 取消发布</h2>
<h3 id="取消发布项目站点" tabindex="-1"> 取消发布项目站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>如果仓库中存在 gh-pages 分支，请删除 gh-pages 分支。</li>
<li>在仓库名称下，单击 Settings (设置) 。</li>
<li>在“ GitHub Pages”下，使用 Source (源) 下拉菜单并选择 None (无) 。</li>
</ol>
<h3 id="取消发布用户或组织站点" tabindex="-1"> 取消发布用户或组织站点</h3>
<ol>
<li>在 GitHub 上，导航到仓库的主页面。</li>
<li>删除用作发布源的分支，或删除整个仓库。</li>
</ol>
<h2 id="自定义域名" tabindex="-1"> 自定义域名</h2>
<p>您可以在对应仓库的 Settings (设置) 选项卡设置自定义域名，同时您需要将自定义域名的 CNAME 记录指向 <code>&lt;用户名&gt;.github.io</code>。</p>
<div><p>提示</p>
<p>自定义域名的控制是由发布源文件夹下的 CNAME 文件控制的，您可以直接创建这个文件写入链接。</p>
<p>同时，GitHub Pages 要求这个文件一直存在，否则自定义域名会失效。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Pull Request</title>
      <link>https://shimonzhan.com/software/github/pr.html</link>
      <guid>https://shimonzhan.com/software/github/pr.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Pull Request</source>
      <category>GitHub</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>对于一个用户的公开仓库，在默认情况下虽然其他用户可以拉取该库的代码，但是他们并不能够直接向这个库进行推送。</p>
<p>GitHub 是一个代码社区，这意味着鼓励大家互相提交与贡献代码。所以这就是 Fork 和 Pull Request 出现的意义。没有人会给一个陌生人添加访问自己仓库的权限，所以我们需要一种方式，能够让大家向仓库所有者发起贡献代码的请求。这就是 pull request 的由来。</p>
<h2 id="提交自己贡献的代码" tabindex="-1"> 提交自己贡献的代码</h2>
<p>对于代码贡献者来说，他需要用一种方法将自己贡献的代码推送到远程库上，以便发起请求，最好的办法就是 fork 原仓库。</p>
<p><img src="@source/software/github/assets/fork.png" alt="Fork 仓库" loading="lazy"></p>
<div><p>相关信息</p>
<p>相关介绍，请见 <a href="/software/github/intro.html#fork">GitHub 简介 → fork</a></p>
</div>
<p>这样，贡献者在自己的账号上获得一个和原仓库完全相同的副本。</p>
<p>既然副本已经创建在自己的账号上，贡献者自然可以:</p>
<ol>
<li>克隆这个项目到本地</li>
<li>在这个项目上贡献自己的代码</li>
<li>将贡献的代码推送到这个副本上</li>
</ol>
<h2 id="发送请求" tabindex="-1"> 发送请求</h2>
<p>pull request 是请求仓库所有者拉取指定仓库分支代码的请求。</p>
<p>在贡献自己的代码并推送到自己的 fork 仓库后，贡献者即可到原仓库去选择自己仓库的对应分支发送这个拉取请求。仓库所有者随时可以批准这个更改，使其自动添加到自己的库中，或是拒绝这个请求。</p>
<p><img src="@source/software/github/assets/pull-request.png" alt="Pull request" loading="lazy"></p>
<blockquote>
<p>这个仓库我已经删了所以显示 <code>unknown repository</code>，原为 <code>Mister-Hope:master</code></p>
</blockquote>
<p>这个页面允许所有人在主要对话线上交换自己的意见。</p>
<p>在 Pull request 里，一旦请求被创建，仓库所有者应该可以直观地看到哪些文件发生了怎样的改变。</p>
<p><img src="@source/software/github/assets/file-changes.png" alt="文件改动" loading="lazy"></p>
<p>同时，他们也可以对贡献者的代码进行审查，对特定行或片段标注，并陈述自己的意见，同时将这个意见根据程度标注为“探讨”、“改进”或者“必须更改”，以便贡献者进行交流讨论与完善修改。</p>
<p><img src="@source/software/github/assets/pull-request-review.png" alt="代码审查" loading="lazy"></p>
<p>同时，对于一个大型库来说，仓库所有者应该可以看到贡献的代码是否通过了所有测试。</p>
<p><img src="@source/software/github/assets/pull-request-check.png" alt="测试通过情况" loading="lazy"></p>
<p>如果审查者认为没有问题，他可能就会通过这个拉取请求，拉取对应的代码到自己的仓库上。这样您就完成了对这个仓库的贡献。</p>
<h2 id="同步原仓库" tabindex="-1"> 同步原仓库</h2>
<p>需要注意的是，fork 创建的是一个时刻副本，也就是自己 fork 产生的仓库，会保持 fork 时的状态，原仓库的任何变动都不会自动同步到 fork 的仓库上。</p>
<p>有些时候，在自己 fork 原仓库、自己编写代码并提交的这段时间里，原仓库已经进行了很多提交。这时，我们就需要同步原仓库的更新到自己的副本上，以确保自己贡献的代码并未和新增代码发生冲突、可以正常工作。</p>
<p>这个时候只需反向拉取，在自己的仓库创建原仓库特定分支到自己仓库特定分支的 Pull request，并批准这个 pull request。这样即可很方便的将原仓库特定分支的更新同步到自己的副本上。</p>
<p>您当然可以在本地添加原仓库的远程库，将最新的更改直接 fetch 到本地，在本地测试通过并完成合并后，由本地推送至自己的 fork 仓库。</p>
]]></content:encoded>
    </item>
    <item>
      <title>语义化提交</title>
      <link>https://shimonzhan.com/software/github/semantic.html</link>
      <guid>https://shimonzhan.com/software/github/semantic.html</guid>
      <source url="https://shimonzhan.com/rss.xml">语义化提交</source>
      <category>GitHub</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="semantic" tabindex="-1"> Semantic</h2>
<p>对于一个大型项目，几千个 commit 是很常见的，这些 commit 部分是项目维护者提交的 commit，部分是一些热心的开发者通过 PR 贡献的。</p>
<p>无论是对于项目维护者，还是想要贡献代码的热心开发者来说，一个简洁明了的 commit 描述都是必不可少的。也就是说我们需要用尽可能简短的备注信息，备注每一个 commit 的作用，以便大家查看。所以我们需要一种规范的，语义化的备注格式，很快由知名项目牵头，全球接收并统一了一种语义化的备注格式，这就是 semantic 规范的来源。</p>
<h2 id="优势" tabindex="-1"> 优势</h2>
<p>当一个仓库所有的 commit 信息都是用标准的 semantic 格式时，用户可以很方便的理解每一个 commit 的作用。</p>
<p>同时，senmantic 支持直接将某个提交或 PR 与特定 issue 链接，并自动关闭或引用这些 issue。</p>
<p>通过一些第三方工具，大家可以基于这些备注信息进行过滤查找，更新日志生成等操作。</p>
<h2 id="格式" tabindex="-1"> 格式</h2>
<div><pre><code>&lt;type>(&lt;scope>): &lt;subject>
&lt;body>

&lt;footer>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="header" tabindex="-1"> header</h3>
<p>第一行被称为 <code>header</code>，它必须只有一行，包括三个字段: <code>&lt;type&gt;</code>(必需)、<code>&lt;scope&gt;</code>(可选)和 <code>&lt;subject&gt;</code>(必需)</p>
<h3 id="type" tabindex="-1"> type</h3>
<p>commit 的类型。</p>
<p>规范中规定了如下类型:</p>
<ul>
<li><code>feat</code>: feature, 新增功能</li>
<li><code>fix</code> : bug fix, 修复 bug</li>
<li><code>docs</code>: documentation, 仅仅修改了文档，如 <code>README.md</code></li>
<li><code>style</code>: style, 仅仅是对格式进行修改，如逗号、缩进、空格等，不改变代码逻辑</li>
<li><code>refactor</code>: refactor, 代码重构，一般更改了源文件或测试文件，但没有新增功能或修复 bug</li>
<li><code>perf</code>: preformance, 优化相关，如提升性能、用户体验等</li>
<li><code>test</code>: test, 测试用例，包括单元测试，集成测试</li>
<li><code>chore</code>: chore, 对于库的其他内容的改变，一般不涉及到源文件或测试文件，比如更改 CI 设置，提升仓库以来等</li>
<li><code>revert</code>: 版本回滚</li>
</ul>
<h3 id="scope" tabindex="-1"> scope</h3>
<p>用于说明 commit 影响的范围，比如: <code>views</code> , <code>component</code>, <code>utils</code>, <code>test</code>。这个是由项目的内容与结构决定的。</p>
<h3 id="subject" tabindex="-1"> subject</h3>
<p>commit 目的的简短描述，最好小于 50 字符，一般不超过 65 个字符，最长不超过 80 字符。</p>
<p>当 subject 限制的字符数无法详细说明此 commit 的变动时，将 commit 的具体变动放置在 body 中</p>
<h3 id="body" tabindex="-1"> body</h3>
<p>对本次 commit 修改内容的具体描述，可以分为多行。<code>body</code> 是可选的，而且 <code>body</code> 可以有多行。</p>
<h3 id="footer" tabindex="-1"> footer</h3>
<p>可选的，前面有一空行。可以添加一些备注，一般放置 <code>BREAKING CHANGE</code>(一些破坏性的变动) 或修复的 bug(涉及的 issue)的链接。</p>
<h2 id="semantic-commit-与-changelog-生成" tabindex="-1"> Semantic commit 与 Changelog 生成</h2>
<p>不同语言环境都有很多种工具来帮助您创建一个 semantic commit 或者自动生成 changelog。</p>
<div><p>案例</p>
<p>Node.js 环境下可以使用:</p>
<ul>
<li>
<p><a href="https://github.com/commitizen/cz-conventional-changelog" target="_blank" rel="noopener noreferrer"><code>cz-conventional-changelog</code></a> 提供 <code>git cz</code> 命令辅助创建 semantic commit。</p>
</li>
<li>
<p><a href="https://github.com/conventional-changelog/conventional-changelog" target="_blank" rel="noopener noreferrer"><code>conventional-changelog-cli</code></a> 来快速生成更新日志，如 <a href="https://github.com/Mister-Hope/vuepress-theme-hope/blob/master/CHANGELOG.md" target="_blank" rel="noopener noreferrer">vuepress-theme-hope 的更改日志</a></p>
</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>加速 GitHub 克隆</title>
      <link>https://shimonzhan.com/software/github/speedup.html</link>
      <guid>https://shimonzhan.com/software/github/speedup.html</guid>
      <source url="https://shimonzhan.com/rss.xml">加速 GitHub 克隆</source>
      <category>GitHub</category>
      <pubDate>Thu, 18 Feb 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于天朝墙的存在，GitHub 的访问速度在大部分国内地区都很慢。如果需要克隆体积比较大的项目，可能需要很长时间，也很大概率会在中途因为网络波动、终端问题导致克隆失败。</p>
<p>本文介绍如何使用 Gitee 加快 GitHub 项目克隆。</p>
<h2 id="gitee" tabindex="-1"> Gitee</h2>
<p>Gitee 又称码云，是一个国内的代码托管商，国内访问 Gitee 的速度是十分 Amazing 的。</p>
<h3 id="注册" tabindex="-1"> 注册</h3>
<p>Gitee 账户可以很方便的通过 GitHub 账户 + 绑定手机号注册。</p>
<h3 id="添加公钥" tabindex="-1"> 添加公钥</h3>
<p>完成注册后，您需要上传本地公钥，以保证可以从 Gitee 上拉取或克隆，其步骤与 GitHub 大致相同。</p>
<h3 id="导入-github-仓库" tabindex="-1"> 导入 GitHub 仓库</h3>
<p>码云的企业专线访问 GitHub 的速度很快，而码云在新建仓库的时候提供了导入选项，这就给我们的加速提供了方式。</p>
<p>我们只需要在码云上新建仓库，选择导入，然后输入自己想要克隆的 GitHub 仓库地址，交给码云完成导入即可。</p>
<p>稍等片刻后，码云即会将 GitHub 的仓库同步到自己的服务器上，此时我们只需要克隆码云上的这个仓库地址，就可以高速克隆这个项目。</p>
<h3 id="远程库地址修改" tabindex="-1"> 远程库地址修改</h3>
<p>在克隆完毕后，本地的 origin 远程库会默认为 Gitee 的仓库，此时我们需要使用 <code>git remote rename origin gitee</code> 命令，将码云的远程仓库重命名为 <code>gitee</code>，并使用 <code>git remote add origin &lt;github url&gt;</code> 命令重新添加 GitHub 的远程仓库为 origin。</p>
<p>这样我们稍后在做出本地提交后，即可直接推送到 GitHub 仓库。</p>
<h3 id="同步仓库" tabindex="-1"> 同步仓库</h3>
<p>如果以导入的形式创建码云仓库。则可以随时点击仓库页面上的同步图标，让码云随时拉取最新的 gitee 代码，以便在本地通过 <code>git fetch gitee</code>，通过码云服务器高速拉取最新代码。</p>
]]></content:encoded>
    </item>
    <item>
      <title>GitHub Token</title>
      <link>https://shimonzhan.com/software/github/token.html</link>
      <guid>https://shimonzhan.com/software/github/token.html</guid>
      <source url="https://shimonzhan.com/rss.xml">GitHub Token</source>
      <description>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。
</description>
      <category>GitHub</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Personal Access Token (PAT)，又称个人访问令牌，是一种代替密码进行 GitHub 身份认证的方式。</p>

<h2 id="创建个人访问令牌" tabindex="-1"> 创建个人访问令牌</h2>
<ol>
<li>
<p>访问 <a href="https://github.com/settings/tokens/new" target="_blank" rel="noopener noreferrer">新建 Token 页面</a> (当然您需要先登陆 GitHub)</p>
<blockquote>
<p>或者可以点击头像 → Settings → Developer settings → Personal access tokens → Generate new Token</p>
</blockquote>
</li>
<li>
<p>输入一个备注，选择您需要授权 Token 访问的内容，之后点击页面底部的 &quot;Generate Token&quot;</p>
</li>
<li>
<p>妥善保存该 Token (因为您无法再次查看它)</p>
</li>
</ol>
<p>详见 <a href="https://docs.github.com/cn/github/authenticating-to-github/creating-a-personal-access-token" target="_blank" rel="noopener noreferrer">创建个人访问令牌</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL</title>
      <link>https://shimonzhan.com/software/mysql/</link>
      <guid>https://shimonzhan.com/software/mysql/</guid>
      <source url="https://shimonzhan.com/rss.xml">MySQL</source>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li><a href="/software/mysql/intro.html">介绍</a></li>
<li><a href="/software/mysql/compare.html">5.7 版本与 8 的比较</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>5.7 与 8</title>
      <link>https://shimonzhan.com/software/mysql/compare.html</link>
      <guid>https://shimonzhan.com/software/mysql/compare.html</guid>
      <source url="https://shimonzhan.com/rss.xml">5.7 与 8</source>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="mysql-5-7-和-mysql-8-的区别" tabindex="-1"> MySql 5.7 和 MySql 8 的区别</h2>
<ol>
<li>
<p>NoSql 存储</p>
<p>Mysql 从 5.7 版本提供了 NoSQL 的存储功能,在 8.0 中这部分得到一些修改。</p>
<ul>
<li>
<p>关系型数据库 (SQL)
通过外键关联来建立表与表之间的关系</p>
</li>
<li>
<p>非关系型数据库 (NOSQL)
通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定</p>
</li>
</ul>
</li>
<li>
<p>隐藏索引</p>
<p>隐藏索引的特性对于性能调试非常有用,在 8.0 中,索引可以被隐藏和显示,当一个索引隐藏时,他不会被查询优化器所使用</p>
<p>也就是说可以隐藏一个索引,然后观察对数据库的影响.如果性能下降,就说明这个索引是有效的,于是将其”恢复显示”即可;如果数据库性能看不出变化,说明这个索引是多于的,可以删掉了</p>
</li>
<li>
<p>设置持久化</p>
<p>MySQL 的设置可以在运行时通过 <code>SET GLOBAL</code> 命令来更改，但是这种更改只会临时生效，到下次启动时数据库又会从配置文件中读取。</p>
<p>MySQL 8.0 新增了 <code>SET PERSIST</code> 命令，
例如: <code>SET PERSIST max_connections = 500;</code>
MySQL 会将该命令的配置保存到数据目录下的 <code>mysqld-auto.cnf</code> 文件中，下次启动时会读取该文件，用其中的配置来覆盖缺省的配置文件。</p>
</li>
<li>
<p>UTF-8 编码</p>
<p>从 MySQL 8.0 开始，数据库的缺省编码将改为 utf8mb4，这个编码包含了所有 emoji 字符。
多少年来我们使用 MySQL 都要在编码方面小心翼翼，生怕忘了将缺省的 latin 改掉而出现乱码问题。从此以后就不用担心了。</p>
</li>
<li>
<p>通用表表达式 (Common Table Expressions)</p>
<p>看上去层次和区域都更加分明，改起来也更清晰的知道要改哪一部分。</p>
</li>
<li>
<p>窗口函数 (Window Functions)</p>
<p>从 8.0 开始，MySQL 新增了一个叫窗口函数的概念，它可以用来实现若干新的查询方式。</p>
<p>窗口函数有点像是 <code>SUM()</code>、<code>COUNT()</code> 那样的集合函数，但它并不会将多行查询结果合并为一行，而是将结果放回多行当中。也就是说，窗口函数是不需要 <code>GROUP BY</code> 的。</p>
</li>
<li>
<p>新的系统字典表</p>
<p>整合了存储有关数据库对象信息的事务数据字典，所有的元数据都用 <code>InnoDB</code> 引擎进行存储</p>
</li>
<li>
<p>安全和用户管理</p>
<p>新增 <code>caching_sha2_password</code> 认证插件，并且是默认的身份认证插件。性能和安全方面加强</p>
<p>权限支持 role</p>
<p>新增密码历史记录功能，限制重复使用以前的密码</p>
</li>
<li>
<p>innodb 增强</p>
<p>新增 <code>INFORMATION_SCHEMA.INNODB_CACHED_INDEXES</code>，查看每个索引缓存在 <code>InnoDB</code> 缓冲池中的索引页数</p>
<p>新增 <code>INFORMATION_SCHEMA.INNODB_TABLESPACES_BRIEF</code> 视图</p>
<p>新增了动态配置项 <code>innodb_deadlock_detect</code>，用来禁用死锁检查，因为在高并发系统中，当大量线程等待同一个锁时，死锁检查会大大拖慢数据库</p>
<p>支持使用 <code>innodb_directories</code> 选项在服务器脱机时将表空间文件移动或恢复到新位置</p>
<p>新增 <code>innodb_dedicated_server</code>，让 <code>InnoDB</code> 根据服务器上检测到的内存量自动配置 <code>innodb_buffer_pool_size</code>, <code>innodb_log_file_size，innodb_flush_method</code>。</p>
<p><code>innodb_dedicated_server</code>: 自动配置缓冲池大小</p>
</li>
<li>
<p>直方图</p>
<p>MySQL 8.0 版本开始支持期待已久直方图。优化器会利用 <code>column_statistics</code> 的数据，判断字段的值的分布，得到更准确的执行计划。</p>
<p>可以使用 <code>ANALYZE TABLE table_name [UPDATE HISTOGRAM on col_name with N BUCKETS |DROP HISTOGRAM ON clo_name]</code> 来收集或者删除直方图信息</p>
<p>支持会话级别 <code>SET_VAR</code> 动态调整部分参数，有利于提升语句性能。</p>
</li>
<li>
<p>InnoDB 性能提升</p>
<p>废除 <code>buffer pool mutex</code>, 将原来一个 <code>mutex</code> 拆分成多个，提高并发拆分 <code>LOCK_thd_list</code> 和 <code>LOCK_thd_remove</code> 这两个 <code>mutex</code>，大约可提高线程链接效率 5%。</p>
<ol>
<li>
<p>行缓存</p>
<p>MySQL 8.0 的优化器可以估算将要读取的行数，因此可以提供给存储引擎一个合适大小的 <code>row buffer</code> 来存储需要的数据。大批量的连续数据扫描的性能将受益于更大的 <code>record buffer</code>。</p>
</li>
<li>
<p>改进扫描性能</p>
<p>改进 <code>InnoDB</code> 范围查询的性能，可提升全表查询和范围查询 5-20%的性能。</p>
</li>
<li>
<p>成本模型</p>
<p><code>InnoDB</code> 缓冲区可以估算缓存区中的有多少表和索引，这可以让优化器选择访问方式时知道数据是否可以存储在内存中还是必须存储到磁盘上。</p>
</li>
</ol>
</li>
</ol>
<h2 id="mysql-5-7-和-8-的选择" tabindex="-1"> MySql 5.7 和 8 的选择</h2>
<p>MySQL 8 会使用更多内存。</p>
<p>对运行相同轻量级工作负载的 MySQL 8 和 MySQL 5.7 (实际上它们是 Percona Server 版本) 的 1GB VM 进行基本测试。</p>
<p>MySQL 8 使用了大约 200MB 的 <code>swap</code> 分区，并且使用更少的系统缓存，被分配更多内存。</p>
<p>如果我们查看 <code>top</code> 命令的输出，我们会看到 MySQL 8 使用的更多常驻内存和虚拟内存。特别是“可怕的”虚拟内存，因为它远远超过这些 VM 上可用的 1GB 物理内存。当然，虚拟内存使用 (VSZ) 是现代应用程序实际内存需求的一个很差的指标，但它确实证实了更高的内存需求这个事。</p>
<p>实际上，正如我们从 <code>vmstat</code> 输出中所知道的那样，即使没有太多的“空间”，MySQL 8 和 MySQL 5.7 都不会在低负载下使用 <code>swap</code> 分区。</p>
<p>如果您有多个连接或希望在同一个 VM 上运行某些应用程序，则可以使用 <code>swap</code> (如果未启用交换，则可能导致 OOM)。这是一个有趣的实验，能看看我有多少可以驱动 MySQL 5.7 和 MySQL 8 的内存消耗。</p>
<p>总结在开发环境中迁移到 MySQL 8 时，请记住，使用相同的设置需要比 MySQL 5.7 配置更多的内存。</p>
]]></content:encoded>
    </item>
    <item>
      <title>简介</title>
      <link>https://shimonzhan.com/software/mysql/intro.html</link>
      <guid>https://shimonzhan.com/software/mysql/intro.html</guid>
      <source url="https://shimonzhan.com/rss.xml">简介</source>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品。</p>
<p>它是最流行的关系型数据库管理系统之一，是最好的 RDBMS 关系数据库管理系统应用软件之一</p>
<p>MySQL 使用 SQL 语言，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站都选择 MySQL 作为网站数据库。</p>
<h2 id="安装" tabindex="-1"> 安装</h2>
<p>下载地址: <a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener noreferrer">https://dev.mysql.com/downloads/</a></p>
<p>在这个下载界面会有几个版本的选择,</p>
<ol>
<li>
<p>MySQL Community Server 社区版本，开源免费，但不提供官方技术支持。</p>
</li>
<li>
<p>MySQL Enterprise Edition 企业版本，需付费，可以试用 30 天。</p>
</li>
<li>
<p>MySQL Cluster 集群版，开源免费。可将几个 MySQL Server 封装成一个 Server。</p>
</li>
<li>
<p>MySQL Cluster CGE 高级集群版，需付费。</p>
</li>
<li>
<p>MySQL Workbench ( GUITOOL )一款专为 MySQL 设计的 ER/数据库建模工具。它是著名的数据库设计工具 DBDesigner4 的继任者。</p>
<p>MySQL Workbench 又分为两个版本，分别是社区版( MySQL Workbench OSS )、商用版( MySQL WorkbenchSE )。</p>
</li>
</ol>
<p>MySQL Community Server 是开源免费的，这也是我们通常用的 MySQL 的版本。</p>
<ol>
<li>
<p>下载后得到 <code>.zip</code> 压缩包.</p>
</li>
<li>
<p>解压到自己想要安装到的目录</p>
</li>
<li>
<p>添加环境变量: 我的电脑 → 属性 → 高级 → 环境变量</p>
<p>选择 PATH，在其后面添加: mysql 安装文件下面的 bin 文件夹</p>
</li>
<li>
<p>新建 mysql 配置文件</p>
<p>在 mysql 文件夹中新建 <code>my.ini</code> 文件,编辑 <code>my.ini</code> 文件,注意替换路径位置</p>
<div><pre><code><span><span>[</span><span>mysqld</span><span>]</span></span>
<span>basedir</span><span>=</span><span>D:\Program Files\mysql-5.7\</span>
<span>datadir</span><span>=</span><span>D:\Program Files\mysql-5.7\data\</span>
<span>port</span><span>=</span><span>3306</span>
skip-grant-tables
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>启动管理员模式下的 CMD，输入 <code>cd /d bin目录路径</code> 将路径切换至 mysql 下的 bin 目录，然后输入 <code>mysqld –install</code> (安装 mysql )</p>
</li>
<li>
<p>再输入 <code>mysqld --initialize-insecure --user=mysql</code> 初始化数据文件</p>
</li>
<li>
<p>然后输入 <code>net start mysql</code> 再次启动 mysql,然后用命令 <code>mysql –u root –p</code> 进入 mysql 管理界面 (密码可为空)</p>
</li>
<li>
<p>进入界面后更改 root 密码</p>
<p><code>update mysql.user set authentication_string=password('123456') where user='root' and Host = 'localhost';</code></p>
</li>
<li>
<p>刷新权限 <code>flush privileges;</code></p>
</li>
</ol>
<p><img src="@source/software/mysql/assets/flush-privileges.png" alt="flush privileges" loading="lazy"></p>
<ol>
<li>
<p>修改 <code>my.ini</code> 文件删除最后一句 <code>skip-grant-tables</code></p>
<div><pre><code><span><span>[</span><span>mysqld</span><span>]</span></span>
<span>basedir</span><span>=</span><span>D:\work\mysql-5.7.19\</span>
<span>datadir</span><span>=</span><span>D:\work\mysql-5.7.19\data\</span>
<span>port</span><span>=</span><span>3306</span>
<span>#skip-grant-tables</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>重启 mysql 即可正常使用</p>
<div><pre><code>net stop mysql
net start mysql
</code></pre><div aria-hidden="true"><div></div><div></div></div></div></li>
<li>
<p>连接上测试出现以下结果就安装好了
<img src="@source/software/mysql/assets/result.png" alt="result" loading="lazy"></p>
</li>
</ol>
<h2 id="连接数据库" tabindex="-1"> 连接数据库</h2>
<ol>
<li>
<p>打开 MySQL 命令窗口</p>
<ul>
<li>在 DOS 命令行窗口进入 安装目录 <code>\mysql\bin</code></li>
<li>可设置环境变量，设置了环境变量，可以在任意目录打开</li>
</ul>
</li>
<li>
<p>输入连接数据库语句:
<code>mysql -h 服务器主机地址 -u 用户名 -p 用户密码</code></p>
<div><p>注意</p>
<p><code>-p</code> 后面不能多加空格，否则会被当做密码的内容，导致登录失败。</p>
</div>
</li>
</ol>
<h2 id="几个基本的数据库操作命令" tabindex="-1"> 几个基本的数据库操作命令</h2>
<div><pre><code>mysql -h 服务器主机地址 -u 用户名 -p 用户密码 连接数据库

update user set password=password('123456')where user='root'; 修改密码

flush privileges; 刷新数据库

show databases; 显示所有数据库

use dbname；打开某个数据库

show tables; 显示数据库 mysql 中所有的表

describe user; 显示表 mysql 数据库中 user 表的列信息

create database name; 创建数据库

use databasename; 选择数据库

exit; 退出 Mysql

? 命令关键词 : 寻求帮助

-- 表示注释
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="数据库基本操作" tabindex="-1"> 数据库基本操作</h2>
<h3 id="操作数据库" tabindex="-1"> 操作数据库</h3>
<ol>
<li>
<p>创建数据库</p>
<div><pre><code><span>CREATE</span> <span>DATABASE</span> name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>显示数据库</p>
<div><pre><code><span>show</span> <span>databases</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意: 为了不再显示的时候乱码，要修改数据库默认编码。以下以 <code>GBK</code> 编码页面为例进行说明:</p>
<ol>
<li>
<p>修改 MYSQL 的配置文件: <code>my.ini</code> 里面修改 <code>default-character-set=gbk</code></p>
</li>
<li>
<p>代码运行时修改:</p>
<ol>
<li>Java 代码: <code>jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk</code></li>
<li>PHP 代码: <code>header(&quot;Content-Type:text/html;charset=gb2312&quot;);</code></li>
<li>C 语言代码: <code>int mysql_set_character_set( MYSQL * mysql, char * csname)；</code>
该函数用于为当前连接设置默认的字符集。字符串 <code>csname</code> 指定了 1 个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与 <code>SET NAMES</code> 语句类似，但它还能设置 mysql → charset 的值，从而影响了由 <code>mysql_real_escape_string()</code> 设置的字符集。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>删除数据库</p>
<div><pre><code><span>drop</span> <span>database</span> name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>删除一个已经确定存在的数据库</li>
</ul>
<div><pre><code><span>drop</span> <span>database</span> name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>删除一个不确定存在的数据库</li>
</ul>
<div><pre><code><span>drop</span> <span>database</span> <span>if</span> <span>exists</span> name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>选择数据库</p>
<div><pre><code><span>use</span> name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>use 语句可以通过 MySQL 把 name 数据库作为默认 (当前) 数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的 USE 语句</p>
<p>使用 use 语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从 db1 数据库访问作者表，并从 db2 数据库访问编辑表</p>
<div><pre><code>mysql<span>></span> <span>USE</span> db1<span>;</span>
mysql<span>></span> <span>SELECT</span> author_name<span>,</span>editor_name <span>FROM</span> author<span>,</span>db2<span>.</span>editor
    <span>-</span><span>></span>        <span>WHERE</span> author<span>.</span>editor_id <span>=</span> db2<span>.</span>editor<span>.</span>editor_id<span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>USE 语句被设立出来，用于与 Sybase 相兼容。</p>
<p>use 数据库后，使用 <code>show databases</code> 就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。</p>
</li>
<li>
<p>当前选择的数据库</p>
<div><pre><code><span>select</span> <span>database</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>MySQL 中 <code>SELECT</code> 命令类似于其他编程语言里的 <code>print</code> 或者 <code>write</code>，您可以用它来显示一个字符串、数字、数学表达式的结果等等,</p>
<ol>
<li>
<p>显示 MYSQL 的版本</p>
<div><pre><code>mysql<span>></span> <span>select</span> version<span>(</span><span>)</span><span>;</span>
<span>+</span><span>-----------------------+</span>
<span>|</span> version<span>(</span><span>)</span>             <span>|</span>
<span>+</span><span>-----------------------+</span>
<span>|</span> <span>6.0</span><span>.4</span><span>-</span>alpha<span>-</span>community <span>|</span>
<span>+</span><span>-----------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.02</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>显示当前时间</p>
<div><pre><code>mysql<span>></span> <span>select</span> <span>now</span><span>(</span><span>)</span><span>;</span>
<span>+</span><span>---------------------+</span>
<span>|</span> <span>now</span><span>(</span><span>)</span>               <span>|</span>
<span>+</span><span>---------------------+</span>
<span>|</span> <span>2009</span><span>-</span><span>09</span><span>-</span><span>15</span> <span>22</span>:<span>35</span>:<span>32</span> <span>|</span>
<span>+</span><span>---------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.04</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>显示年月日</p>
<div><pre><code><span>SELECT</span> DAYOFMONTH<span>(</span><span>CURRENT_DATE</span><span>)</span><span>;</span>
<span>+</span><span>--------------------------+</span>
<span>|</span> DAYOFMONTH<span>(</span><span>CURRENT_DATE</span><span>)</span> <span>|</span>
<span>+</span><span>--------------------------+</span>
<span>|</span>                       <span>15</span> <span>|</span>
<span>+</span><span>--------------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.01</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>SELECT</span> <span>MONTH</span><span>(</span><span>CURRENT_DATE</span><span>)</span><span>;</span>
<span>+</span><span>---------------------+</span>
<span>|</span> <span>MONTH</span><span>(</span><span>CURRENT_DATE</span><span>)</span> <span>|</span>
<span>+</span><span>---------------------+</span>
<span>|</span>                   <span>9</span> <span>|</span>
<span>+</span><span>---------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span>SELECT</span> <span>YEAR</span><span>(</span><span>CURRENT_DATE</span><span>)</span><span>;</span>
<span>+</span><span>--------------------+</span>
<span>|</span> <span>YEAR</span><span>(</span><span>CURRENT_DATE</span><span>)</span> <span>|</span>
<span>+</span><span>--------------------+</span>
<span>|</span>               <span>2009</span> <span>|</span>
<span>+</span><span>--------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>显示字符串</p>
<div><pre><code>mysql<span>></span> <span>SELECT</span> <span>"welecome to my blog!"</span><span>;</span>
<span>+</span><span>----------------------+</span>
<span>|</span> welecome <span>to</span> my blog<span>!</span> <span>|</span>
<span>+</span><span>----------------------+</span>
<span>|</span> welecome <span>to</span> my blog<span>!</span> <span>|</span>
<span>+</span><span>----------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>当计算器用</p>
<div><pre><code><span>select</span> <span>(</span><span>(</span><span>4</span> <span>*</span> <span>4</span><span>)</span> <span>/</span> <span>10</span> <span>)</span> <span>+</span> <span>25</span><span>;</span>
<span>+</span><span>----------------------+</span>
<span>|</span> <span>(</span><span>(</span><span>4</span> <span>*</span> <span>4</span><span>)</span> <span>/</span> <span>10</span> <span>)</span> <span>+</span> <span>25</span> <span>|</span>
<span>+</span><span>----------------------+</span>
<span>|</span>                <span>26.60</span> <span>|</span>
<span>+</span><span>----------------------+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>串接字符串</p>
<div><pre><code><span>select</span> CONCAT<span>(</span>f_name<span>,</span> <span>" "</span><span>,</span> l_name<span>)</span>
<span>AS</span> Name
<span>from</span> employee_data
<span>where</span> title <span>=</span> <span>'Marketing Executive'</span><span>;</span>
<span>+</span><span>---------------+</span>
<span>|</span> Name          <span>|</span>
<span>+</span><span>---------------+</span>
<span>|</span> Monica Sehgal <span>|</span>
<span>|</span> Hal Simlai    <span>|</span>
<span>|</span> Joseph Irvine <span>|</span>
<span>+</span><span>---------------+</span>
<span>3</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意: 这里用到<code>CONCAT()</code>函数，用来把字符串串接起来。另外，用 <code>AS</code> 给结果列 'CONCAT(f_name, &quot; &quot;, l_name)' 起了个假名。</p>
</li>
</ol>
</li>
</ol>
<h3 id="操作数据表" tabindex="-1"> 操作数据表</h3>
<ol>
<li>
<p>创建数据表</p>
<div><pre><code><span>create</span> <span>table</span> <span>&lt;</span>表名<span>></span> <span>(</span> <span>&lt;</span>字段名<span>1</span><span>></span> <span>&lt;</span>类型<span>1</span><span>></span> <span>[</span><span>,</span><span>.</span><span>.</span><span>&lt;</span>字段名n<span>></span> <span>&lt;</span>类型n<span>></span><span>]</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例如，建立一个名为 User 的表，</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>数字类型</th>
<th>数据宽度</th>
<th>是否为空</th>
<th>是否主键</th>
<th>自动增加</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>int</td>
<td>4</td>
<td>否</td>
<td>primary key</td>
<td>auto_increment</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td>char</td>
<td>20</td>
<td>否</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>sex</td>
<td>int</td>
<td>4</td>
<td>否</td>
<td></td>
<td></td>
<td>0</td>
</tr>
</tbody>
</table>
<div><pre><code>mysql&gt; create table MyClass(
    -&gt; id int(4) not null primary key auto_increment,
    -&gt; name char(20) not null,
    -&gt; sex int(4) not null default '0');
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>删除数据表</p>
<div><pre><code><span>drop</span> <span>table</span> <span>&lt;</span>表名<span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>
<p><code>DROP TABLE</code> 用于取消一个或多个表。您必须有每个表的 <code>DROP</code> 权限。所有的表数据和表定义会被取消，所以使用本语句要小心!</p>
</li>
<li>
<p>注意: 对于一个带分区的表，<code>DROP TABLE</code> 会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。<code>DROP TABLE</code> 还会取消与被取消的表有关联的分区定义 (.par) 文件。</p>
</li>
<li>
<p>对于不存在的表，使用<code>IF EXISTS</code>用于防止错误发生。当使用<code>IF EXISTS</code>时，对于每个不存在的表，会生成一个<code>NOTE</code>。</p>
</li>
</ul>
</li>
<li>
<p>向表中插入数据</p>
<div><pre><code><span>insert</span> <span>into</span> <span>&lt;</span>表名<span>></span> <span>[</span><span>(</span> <span>&lt;</span>字段名<span>1</span><span>></span><span>[</span><span>,</span><span>.</span><span>.</span><span>&lt;</span>字段名n <span>></span> <span>]</span><span>)</span><span>]</span> <span>values</span> <span>(</span> 值<span>1</span> <span>)</span><span>[</span><span>,</span> <span>(</span> 值n <span>)</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例如: 往表 MyClass 中插入二条记录,
编号为 1 的名为 Tom 的性别为 0,
编号为 2 的名为 Joan 的性别为 1</p>
<div><pre><code>mysql<span>></span> <span>insert</span> <span>into</span> MyClass <span>values</span><span>(</span><span>1</span><span>,</span><span>'Tom'</span><span>,</span><span>0</span><span>)</span><span>,</span><span>(</span><span>2</span><span>,</span><span>'Joan'</span><span>,</span><span>1</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意: <code>insert into</code> 每次只能向表中插入一条记录。</p>
</li>
<li>
<p>查询数据表中的数据</p>
<div><pre><code><span>select</span> <span>&lt;</span>字段<span>1</span>，字段<span>2</span>，<span>.</span><span>.</span><span>.</span><span>></span> <span>from</span> <span>&lt;</span> 表名 <span>></span> <span>where</span> <span>&lt;</span> 表达式 <span>></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ol>
<li>
<p>查询所有行
例如: 查看表 MyClass 中所有数据</p>
<div><pre><code>mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> MyClass<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>查询前几行数据
例如: 查看表 MyClass 中前 2 行数据</p>
<div><pre><code>mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> MyClass <span>order</span> <span>by</span> id <span>limit</span> <span>0</span><span>,</span><span>2</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
</ol>
<p>select 一般配合 where 使用，以查询更精确更复杂的数据</p>
</li>
<li>
<p>删除数据表中的数据</p>
<div><pre><code><span>delete</span> <span>from</span> 表名 <span>where</span> 表达式
</code></pre><div aria-hidden="true"><div></div></div></div><p>例如: 删除表 MyClass 中编号为 1 的记录</p>
<div><pre><code>mysql<span>></span> <span>delete</span> <span>from</span> MyClass <span>where</span> id<span>=</span><span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>下面是一个删除数据前后表的对比。</p>
<div><pre><code>mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> MyClass<span>;</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span> id <span>|</span> name <span>|</span> sex <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span>  <span>1</span> <span>|</span> Tom  <span>|</span>   <span>0</span> <span>|</span>
<span>|</span>  <span>2</span> <span>|</span> Joan <span>|</span>   <span>1</span> <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>2</span> <span>rows</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span> <span>delete</span> <span>from</span> MyClass <span>where</span> id<span>=</span><span>1</span><span>;</span>
Query OK<span>,</span> <span>1</span> <span>row</span> affected <span>(</span><span>0.02</span> sec<span>)</span>

mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> MyClass<span>;</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span> id <span>|</span> name <span>|</span> sex <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span>  <span>2</span> <span>|</span> Joan <span>|</span>   <span>1</span> <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>修改数据表中的数据</p>
<div><pre><code><span>update</span> 表名 <span>set</span> 字段<span>=</span>新值<span>,</span>… <span>where</span> 条件
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>select</span> <span>*</span> <span>from</span> MyClass<span>;</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span> id <span>|</span> name <span>|</span> sex <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span>  <span>2</span> <span>|</span> Joan <span>|</span>   <span>1</span> <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>

mysql<span>></span> <span>update</span> MyClass <span>set</span> name<span>=</span><span>'Mary'</span> <span>where</span> id<span>=</span><span>2</span><span>;</span>
Query OK<span>,</span> <span>1</span> <span>row</span> affected <span>(</span><span>0.01</span> sec<span>)</span>
<span>Rows</span> <span>matched</span>: <span>1</span>  Changed: <span>1</span>  <span>Warnings</span>: <span>0</span>

mysql<span>></span> <span>select</span> <span>*</span> <span>from</span> MyClass<span>;</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span> id <span>|</span> name <span>|</span> sex <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>|</span>  <span>2</span> <span>|</span> Mary <span>|</span>   <span>1</span> <span>|</span>
<span>+</span><span>----+------+-----+</span>
<span>1</span> <span>row</span> <span>in</span> <span>set</span> <span>(</span><span>0.00</span> sec<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ul>
<li><code>UPDATE</code>语法可以用新值更新原有表行中的各列。</li>
<li><code>SET</code>子句指示要修改哪些列和要给予哪些值。</li>
<li><code>WHERE</code>子句指定应更新哪些行。如果没有<code>WHERE</code>子句，则更新所有的行。</li>
</ul>
</li>
<li>
<p>增加数据</p>
<ol>
<li>
<p>增加字段</p>
<div><pre><code><span>alter</span> <span>table</span> 表名 <span>add</span> 字段 类型 其他<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例如: 在表 MyClass 中添加了一个字段 age，类型为 int(4)，默认值为 0</p>
<div><pre><code>mysql<span>></span> <span>alter</span> <span>table</span> MyClass <span>add</span> age <span>int</span><span>(</span><span>4</span><span>)</span> <span>default</span> <span>'0'</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>修改原字段名称及类型:</p>
<div><pre><code><span>ALTER</span> <span>TABLE</span> table_name CHANGE old_field_name new_field_name field_type<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>删除字段:</p>
<div><pre><code>MySQL <span>ALTER</span> <span>TABLE</span> table_name <span>DROP</span> field_name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>加索引</p>
<div><pre><code><span>alter</span> <span>table</span> 表名 <span>add</span> <span>index</span> 索引名 <span>(</span>字段名<span>1</span><span>[</span>，字段名<span>2</span> …<span>]</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例子:</p>
<div><pre><code>mysql<span>></span> <span>alter</span> <span>table</span> employee <span>add</span> <span>index</span> emp_name <span>(</span>name<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>加主关键字的索引</p>
<div><pre><code><span>alter</span> <span>table</span> 表名 <span>add</span> <span>primary</span> <span>key</span> <span>(</span>字段名<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例子:</p>
<div><pre><code>mysql<span>></span> <span>alter</span> <span>table</span> employee <span>add</span> <span>primary</span> <span>key</span><span>(</span>id<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>加唯一限制条件的索引</p>
<div><pre><code><span>alter</span> <span>table</span> 表名 <span>add</span> <span>unique</span> 索引名 <span>(</span>字段名<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例子:</p>
<div><pre><code>mysql<span>></span> <span>alter</span> <span>table</span> employee <span>add</span> <span>unique</span> emp_name2<span>(</span>cardnumber<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p>删除某个索引</p>
<div><pre><code><span>alter</span> <span>table</span> 表名 <span>drop</span> <span>index</span> 索引名<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>例子:</p>
<div><pre><code>mysql<span>></span><span>alter</span> <span>table</span> employee <span>drop</span> <span>index</span> emp_name<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
</ol>
</li>
<li>
<p>修改表名</p>
<div><pre><code><span>rename</span> <span>table</span> 原表名 <span>to</span> 新表名<span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>
<p>当您执行 <code>RENAME</code> 时，您不能有任何锁定的表或活动的事务。您同样也必须有对原初表的 <code>ALTER</code> 和 <code>DROP</code> 权限，以及对新表的 <code>CREATE</code> 和 <code>INSERT</code> 权限。</p>
</li>
<li>
<p>如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。</p>
</li>
<li>
<p><code>RENAME TABLE</code> 在 <code>MySQL 3.23.23</code> 中被加入。</p>
</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 教程</title>
      <link>https://shimonzhan.com/code/language/js/</link>
      <guid>https://shimonzhan.com/code/language/js/</guid>
      <source url="https://shimonzhan.com/rss.xml">JavaScript 教程</source>
      <description>
部分内容参考/来自廖雪峰、阮一峰书籍与博客

</description>
      <category>JavaScript</category>
      <pubDate>Thu, 12 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>部分内容参考/来自廖雪峰、阮一峰书籍与博客</p>
</blockquote>

<h2 id="javascript-是什么" tabindex="-1"> JavaScript 是什么</h2>
<ul>
<li><a href="/code/language/js/intro/">导论</a></li>
</ul>
<div><p>有趣的历史</p>
<p>1995 年网景公司正凭借其 Navigator 浏览器成为 Web 时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态 HTML 页面上添加一些动态效果，于是叫 Brendan Eich 这哥们在两周之内设计出了 JavaScript 语言。您没看错，这哥们只用了 10 天时间 (这也是为什么至今也有人也在吐槽 JavaScript 垃圾的原因)。</p>
<p>为什么起名叫 JavaScript? 原因是当时 Java 语言非常红火，所以网景公司就来碰瓷了，实际上两者没任何关系。</p>
<ul>
<li><a href="/code/language/js/intro/history.html">更多历史介绍</a></li>
</ul>
</div>
<h2 id="入门教程" tabindex="-1"> 入门教程</h2>
<ul>
<li><a href="/code/language/js/guide/">快速上手</a></li>
</ul>
<h2 id="更多教程" tabindex="-1"> 更多教程</h2>
<ul>
<li>
<p><a href="/code/language/js/types/">数据类型</a></p>
</li>
<li>
<p><a href="/code/language/js/operators/">运算符</a></p>
</li>
<li>
<p><a href="/code/language/js/function/">函数</a></p>
</li>
<li>
<p><a href="/code/language/js/object/">对象</a></p>
</li>
<li>
<p><a href="/code/language/js/browser/">浏览器</a></p>
</li>
</ul>
<h2 id="进阶" tabindex="-1"> 进阶</h2>
<ul>
<li>
<p><a href="/code/language/js/es6/">ES6 教程</a></p>
</li>
<li>
<p><a href="/code/website/jQuery/">JQuery</a></p>
</li>
<li>
<p><a href="/code/language/js/error.html">错误处理</a></p>
</li>
<li>
<p><a href="/code/node-js/">node.js</a></p>
</li>
</ul>
<h2 id="在线教程" tabindex="-1"> 在线教程</h2>
<ul>
<li>
<p><a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener noreferrer">JavaScript 在线教程</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">JavaScript MDN 教程</a></p>
</li>
</ul>
<h2 id="许可协议" tabindex="-1"> 许可协议</h2>
<p>此部分博客采用 <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank" rel="noopener noreferrer">知识共享 署名-相同方式共享 3.0 协议</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>错误处理</title>
      <link>https://shimonzhan.com/code/language/js/error.html</link>
      <guid>https://shimonzhan.com/code/language/js/error.html</guid>
      <source url="https://shimonzhan.com/rss.xml">错误处理</source>
      <category>JavaScript</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="错误处理" tabindex="-1"> 错误处理</h1>
<p>在执行 JavaScript 代码的时候，有些情况下会发生错误。</p>
<p>错误分两种，一种是程序写的逻辑不对，导致代码执行异常。例如:</p>
<div><pre><code><span>let</span> s <span>=</span> <span>null</span><span>;</span>
<span>let</span> len <span>=</span> s<span>.</span>length<span>;</span> <span>// TypeError: null 变量没有 length 属性</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>对于这种错误，要修复程序。</p>
<p>一种是执行过程中，程序可能遇到无法预测的异常情况而报错，例如，网络连接中断，读取不存在的文件，没有操作权限等。</p>
<p>对于这种错误，我们需要处理它，并可能需要给用户反馈。</p>
<p>错误处理是程序设计时必须要考虑的问题。对于 C 这样贴近系统底层的语言，错误是通过错误码返回的:</p>
<div><pre><code>int fd <span>=</span> <span>open</span><span>(</span><span>"/path/to/file"</span><span>,</span> <span>O_RDONLY</span><span>)</span><span>;</span>
<span>if</span> <span>(</span>fd <span>==</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
    <span>printf</span><span>(</span><span>"Error when open file!"</span><span>)</span><span>;</span>
<span>}</span> <span>else</span> <span>{</span>
    <span>// TODO</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>通过错误码返回错误，就需要约定什么是正确的返回值，什么是错误的返回值。上面的 <code>open()</code> 函数约定返回 <code>-1</code> 表示错误。</p>
<p>显然，这种用错误码表示错误在编写程序时十分不便。</p>
<p>因此，高级语言通常都提供了更抽象的错误处理逻辑 <code>try ... catch ... finally</code>，JavaScript 也不例外。</p>
<h2 id="try-catch-finally" tabindex="-1"> <code>try ... catch ... finally</code></h2>
<p>使用 <code>try ... catch ... finally</code> 处理错误时，我们编写的代码如下:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>let</span> r1<span>,</span>
  r2<span>,</span>
  s <span>=</span> <span>null</span><span>;</span>
<span>try</span> <span>{</span>
  r1 <span>=</span> s<span>.</span>length<span>;</span> <span>// 此处应产生错误</span>
  r2 <span>=</span> <span>100</span><span>;</span> <span>// 该语句不会执行</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"出错了: "</span> <span>+</span> e<span>)</span><span>;</span>
<span>}</span> <span>finally</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"finally"</span><span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>"r1 = "</span> <span>+</span> r1<span>)</span><span>;</span> <span>// r1应为undefined</span>
console<span>.</span><span>log</span><span>(</span><span>"r2 = "</span> <span>+</span> r2<span>)</span><span>;</span> <span>// r2应为undefined</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行后可以发现，输出提示类似出错了: <code>TypeError: Cannot read property 'length' of null”</code>。</p>
<p>我们来分析一下使用 <code>try ... catch ... finally</code> 的执行流程。</p>
<p>当代码块被 <code>try { ... }</code> 包裹的时候，就表示这部分代码执行过程中可能会发生错误，一旦发生错误，就不再继续执行后续代码，转而跳到 <code>catch</code> 块。<code>catch (e) { ... }</code> 包裹的代码就是错误处理代码，变量 <code>e</code> 表示捕获到的错误。最后，无论有没有错误，<code>finally</code> 一定会被执行。</p>
<p>所以，有错误发生时，执行流程像这样:</p>
<ol>
<li>先执行 <code>try { ... }</code> 的代码；</li>
<li>执行到出错的语句时，后续语句不再继续执行，转而执行 <code>catch (e) { ... }</code> 代码；</li>
<li>最后执行 <code>finally { ... }</code> 代码。</li>
</ol>
<p>而没有错误发生时，执行流程像这样:</p>
<ol>
<li>先执行 <code>try { ... }</code> 的代码；</li>
<li>因为没有出错，<code>catch (e) { ... }</code> 代码不会被执行；</li>
<li>最后执行 <code>finally { ... }</code> 代码。</li>
</ol>
<p>最后请注意，<code>catch</code> 和 <code>finally</code> 可以不必都出现。也就是说，<code>try</code> 语句一共有三种形式:</p>
<p>完整的 <code>try ... catch ... finally</code>:</p>
<div><pre><code><span>try</span> <span>{</span>
    <span>...</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    <span>...</span>
<span>}</span> <span>finally</span> <span>{</span>
    <span>...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>只有 <code>try ... catch</code>，没有 <code>finally</code>:</p>
<div><pre><code><span>try</span> <span>{</span>
    <span>...</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    <span>...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>只有 <code>try ... finally</code>，没有 <code>catch</code>:</p>
<div><pre><code><span>try</span> <span>{</span>
    <span>...</span>
<span>}</span> <span>finally</span> <span>{</span>
    <span>...</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="错误类型" tabindex="-1"> 错误类型</h2>
<p>JavaScript 有一个标准的 Error 对象表示错误，还有从 Error 派生的 <code>TypeError</code>、<code>ReferenceError</code> 等错误对象。我们在处理错误时，可以通过 <code>catch(e)</code> 捕获的变量 <code>e</code> 访问错误对象:</p>
<div><pre><code><span>try</span> <span>{</span>
    <span>...</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>e <span>instanceof</span> <span>TypeError</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span><span>'Type error!'</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>e <span>instanceof</span> <span>Error</span><span>)</span> <span>{</span>
        <span>alert</span><span>(</span>e<span>.</span>message<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>alert</span><span>(</span><span>'Error: '</span> <span>+</span> e<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>使用变量 <code>e</code> 是一个习惯用法，也可以以其他变量名命名，如 <code>catch(ex)</code>。</p>
<h2 id="抛出错误" tabindex="-1"> 抛出错误</h2>
<p>程序也可以主动抛出一个错误，让执行流程直接跳转到 <code>catch</code> 块。抛出错误使用 <code>throw</code> 语句。</p>
<p>例如，下面的代码让用户输入一个数字，程序接收到的实际上是一个字符串，然后用 <code>parseInt()</code> 转换为整数。当用户输入不合法的时候，我们就抛出错误:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>let</span> r<span>,</span> n<span>,</span> s<span>;</span>
<span>try</span> <span>{</span>
  s <span>=</span> <span>prompt</span><span>(</span><span>"请输入一个数字"</span><span>)</span><span>;</span>
  n <span>=</span> <span>parseInt</span><span>(</span>s<span>)</span><span>;</span>
  <span>if</span> <span>(</span>Number<span>.</span><span>isNaN</span><span>(</span>n<span>)</span><span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>"输入错误"</span><span>)</span><span>;</span>
  <span>}</span>
  <span>// 计算平方:</span>
  r <span>=</span> n <span>*</span> n<span>;</span>
  console<span>.</span><span>log</span><span>(</span>n <span>+</span> <span>" * "</span> <span>+</span> n <span>+</span> <span>" = "</span> <span>+</span> r<span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"出错了: "</span> <span>+</span> e<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>实际上，JavaScript 允许抛出任意对象，包括数字、字符串。但是，最好还是抛出一个 <code>Error</code> 对象。</p>
<p>最后，当我们用 <code>catch</code> 捕获错误时，一定要编写错误处理语句:</p>
<div><pre><code><span>let</span> n <span>=</span> <span>0</span><span>,</span>
  s<span>;</span>
<span>try</span> <span>{</span>
  n <span>=</span> s<span>.</span>length<span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>n<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>哪怕仅仅把错误打印出来，也不要什么也不干:</p>
<div><pre><code><span>let</span> n <span>=</span> <span>0</span><span>,</span>
  s<span>;</span>
<span>try</span> <span>{</span>
  n <span>=</span> s<span>.</span>length<span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span><span>}</span>
console<span>.</span><span>log</span><span>(</span>n<span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>因为 <code>catch</code> 到错误却什么都不执行，就不知道程序执行过程中到底有没有发生错误。</p>
<p>处理错误时，请不要简单粗暴地用 <code>alert()</code> 把错误显示给用户。教程的代码使用 <code>alert()</code> 是为了便于演示。</p>
<h2 id="错误传播" tabindex="-1"> 错误传播</h2>
<p>如果代码发生了错误，又没有被 <code>try ... catch</code> 捕获，那么，程序执行流程会跳转到哪呢?</p>
<div><pre><code><span>function</span> <span>getLength</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  <span>return</span> s<span>.</span>length<span>;</span>
<span>}</span>

<span>function</span> <span>printLength</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>getLength</span><span>(</span><span>"abc"</span><span>)</span><span>)</span><span>;</span> <span>// 3</span>
  console<span>.</span><span>log</span><span>(</span><span>getLength</span><span>(</span><span>null</span><span>)</span><span>)</span><span>;</span> <span>// Error!</span>
<span>}</span>

<span>printLength</span><span>(</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果在一个函数内部发生了错误，它自身没有捕获，错误就会被抛到外层调用函数，如果外层函数也没有捕获，该错误会一直沿着函数调用链向上抛出，直到被 JavaScript 引擎捕获，代码终止执行。</p>
<p>所以，我们不必在每一个函数内部捕获错误，只需要在合适的地方来个统一捕获，一网打尽:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>function</span> <span>main</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"BEGIN main()"</span><span>)</span><span>;</span>
  <span>try</span> <span>{</span>
    <span>foo</span><span>(</span>s<span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"出错了: "</span> <span>+</span> e<span>)</span><span>;</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span><span>"END main()"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>foo</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"BEGIN foo()"</span><span>)</span><span>;</span>
  <span>bar</span><span>(</span>s<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>"END foo()"</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>bar</span><span>(</span><span>s</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"BEGIN bar()"</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>"length = "</span> <span>+</span> s<span>.</span>length<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>"END bar()"</span><span>)</span><span>;</span>
<span>}</span>

<span>main</span><span>(</span><span>null</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>当 <code>bar()</code> 函数传入参数 <code>null</code> 时，代码会报错，错误会向上抛给调用方 <code>foo()</code> 函数，<code>foo()</code> 函数没有 <code>try ... catch</code> 语句，所以错误继续向上抛给调用方 <code>main()</code> 函数，<code>main()</code> 函数有 <code>try ... catch</code> 语句，所以错误最终在 <code>main()</code> 函数被处理了。</p>
<p>至于在哪些地方捕获错误比较合适，需要视情况而定。</p>
<h2 id="异步错误处理" tabindex="-1"> 异步错误处理</h2>
<p>编写 JavaScript 代码时，我们要时刻牢记，JavaScript 引擎是一个事件驱动的执行引擎，代码总是以单线程执行，而回调函数的执行需要等到下一个满足条件的事件出现后，才会被执行。</p>
<p>例如，<code>setTimeout()</code> 函数可以传入回调函数，并在指定若干毫秒后执行:</p>
<div><pre><code><span>function</span> <span>printTime</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"It is time!"</span><span>)</span><span>;</span>
<span>}</span>

<span>setTimeout</span><span>(</span>printTime<span>,</span> <span>1000</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>"done"</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的代码会先打印 <code>done</code>，1 秒后才会打印 <code>It is time!</code>。</p>
<p>如果 <code>printTime()</code> 函数内部发生了错误，我们试图用 <code>try</code> 包裹 <code>setTimeout()</code> 是无效的:</p>
<div><pre><code><span>"use strict"</span><span>;</span>

<span>function</span> <span>printTime</span><span>(</span><span>)</span> <span>{</span>
  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>try</span> <span>{</span>
  <span>setTimeout</span><span>(</span>printTime<span>,</span> <span>1000</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>"done"</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>"error"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>原因就在于调用 <code>setTimeout()</code> 函数时，传入的 <code>printTime</code> 函数并未立刻执行! 紧接着，JavaScript 引擎会继续执行 <code>console.log('done');</code> 语句，而此时并没有错误发生。直到 1 秒钟后，执行 <code>printTime</code> 函数时才发生错误，但此时除了在 <code>printTime</code> 函数内部捕获错误外，外层代码并无法捕获。</p>
<p>所以，涉及到异步代码，无法在调用时捕获，原因就是在捕获的当时，回调函数并未执行。</p>
<p>类似的，当我们处理一个事件时，在绑定事件的代码处，无法捕获事件处理函数的错误。</p>
]]></content:encoded>
    </item>
    <item>
      <title>JSON 教程</title>
      <link>https://shimonzhan.com/code/language/json/</link>
      <guid>https://shimonzhan.com/code/language/json/</guid>
      <source url="https://shimonzhan.com/rss.xml">JSON 教程</source>
      <description>JSON: JavaScript Object Notation(JavaScript 对象表示法)


JSON 是存储和交换文本信息的语法。类似 XML。


JSON 比 XML 更小、更快，更易解析。


JSON 是轻量级的文本数据交换格式


JSON 独立于语言: JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。目前非常多的动态(PHP，JSP，.NET)编程语言都支持 JSON。


JSON 具有自我描述性，更易理解


</description>
      <category>JSON</category>
      <pubDate>Sat, 25 Jul 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>JSON: JavaScript Object Notation(JavaScript 对象表示法)</p>
<ul>
<li>
<p>JSON 是存储和交换文本信息的语法。类似 XML。</p>
</li>
<li>
<p>JSON 比 XML 更小、更快，更易解析。</p>
</li>
<li>
<p>JSON 是轻量级的文本数据交换格式</p>
</li>
<li>
<p>JSON 独立于语言: JSON 使用 JavaScript 语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。目前非常多的动态(PHP，JSP，.NET)编程语言都支持 JSON。</p>
</li>
<li>
<p>JSON 具有自我描述性，更易理解</p>
</li>
</ul>

<h2 id="json-值" tabindex="-1"> JSON 值</h2>
<p>JSON 值可以是:</p>
<ul>
<li>数字(整数或浮点数)</li>
<li>字符串(在双引号中)</li>
<li>逻辑值(<code>true</code> 或 <code>false</code>)</li>
<li>数组(在中括号中)</li>
<li>对象(在大括号中)</li>
<li>null</li>
</ul>
<h2 id="json-数字" tabindex="-1"> JSON 数字</h2>
<p>JSON 数字可以是整型或者浮点型:</p>
<p><strong>例:</strong></p>
<ul>
<li><code>5201314</code></li>
<li><code>-1</code></li>
<li><code>3.141592654</code></li>
</ul>
<h2 id="json-布尔值" tabindex="-1"> JSON 布尔值</h2>
<p>JSON 布尔值可以是 <code>true</code> 或者 <code>false</code></p>
<h2 id="json-字符串" tabindex="-1"> JSON 字符串</h2>
<p>JSON 字符串需要用双括号 <code>&quot;</code> 包含，如果内部含有英文引号 <code>&quot;</code>，需要使用 <code>\</code> 转义。</p>
<p><strong>例:</strong></p>
<ul>
<li><code>&quot;Shimon Zhan is handsome&quot;</code></li>
<li><code>&quot;春眠不觉晓，处处闻啼鸟&quot;</code></li>
<li><code>&quot;A saying goes: \&quot;Great hopes make great man.\&quot;&quot;</code></li>
</ul>
<h2 id="json-对象" tabindex="-1"> JSON 对象</h2>
<p>JSON 对象在大括号 <code>{}</code> 中书写以 <code>键: 值</code> 对的方式书写，不同键值对之间用 <code>,</code> 分隔。</p>
<p><strong>例:</strong></p>
<div><pre><code><span>{</span>
  <span>"tag"</span><span>:</span> <span>"text"</span><span>,</span>
  <span>"heading"</span><span>:</span> <span>"校园卡说明"</span><span>,</span>
  <span>"text"</span><span>:</span> <span>"校园卡是东师的金融消费卡"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="json-数组" tabindex="-1"> JSON 数组</h2>
<p>JSON 数组在中括号 <code>[]</code> 中书写，不同元素间用 <code>,</code> 隔开。</p>
<h2 id="json-null" tabindex="-1"> JSON null</h2>
<p>JSON 可以设置 <code>null</code> 值</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown</title>
      <link>https://shimonzhan.com/code/language/markdown/</link>
      <guid>https://shimonzhan.com/code/language/markdown/</guid>
      <source url="https://shimonzhan.com/rss.xml">Markdown</source>
      <description>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。
Markdown 的目标是实现「易读易写」。
Markdown 的主要目的是用来作为一种网络内容的写作用语言。
</description>
      <category>Markdown</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。</p>
<p>Markdown 的主要目的是用来作为一种网络内容的<strong>写作用语言</strong>。</p>

<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li><a href="/code/language/markdown/intro.html">简介</a></li>
<li><a href="/code/language/markdown/block.html">块元素</a></li>
<li><a href="/code/language/markdown/inline.html">行内元素</a></li>
<li><a href="/code/language/markdown/extend.html">扩展与其他内容</a></li>
</ul>
<h2 id="markdown-效果演示" tabindex="-1"> Markdown 效果演示</h2>
<ul>
<li><a href="/code/language/markdown/demo.html">查看详情</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 块元素</title>
      <link>https://shimonzhan.com/code/language/markdown/block.html</link>
      <guid>https://shimonzhan.com/code/language/markdown/block.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Markdown 块元素</source>
      <category>Markdown</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="段落和换行" tabindex="-1"> 段落和换行</h2>
<p>一个段落由一个及以上相连接的行句组成。</p>
<p>一个即以上的空行则会切分出不同的段落，一般的段落不需要用空白或断行缩进。</p>
<div><p>空行</p>
<p>空行的定义是显示上看起来像是空行，便会被视为空行。</p>
<p>也就是若某一行只包含空白和 tab，则该行也会被视为空行。</p>
</div>
<p>「一个及以上相连接的行句组成」这句话其实暗示了 Markdown 允许段落内的强迫断行，其它的格式会把每个断行都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果您<strong>真的想要</strong>插入 <code>&lt;br /&gt;</code> 标签的话，在行尾加上两个以上的空白，然后按下回车:</p>
<div><pre><code>这是一句话，它可以在这里  
强制换行
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="标题" tabindex="-1"> 标题</h2>
<p>标题能显示出文章的结构。</p>
<p>Atx (<strong>推荐</strong>)形式是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如:</p>
<ul>
<li>H1: <code># Header 1</code></li>
<li>H2: <code>## Header 2</code></li>
<li>H3: <code>### Header 3</code></li>
<li>H4: <code>#### Header 4</code></li>
<li>H5: <code>##### Header 5</code></li>
<li>H6: <code>###### Header 6</code></li>
</ul>
<div><p>最佳实践</p>
<p>为了使内容可读性更强，Markdown 最佳实践要求标题应使用 Atx 写法，并且每个标题应被空行隔开。 (第一行的大标题不需要向上空行)</p>
</div>
<p>Setext<sup></sup> 格式不推荐使用。</p>
<h2 id="blockquotes" tabindex="-1"> Blockquotes</h2>
<p>Markdown 使用 email 形式的块引言。</p>
<p>如果您很熟悉如何在 email 信件中引言，您就知道如何在 Markdown 文件中建立一个块引言:在每行的最前面加上 <code>&gt;</code> 接一个空格:</p>
<div><pre><code><span>></span> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
<span>></span> consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
<span>></span> Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
<span>></span>
<span>></span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
<span>></span> id sem consectetuer libero luctus adipiscing.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>渲染结果</summary>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
</details>
<div><p>易写性</p>
<p>处于易写性的考虑，Markdown 允许您只在整个段落的第一行最前面加上 <code>&gt;</code> :</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>></span> This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
  consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
  Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

<span>></span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
  id sem consectetuer libero luctus adipiscing.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>

<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>

</details>
<p>但是请注意，我们<strong>不推荐</strong>使用这种做法，这并不是符合 Markdown 最佳实践。</p>
<p>同时，<code>&gt;</code> 后面的空格也是可选的，我们也推荐您加上它。</p>
</div>
<details><summary>块引言可以有阶层 (例如: 引言内的引言) ，只要根据层数加上不同数量的 ></summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>></span> This is the first level of quoting.
<span>></span>
<span>> ></span> This is nested blockquote.
<span>></span>
<span>></span> Back to the first level.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
</details>
<details><summary>引言的块内也可以使用其他的 Markdown 语法，包括标题、列表、代码块等</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>></span> <span>1.</span> This is the first list item.
<span>></span> <span>1.</span> This is the second list item.
<span>></span>
<span>></span> Here’s some example code:
<span>></span> 
<span>></span> ```js
<span>></span> const a = 1;
<span>></span> ```
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<blockquote>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here’s some example code:</p>
<div><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div></blockquote>
</details>
<h2 id="列表" tabindex="-1"> 列表</h2>
<p>Markdown 支持有序列表和无序列表。</p>
<h3 id="无序列表" tabindex="-1"> 无序列表</h3>
<p>无序列表在规范中使用减号作为列表标记:</p>
<div><pre><code><span>-</span> Red
<span>-</span> Green
<span>-</span> Blue
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><details><summary>渲染结果</summary>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
</details>
<div><p>其他支持的符号</p>
<p>Markdown 最初的规范也支持使用星号、加号:</p>
<div><pre><code><span>+</span> Red
<span>+</span> Green
<span>+</span> Blue

<span>*</span> Red
<span>*</span> Green
<span>*</span> Blue
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们<strong>极其不建议</strong>使用以上写法，它们并不符合 Markdown 最佳实践。(加号看上去并不像一个列表，而且星号并不是可以直接按键输入的符号)</p>
</div>
<h3 id="有序列表" tabindex="-1"> 有序列表</h3>
<p>有序列表使用数字接著一个英文句点:</p>
<div><pre><code><span>1.</span> Bird
<span>2.</span> McHale
<span>3.</span> Parish
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><details><summary>渲染结果</summary>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</details>
<p>很重要的一点是，您在列表标记上使用的数字并不会影响输出的 HTML 结果，因为上面的列表所产生的 HTML 标记为:</p>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Bird<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>McHale<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Parish<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>这意味着您无需刻意对列表进行标号</summary>
<p>如果您使用:</p>
<div><pre><code><span>1.</span> Bird
<span>1.</span> McHale
<span>1.</span> Parish
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>列表项也会正确的渲染:</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</details>
<div><p>将标号交给 Markdown</p>
<p>人工为列表进行正确的标号与全部使用 <code>1.</code> 都符合 Markdown 最佳实践。</p>
<p>但是请不要错误的进行标号，如:</p>
<div><pre><code><span>2.</span> Bird
<span>3.</span> McHale
<span>5.</span> Parish
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>为了更加便捷的添加、删除或排序有序列表项，我们<strong>推荐都设置为标号 <code>1</code></strong>。</p>
</div>
<h3 id="列表格式的转义" tabindex="-1"> 列表格式的转义</h3>
<p>有些时候项目列表很可能会不小心被产生，比如:</p>
<div><pre><code>XXX finally died in
<span>1986.</span> What a great man.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，您可以在句点前面加上反斜线。</p>
<div><pre><code>XXX finally died in
1986\. What a great man.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="缩进与段落" tabindex="-1"> 缩进与段落</h3>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多三个空白，项目标记后面则一定要接著至少一个空白或 tab。</p>
<p>要让列表看起来更漂亮，您可以把内容用固定的缩进整理好:</p>
<div><pre><code><span>-</span> Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
  Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
  viverra nec, fringilla in, laoreet vitae, risus.
<span>-</span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>渲染结果</summary>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
</details>
<div><p>易写性</p>
<p>处于易写性的考虑，列表缩进不是强制的，也就是以下的内容渲染结果与上面相同。</p>
<div><pre><code><span>-</span> Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
<span>-</span> Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>渲染结果</summary>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
</details>
<p>但是我们<strong>不推荐</strong>这种写法，这种写法会导致 Markdown 源文件可读性变差，不符合 Markdown 最佳实践。</p>
</div>
<p>如果列表项目间用空行分开， Markdown 会把项目的内容在输出时用 <code>&lt;p&gt;</code> 标签包起来，举例来说:</p>
<details><summary>普通的无序列表</summary>
<p>输入:</p>
<div><pre><code><span>-</span> Bird
<span>-</span> Magic
<span>-</span> Wood
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>转换结果:</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Bird<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Magic<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>Wood<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>渲染:</p>
<ul>
<li>Bird</li>
<li>Magic</li>
<li>Wood</li>
</ul>
</details>
<p>但是这个:</p>
<div><pre><code><span>-</span> Bird

<span>-</span> Magic

<span>-</span> Wood
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>会被转换为:</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>Bird<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>Magic<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span><span><span><span>&lt;</span>p</span><span>></span></span>Wood<span><span><span>&lt;/</span>p</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><details><summary>渲染结果</summary>
<ul>
<li>
<p>Bird</p>
</li>
<li>
<p>Magic</p>
</li>
<li>
<p>Wood</p>
</li>
</ul>
</details>
<p>这会在列表项之间创建更大的空间。</p>
<div><p>最佳实践</p>
<p>对于一个列表项来说，只要有一项使用了空行，所有项目都会转换为段落，也就是以下格式也会渲染为段落列表。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>-</span> Bird
<span>-</span> Magic

<span>-</span> Wood
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<ul>
<li>
<p>Bird</p>
</li>
<li>
<p>Magic</p>
</li>
<li>
<p>Wood</p>
</li>
</ul>
</details>
<p>Markdown 最佳实践要求您在每一个列表间始终(或始终不)添加空行。</p>
</div>
<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 2 - 4 个空白或是一个 tab。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>-</span> This is a list item with two paragraphs.

  This is the second paragraph in the list item. You’re
  only required to indent the first line. Lorem ipsum dolor
  sit amet, consectetuer adipiscing elit.

<span>-</span> Another item in the same list.

<span>1.</span> This is a list item with two paragraphs. Lorem ipsum dolor
   sit amet, consectetuer adipiscing elit. Aliquam hendrerit
   mi posuere lectus.

   Vestibulum enim wisi, viverra nec, fringilla in, laoreet
   vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
   sit amet velit.

<span>2.</span> Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<ul>
<li>
<p>This is a list item with two paragraphs.</p>
<p>This is the second paragraph in the list item. You’re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.</p>
</li>
<li>
<p>Another item in the same list.</p>
</li>
</ul>
<ol>
<li>
<p>This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.</p>
</li>
<li>
<p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>
</li>
</ol>
</details>
<p>如果要在列表项目内放入其他内容，也需要缩进。</p>
<p>比如放进引言，那 <code>&gt;</code> 就需要缩进:</p>
<div><pre><code><span>-</span> A list item with a blockquote:

  > This is a blockquote
  > inside a list item.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><div><p>Markdown 最佳实践</p>
<p>为了更高的可读性，段落缩进应当等同于列表第一行，也就是无序列表缩进 2 个空格，有序列表根据缩进三或四个空格。</p>
</div>
<h2 id="代码块" tabindex="-1"> 代码块</h2>
<p>和代码相关的写作或是标签语言原始码通常会有已经排版好的代码块，通常这些块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码块包起来。</p>
<p>Markdown 最初标准只规定了一种缩进格式的代码块<sup></sup>。</p>
<p>由于缩进式的代码块格式不够鲜明，且无法在此模式下设置代码块的语言并对代码块进行高亮，围栏式的代码扩展几乎被所有 Markdown 实现所支持。</p>
<p>Markdown 最佳实践也同样推荐使用围栏式的代码块，尽管它并不在最初的标准中。</p>
<p>您可以很简单的使用 <code>```代码名称</code> 与 <code>```</code> 创建围栏式代码块。比如:</p>
<div><pre><code><span><span>```</span><span>js</span>
<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>
<span>```</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>会渲染为</p>
<div><pre><code><span>const</span> a <span>=</span> <span>1</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>在代码块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让您非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制粘贴，再加上缩进就可以了，剩下的 Markdown 都会帮您处理。</p>
<details><summary>Markdown 处理例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span>```</span><span>html</span>
<span><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>footer<span>"</span></span><span>></span></span>
  <span title="&copy;">&amp;copy;</span> 2004 Foo Corporation
<span><span><span>&lt;/</span>div</span><span>></span></span></span>
<span>```</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>转换结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>pre</span><span>></span></span>
  <span><span><span>&lt;</span>code</span><span>></span></span><span title="&lt;">&amp;lt;</span>div<span title="&gt;">&amp;gt;</span>
  <span title="&amp;">&amp;amp;</span>copy; 2004 Foo Corporation
<span title="&lt;">&amp;lt;</span>/div<span title="&gt;">&amp;gt;</span><span><span><span>&lt;/</span>code</span><span>></span></span>
<span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>footer<span>"</span></span><span>></span></span>
  <span title="&copy;">&amp;copy;</span> 2004 Foo Corporation
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></details>
<p>代码块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示您可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="转义与嵌套" tabindex="-1"> 转义与嵌套</h3>
<p>如果您希望在一个代码块中放置另一个 Markdown 代码块格式，您可以增加 <code>`</code> 的数量来进行嵌套</p>
<div><pre><code><span><span>```</span><span>`md</span>
<span>```js
const a = 1;</span>
<span>```</span></span>
````
</code></pre><div><div>&nbsp;</div><br><br><br><div>&nbsp;</div></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>会渲染为</p>
<div><pre><code><span><span>```</span><span>js</span>
<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>
<span>```</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>如果您希望输入 <code>```</code>，您可以使用 <code>\</code> 转义:</p>
<p><code>\`\`\`</code> 会被渲染为: ```</p>
<h3 id="分隔线" tabindex="-1"> 分隔线</h3>
<p>您可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。您也可以在星号中间插入空白。下面每种写法都可以建立分隔线:</p>
<div><pre><code>---(建议)

<span>* * *</span>

<span>***</span>

<span>*****</span>

<span>- - -</span>

<span>---------------------------------------</span>
</code></pre><div><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div><br><div>&nbsp;</div></div><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><hr>
<section>
<ol>
<li id="footnote1"><p>Setext 格式</p>
<p>Setext 形式是用底线的形式，利用 <code>=</code> (最高阶标题) 和 <code>-</code> (第二阶标题) ，例如:</p>
<div><pre><code><span>This is an H1
<span>=============</span></span>

<span>This is an H2
<span>-------------</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>请注意我们<strong>极其不推荐</strong>使用该格式! 因为它不仅麻烦，还仅支持两级目录。 </p>
</li>
<li id="footnote2"><p>缩进格式的代码块</p>
<p>在 Markdown 中，可以通过简单地缩进 4 个空白或是 1 个 tab 来建立代码块。比如:</p>
<div><pre><code>This is a normal paragraph:

<span>    This is a code block.</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>Markdown 会转换成:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>This is a normal paragraph:<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>pre</span><span>></span></span>
  <span><span><span>&lt;</span>code</span><span>></span></span>This is a code block.<span><span><span>&lt;/</span>code</span><span>></span></span>
<span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的缩进 (4 个空白或是 1 个 tab) ，都会被移除，例如:</p>
<div><pre><code>Here is an example of AppleScript:

<span>    tell application "Foo"
    beep
    end tell</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>会被转换为:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Here is an example of AppleScript:<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>pre</span><span>></span></span><span><span><span>&lt;</span>code</span><span>></span></span>tell application "Foo"
beep
end tell
<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>一个代码块会一直持续到没有缩进的那一行 (或是文件结尾)。 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown示例</title>
      <link>https://shimonzhan.com/code/language/markdown/demo.html</link>
      <guid>https://shimonzhan.com/code/language/markdown/demo.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Markdown示例</source>
      <category>Markdown</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[
<h1 id="一级标题" tabindex="-1"> 一级标题</h1>

<div><pre><code><span><span>#</span> 一级标题</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="二级标题" tabindex="-1"> 二级标题</h2>
<div><pre><code><span><span>##</span> 二级标题</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="三级标题" tabindex="-1"> 三级标题</h3>
<div><pre><code><span><span>###</span> 三级标题</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h4 id="四级标题" tabindex="-1"> 四级标题</h4>
<div><pre><code><span><span>####</span> 四级标题</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h5 id="五级标题" tabindex="-1"> 五级标题</h5>
<div><pre><code><span><span>#####</span> 五级标题</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h6 id="六级标题" tabindex="-1"> 六级标题</h6>
<div><pre><code><span><span>######</span> 六级标题</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="text" tabindex="-1"> Text</h2>
<p>这句话里拥有<strong>加粗</strong>、<em>倾斜</em>和<s>删除</s></p>
<div><pre><code>这句话里拥有<span><span>**</span><span>加粗</span><span>**</span></span>、<span><span>*</span><span>倾斜</span><span>*</span></span>和<span><span>~~</span><span>删除</span><span>~~</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="段落" tabindex="-1"> 段落</h2>
<p>这是一个段落。</p>
<p>这是另一个段落。</p>
<div><pre><code>这是一个段落

这是另一个段落。
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="换行" tabindex="-1"> 换行</h2>
<p>这是一句话不过我要在这里<br>
换行</p>
<div><pre><code>这是一句话不过我要在这里  
换行
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>提示</p>
<p>上方的代码中 <code>这里</code> 后面有两个空格</p>
</div>
<h2 id="引用" tabindex="-1"> 引用</h2>
<blockquote>
<p>引用也可以连用</p>
<blockquote>
<p>可以添加额外的大于号制造更深的引用</p>
</blockquote>
</blockquote>
<div><pre><code><span>></span> 引用也可以连用
<span>></span>
<span>> ></span> 可以添加额外的大于号制造更深的引用
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="列表" tabindex="-1"> 列表</h2>
<h3 id="无序列表" tabindex="-1"> 无序列表</h3>
<ul>
<li>
<p>无序列表项</p>
</li>
<li>
<p>无序列表项</p>
<ul>
<li>
<p>列表中的列表项</p>
<ul>
<li>更多的列表项</li>
<li>更多的列表项</li>
<li>更多的列表项</li>
</ul>
</li>
<li>
<p>列表中的长列表项，这个列表项很长。</p>
<p>而且由很多个段落构成。</p>
<p>甚至最后一个段落还包含了。</p>
</li>
</ul>
</li>
<li>
<p>无序列表项</p>
</li>
</ul>
<div><pre><code><span>-</span> 无序列表项
<span>-</span> 无序列表项

  <span>-</span> 列表中的列表项
    <span>-</span> 更多的列表项
    <span>-</span> 更多的列表项
    <span>-</span> 更多的列表项
  <span>-</span> 列表中的长列表项，这个列表项很长。

<span>    而且由很多个段落构成。</span>

<span>    甚至最后一个段落还包含了[链接](#链接)。</span>

<span>-</span> 无序列表项
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="有序列表" tabindex="-1"> 有序列表</h3>
<ol>
<li>有序列表第一项</li>
<li>有序列表第二项<br>
第二项的需要换行<br>
再次换行</li>
<li>有序列表第三项</li>
</ol>
<div><pre><code><span>1.</span> 有序列表第一项
<span>1.</span> 有序列表第二项  
   第二项的需要换行  
   再次换行
<span>1.</span> 有序列表第三项
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><p>提示</p>
<p>上方的代码中<code>换行</code>后面有也两个空格</p>
</div>
<h2 id="分割线" tabindex="-1"> 分割线</h2>
<hr>
<div><pre><code><span>---</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="链接" tabindex="-1"> 链接</h2>
<p><a href="/">根目录访问主页</a></p>
<p><a href="/code/">相对路径主页</a></p>
<div><pre><code><span>[<span>根目录访问主页</span>](<span>/</span>)</span>

<span>[<span>相对路径主页</span>](<span>../../README.md</span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><div><p>提示</p>
<p>VuePress 还兼容如下跳转到主页的写法:</p>
<ul>
<li>
<p><a href="/code/language/">相对路径访问，兼容 Markdown 编写时相互跳转</a></p>
</li>
<li>
<p><a href="/">根目录访问主页 2</a></p>
</li>
<li>
<p><a href="/code/language/index.html">HTML 形式</a></p>
</li>
</ul>
<p>如果希望在使用编辑器编辑 Markdown 时也能够进行相互跳转的话，则需要全部使用<strong>相对路径</strong>，并且<code>README.md</code><strong>不能省略</strong>。</p>
<p>代码:</p>
<div><pre><code><span>[<span>根目录访问主页 2</span>](<span>/README.md</span>)</span>

<span>[<span>相对路径访问，兼容 markdown 编写时相互跳转</span>](<span>../README.md</span>)</span>

<span>[<span>HTML 形式</span>](<span>../index.html</span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div></div>
<h2 id="图片" tabindex="-1"> 图片</h2>
<p><img src="/logo.svg" alt="Logo" loading="lazy"></p>
<div><pre><code><span><span>!</span>[<span>Logo</span>](<span>/logo.svg</span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="emoji" tabindex="-1"> Emoji</h2>
<p>经典方式:</p>
<p>😉 😢 😆 😋</p>
<div><pre><code>:wink: :cry: :laughing: :yum:
</code></pre><div aria-hidden="true"><div></div></div></div><p>简写:</p>
<p>😎 😃 :* 😦 😃 😦 😉</p>
<div><pre><code>8-) :) :\* :( :-) :-( ;)
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>更多详见 <a href="/code/language/markdown/emoji/">Emoji 列表</a></p>
</div>
<h2 id="表格" tabindex="-1"> 表格</h2>
<table>
<thead>
<tr>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:left">左对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">居中使用<code>:-:</code></td>
<td style="text-align:right">右对齐使用<code>-:</code></td>
<td style="text-align:left">左对齐使用<code>:-</code></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:right">aaaaaaaaa</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:right">aaaa</td>
<td style="text-align:left">a</td>
</tr>
</tbody>
</table>
<div><pre><code><span><span><span>|</span><span>     居中      </span><span>|</span><span>         右对齐 </span><span>|</span><span> 左对齐         </span><span>|</span>
</span><span><span>|</span> <span>:-----------:</span> <span>|</span> <span>-------------:</span> <span>|</span> <span>:-------------</span> <span>|</span>
</span><span><span>|</span><span> 居中使用<span>`:-:`</span> </span><span>|</span><span> 右对齐使用<span>`-:`</span> </span><span>|</span><span> 左对齐使用<span>`:-`</span> </span><span>|</span>
<span>|</span><span>       b       </span><span>|</span><span>      aaaaaaaaa </span><span>|</span><span> aaaa           </span><span>|</span>
<span>|</span><span>       c       </span><span>|</span><span>           aaaa </span><span>|</span><span> a              </span><span>|</span>
</span></span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="代码" tabindex="-1"> 代码</h2>
<p>行内代码效果: <code>code</code></p>
<div><pre><code>行内代码效果: <span>`code`</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>缩进代码:</p>
<div><pre><code>// Some comments
line 1 of code
line 2 of code
line 3 of code
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>实际代码:</p>
<div><pre><code>    // Some comments
    line 1 of code
    line 2 of code
    line 3 of code
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>块级代码</p>
<div><pre><code>Sample text here...
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code>块级代码

<span><span>```</span>
<span>Sample text here...</span>
<span>```</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>高亮格式:</p>
<div><pre><code><span>var</span> <span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>bar</span><span>)</span> <span>{</span>
  <span>return</span> bar<span>++</span><span>;</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>foo</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code>高亮格式:

<span><span>```</span><span>js</span>
<span><span>var</span> <span>foo</span> <span>=</span> <span>function</span> <span>(</span><span>bar</span><span>)</span> <span>{</span>
  <span>return</span> bar<span>++</span><span>;</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>foo</span><span>(</span><span>5</span><span>)</span><span>)</span><span>;</span></span>
<span>```</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
      <enclosure url="https://shimonzhan.com/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>Markdown 扩展</title>
      <link>https://shimonzhan.com/code/language/markdown/extend.html</link>
      <guid>https://shimonzhan.com/code/language/markdown/extend.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Markdown 扩展</source>
      <category>Markdown</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="其他特性" tabindex="-1"> 其他特性</h2>
<h3 id="自动链接" tabindex="-1"> 自动链接</h3>
<p>Markdown 支持比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接，链接的文字就和链接位置一样，例如:</p>
<div><pre><code>&lt;http://example.com/>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Markdown 会转为:</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://example.com/<span>"</span></span><span>></span></span>http://example.com/<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>自动的邮件链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以混淆一些不好的信箱地址收集机器人，例如:</p>
<div><pre><code><span><span><span>&lt;</span>address@example.com</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Markdown 会转成:</p>
<div><pre><code><span><span><span>&lt;</span>a</span>
  <span>href</span><span><span>=</span><span>"</span><span title="&#x6D;">&amp;#x6D;</span><span title="&#x61;">&amp;#x61;</span>i<span title="&#x6C;">&amp;#x6C;</span><span title="&#x74;">&amp;#x74;</span><span title="&#x6F;">&amp;#x6F;</span>:<span title="&#x61;">&amp;#x61;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x72;">&amp;#x72;</span><span title="&#x65;">&amp;#x65;</span><span title="&#115;">&amp;#115;</span><span title="&#115;">&amp;#115;</span><span title="&#64;">&amp;#64;</span><span title="&#101;">&amp;#101;</span><span title="&#120;">&amp;#120;</span><span title="&#x61;">&amp;#x61;</span><span title="&#109;">&amp;#109;</span><span title="&#x70;">&amp;#x70;</span><span title="&#x6C;">&amp;#x6C;</span>e<span title="&#x2E;">&amp;#x2E;</span><span title="&#99;">&amp;#99;</span><span title="&#111;">&amp;#111;</span><span title="&#109;">&amp;#109;</span><span>"</span></span>
  <span>></span></span><span title="&#x61;">&amp;#x61;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x64;">&amp;#x64;</span><span title="&#x72;">&amp;#x72;</span><span title="&#x65;">&amp;#x65;</span><span title="&#115;">&amp;#115;</span><span title="&#115;">&amp;#115;</span><span title="&#64;">&amp;#64;</span><span title="&#101;">&amp;#101;</span><span title="&#120;">&amp;#120;</span><span title="&#x61;">&amp;#x61;</span><span title="&#109;">&amp;#109;</span><span title="&#x70;">&amp;#x70;</span><span title="&#x6C;">&amp;#x6C;</span>e<span title="&#x2E;">&amp;#x2E;</span><span title="&#99;">&amp;#99;</span><span title="&#111;">&amp;#111;</span><span title="&#109;">&amp;#109;</span><span><span><span>&lt;/</span>a</span>
<span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>在浏览器里面，这段字串会变成一个可以点击的「address@example.com」链接。</p>
<p>(这种作法虽然可以混淆不少的机器人，但并无法全部挡下来，不过这样也比什么都不做好些。无论如何，公开您的信箱终究会引来广告信件的。)</p>
<h3 id="转义字符" tabindex="-1"> 转义字符</h3>
<p>Markdown 可以利用反斜线来插入一些在语法中有其它意义的符号，例如: 如果您想要用星号加在文字旁边的方式来做出强调效果 (但不用 <code>&lt;em&gt;</code> 标签) ，您可以在星号的前面加上反斜线:</p>
<div><pre><code>\*literal asterisks\*
</code></pre><div aria-hidden="true"><div></div></div></div><p>Markdown 支持在下面这些符号前面加上反斜线来帮助插入普通的符号:</p>
<ul>
<li><code>\</code> 反斜线</li>
<li><code>`</code> 反引号</li>
<li><code>*</code> 星号</li>
<li><code>_</code> 底线</li>
<li><code>{}</code> 大括号</li>
<li><code>[]</code> 方括号</li>
<li><code>()</code> 括号</li>
<li><code>#</code> 井字号</li>
<li><code>+</code> 加号</li>
<li><code>-</code> 减号</li>
<li><code>.</code> 英文句点</li>
<li><code>!</code> 惊叹号</li>
</ul>
<h2 id="大部分编辑器通用快捷键" tabindex="-1"> 大部分编辑器通用快捷键</h2>
<table>
<thead>
<tr>
<th>输出后的效果</th>
<th>Markdown</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bold</strong></td>
<td><code>**text**</code></td>
<td>Ctrl/⌘ + B</td>
</tr>
<tr>
<td><em>Emphasize</em></td>
<td><code>*text*</code></td>
<td>Ctrl/⌘ + I</td>
</tr>
<tr>
<td><code>Inline Code</code></td>
<td>`code`</td>
<td>选中后 <code>`</code></td>
</tr>
</tbody>
</table>
<h2 id="常见扩展" tabindex="-1"> 常见扩展</h2>
<p>有几种轻量级标记语言是 Markdown 的超集。它们包含 Gruber 的基本语法，并通过添加其他元素 (例如表，代码块，语法突出显示，URL 自动链接和脚注) 在此基础上构建。许多最受欢迎的 Markdown 应用程序使用以下轻量级标记语言之一:</p>
<ul>
<li><a href="https://commonmark.org/" target="_blank" rel="noopener noreferrer">CommonMark</a></li>
<li><a href="https://github.github.com/gfm/" target="_blank" rel="noopener noreferrer">GitHub Flavored Markdown (GFM)</a></li>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" target="_blank" rel="noopener noreferrer">Markdown Extra</a></li>
<li><a href="https://fletcherpenney.net/multimarkdown/" target="_blank" rel="noopener noreferrer">MultiMarkdown</a></li>
<li><a href="https://rmarkdown.rstudio.com/" target="_blank" rel="noopener noreferrer">R Markdown</a></li>
</ul>
<h3 id="表格" tabindex="-1"> 表格</h3>
<p>表格是 GFM 标准支持的格式。</p>
<p>您需要创建表头，并使用 <code>---</code> 来分割表头和表身。</p>
<p>您需要使用 <code>|</code> 来分割每一个表格项目，如果您需要输入 <code>|</code> 请使用 <code>\</code> 转义它。</p>
<p>您可以在表头分割行处使用 <code>:</code> 来自定义该列的对其</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span><span>|</span><span>     居中      </span><span>|</span><span>                   右对齐 </span><span>|</span><span> 左对齐         </span><span>|</span>
</span><span><span>|</span> <span>:-----------:</span> <span>|</span> <span>-----------------------:</span> <span>|</span> <span>:-------------</span> <span>|</span>
</span><span><span>|</span><span> 居中使用<span>`:-:`</span> </span><span>|</span><span>           右对齐使用<span>`-:`</span> </span><span>|</span><span> 左对齐使用<span>`:-`</span> </span><span>|</span>
<span>|</span><span>       b       </span><span>|</span><span> 表格中包含的 \| 需要转义 </span><span>|</span><span> aaaa           </span><span>|</span>
<span>|</span><span>       c       </span><span>|</span><span>                     aaaa </span><span>|</span><span> a              </span><span>|</span>
</span></span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:left">左对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">居中使用<code>:-:</code></td>
<td style="text-align:right">右对齐使用<code>-:</code></td>
<td style="text-align:left">左对齐使用<code>:-</code></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:right">表格中包含的 | 需要转义</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:right">aaaa</td>
<td style="text-align:left">a</td>
</tr>
</tbody>
</table>
</details>
<h3 id="emoji" tabindex="-1"> Emoji</h3>
<p>Emoji 是 GFM 标准支持的格式，需要通过 <code>:emoji名称:</code> 来使用 emoji。</p>
<p>例子: <code>:smile:</code> 😄</p>
<p>您可以在 <a href="/code/language/markdown/emoji/">Emoji 列表</a> 找到所有可用的 Emoji。</p>
<h3 id="删除线" tabindex="-1"> 删除线</h3>
<p>您可以使用 <code>~~delete~~</code> 来创建类似 <s>delete</s> 的删除线</p>
<h3 id="脚注" tabindex="-1"> 脚注</h3>
<p>在 Markdown 中使用 <code>[^锚点文字]</code> 来定义脚注。</p>
<p>在之后的任何位置使用 <code>[^锚点文字]: ...</code> 来描述脚注内容。</p>
<p>如果脚注包含多个段落，其后的段落应当保持双层缩进。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>脚注 1 链接[^first].

脚注 2 链接[^second].

行内的脚注^[Text of inline footnote] 定义.

重复的页脚引用[^second].

<span><span>[</span><span>^first</span><span>]</span><span>:</span> 脚注</span> <span><span>**</span><span>可以包含特殊标记</span><span>**</span></span>

<span>    也可以由多个段落组成</span>

<span><span>[</span><span>^second</span><span>]</span><span>:</span> 脚注文字。</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<p>脚注 1 链接<sup></sup>.</p>
<p>脚注 2 链接<sup></sup>.</p>
<p>行内的脚注<sup></sup> 定义.</p>
<p>重复的页脚引用<sup></sup>.</p>
</details>
<h3 id="自定义标题" tabindex="-1"> 自定义标题</h3>
<p>许多 Markdown 处理器支持标题的自定义 ID。</p>
<p>添加自定义 ID 允许您直接链接到标题并使用 CSS 对其进行修改。要添加自定义标题 ID，请在与标题相同的行上用大括号括起该自定义 ID。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span>###</span> My Great Heading {#custom-id}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>h3</span> <span>id</span><span><span>=</span><span>"</span>custom-id<span>"</span></span><span>></span></span>My Great Heading<span><span><span>&lt;/</span>h3</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div></details>
<h3 id="定义列表" tabindex="-1"> 定义列表</h3>
<p>一些 Markdown 处理器允许您创建术语及其对应定义的定义列表。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>First Term
: This is the definition of the first term.

Second Term
: This is one definition of the second term.
: This is another definition of the second term.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>dl</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>First Term<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>This is the definition of the first term.<span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>Second Term<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>This is one definition of the second term.<span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>This is another definition of the second term.<span><span><span>&lt;/</span>dd</span><span>></span></span>
<span><span><span>&lt;/</span>dl</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>

<dl>
  <dt>First Term</dt>
  <dd>This is the definition of the first term.</dd>
  <dt>Second Term</dt>
  <dd>This is one definition of the second term.</dd>
  <dd>This is another definition of the second term.</dd>
</dl>
</details>
<h3 id="任务列表" tabindex="-1"> 任务列表</h3>
<p>任务列表使您可以创建带有复选框的项目列表。</p>
<p>要创建任务列表，请创建一个列表，并以方括号 <code>[ ]</code> 开头。通过添加空格 <code>x</code> 来改变复选框的勾选情况。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>-</span> [x] Write the press release
<span>-</span> [ ] Update the website
<span>-</span> [ ] Contact the media
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<ul>
  <li><input type="checkbox" checked disabled />Write the press release</li>
  <li><input type="checkbox" disabled />Update the website</li>
  <li><input type="checkbox" disabled />Contact the media</li>
</ul>
</details>
<hr>
<section>
<ol>
<li id="footnote1"><p>脚注 <strong>可以包含特殊标记</strong></p>
<p>也可以由多个段落组成 </p>
</li>
<li id="footnote2"><p>脚注文字。  </p>
</li>
<li id="footnote3"><p>Text of inline footnote </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 行内元素</title>
      <link>https://shimonzhan.com/code/language/markdown/inline.html</link>
      <guid>https://shimonzhan.com/code/language/markdown/inline.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Markdown 行内元素</source>
      <category>Markdown</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="链接" tabindex="-1"> 链接</h2>
<p>Markdown 支持两种形式的链接语法: <em>行内</em>和<em>参考</em>。</p>
<p>不管是哪一种，链接的文字都是用 <code>[方括号]</code> 来标记。</p>
<h3 id="行内链接" tabindex="-1"> 行内链接</h3>
<p>要建立一个行内形式的链接，只要在方块括号后输入圆括号并插入网址链接即可，如果您还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>This is <span>[<span>an example</span>](<span>http://example.com/</span> <span>"Title"</span>)</span> inline link.

<span>[<span>This link</span>](<span>http://example.net/</span>)</span> has no title attribute.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  This is <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://example.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>Title<span>"</span></span><span>></span></span> an example<span><span><span>&lt;/</span>a</span><span>></span></span> inline
  link.
<span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://example.net/<span>"</span></span><span>></span></span>This link<span><span><span>&lt;/</span>a</span><span>></span></span> has no title attribute.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener noreferrer">an example</a> inline link.</p>
<p><a href="http://example.net/" target="_blank" rel="noopener noreferrer">This link</a> has no title attribute.</p>
</details>
<p>如果您是要链接到同样主机的资源，您可以使用绝对路径或相对路径:</p>
<div><pre><code>See my <span>[<span>About</span>](<span>/about.html</span>)</span> page for details.
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="参考链接" tabindex="-1"> 参考链接</h3>
<p>参考形式的链接使用另外一个方括号接在链接文字的括号后面，而在第二个方括号里面要填入标识链接的标签:</p>
<div><pre><code>This is <span>[<span>an example</span>][<span>id</span>]</span> reference-style link.
</code></pre><div aria-hidden="true"><div></div></div></div><p>之后在文件的任意地方，您都可以把这个标签的链接内容定义出来:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>链接定义的形式为:</p>
<ul>
<li>方括号，输入链接的标识 ID</li>
<li>冒号</li>
<li>一个以上的空白或 tab</li>
<li>链接的网址</li>
<li>选择性地添加 title 内容，可以用单引号、双引号或是括号包括</li>
</ul>
<p>下面这三种链接的定义相同:</p>
<div><pre><code><span><span>[</span><span>foo</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
<span><span>[</span><span>foo</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
<span><span>[</span><span>foo</span><span>]</span><span>:</span> http://example.com/ <span>"Optional Title Here"</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>链接网址也可以用方括号包起来:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> [http://example.com/] <span>"Optional Title Here"</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>您也可以把 title 属性放到下一行，也可以加一些缩进，网址太长的话，这样会比较好看:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> http://example.com/longish/path/to/resource/here</span>
    "Optional Title Here"
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨识标签可以有字母、数字、空白和标点符号，但是并<strong>不</strong>区分大小写，因此下面两个链接是一样的:</p>
<div><pre><code><span>[<span>link text</span>][<span>a</span>]</span>
<span>[<span>link text</span>][<span>A</span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><div><p>最佳实践</p>
<p>由于不区分大小写的原因，Markdown 最佳实践推荐标识标签均使用小写。</p>
</div>
<h4 id="简写" tabindex="-1"> 简写</h4>
<p>您可以通过简写写法省略指定链接标签，这种情形下，链接标签和链接文字会视为相同，要用预设链接标签只要在链接文字后面加上一个空的方括号，如果您要让 &quot;Google&quot; 链接到 google.com，您可以简化成:</p>
<div><pre><code>[Google][]
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后定义链接内容:</p>
<div><pre><code><span><span>[</span><span>google</span><span>]</span><span>:</span> http://google.com/</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>由于链接文字可能包含空白，所以这种简化的标签内也可以包含多个文字:</p>
<div><pre><code>Visit [Daring Fireball][] for more information.
</code></pre><div aria-hidden="true"><div></div></div></div><p>然后定义链接:</p>
<div><pre><code><span><span>[</span><span>daring fireball</span><span>]</span><span>:</span> http://daringfireball.net/</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>链接的定义可以放在文件中的任何一个地方，建议放在链接出现段落的后面或文件最后面，就像是注解一样。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>I get 10 times more traffic from <span>[<span>Google</span>][<span>1</span>]</span> than from
<span>[<span>Yahoo</span>][<span>2</span>]</span> or <span>[<span>MSN</span>][<span>3</span>]</span>.

<span><span>[</span><span>1</span><span>]</span><span>:</span> http://google.com/ <span>"Google"</span></span>
<span><span>[</span><span>2</span><span>]</span><span>:</span> http://search.yahoo.com/ <span>"Yahoo Search"</span></span>
<span><span>[</span><span>3</span><span>]</span><span>:</span> http://search.msn.com/ <span>"MSN Search"</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>等同于</strong>:</p>
<div><pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

<span><span>[</span><span>google</span><span>]</span><span>:</span> http://google.com/ <span>"Google"</span></span>
<span><span>[</span><span>yahoo</span><span>]</span><span>:</span> http://search.yahoo.com/ <span>"Yahoo Search"</span></span>
<span><span>[</span><span>msn</span><span>]</span><span>:</span> http://search.msn.com/ <span>"MSN Search"</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>
  I get 10 times more traffic from
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://google.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>Google<span>"</span></span><span>></span></span>Google<span><span><span>&lt;/</span>a</span><span>></span></span> than from
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://search.yahoo.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>Yahoo Search<span>"</span></span><span>></span></span>Yahoo<span><span><span>&lt;/</span>a</span><span>></span></span>
  or <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://search.msn.com/<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>MSN Search<span>"</span></span><span>></span></span>MSN<span><span><span>&lt;/</span>a</span><span>></span></span>.
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener noreferrer">Google</a> than from
<a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener noreferrer">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener noreferrer">MSN</a>.</p>
<p><strong>同样的行内模式写法</strong>:</p>
<div><pre><code>I get 10 times more traffic from <span>[<span>Google</span>](<span>http://google.com/</span> <span>"Google"</span>)</span>
than from <span>[<span>Yahoo</span>](<span>http://search.yahoo.com/</span> <span>"Yahoo Search"</span>)</span> or
<span>[<span>MSN</span>](<span>http://search.msn.com/</span> <span>"MSN Search"</span>)</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></details>
<div><p>优势</p>
<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的链接却会增加到 176 个字符，如果是用纯 HTML 格式来写，会有 234 个字符，在 HTML 格式中，标签比文字还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让您可以把一些标记相关的资讯移到段落文字之外，您就可以增加链接而不让文章的阅读感觉被打断。</p>
</div>
<h2 id="强调" tabindex="-1"> 强调</h2>
<p>Markdown 使用星号 (<code>*</code>) 和底线 (<code>_</code>) 作为标记强调字词的符号。</p>
<p>被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span><span>**</span><span>double asterisks</span><span>**</span></span> (建议)

<span><span>_</span><span>single underscores</span><span>_</span></span> (建议)

<span><span>__</span><span>double underscores</span><span>__</span></span>

<span><span>*</span><span>single asterisks</span><span>*</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>strong</span><span>></span></span>double asterisks<span><span><span>&lt;/</span>strong</span><span>></span></span>

<span><span><span>&lt;</span>em</span><span>></span></span>single underscores<span><span><span>&lt;/</span>em</span><span>></span></span>

<span><span><span>&lt;</span>strong</span><span>></span></span>double underscores<span><span><span>&lt;/</span>strong</span><span>></span></span>

<span><span><span>&lt;</span>em</span><span>></span></span>single asterisks<span><span><span>&lt;/</span>em</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></details>
<p>但是如果您的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>These two <span><span>_</span><span>, </span><span>_</span></span> and <span><span>*</span><span>, </span><span>*</span></span> will be treated as normal characters.
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>输出</strong>:</p>
<p>These two _, _ and *, * will be treated as normal characters.</p>
</details>
<div><p>最佳实践</p>
<p>为了将两者进行区分，Markdown 最佳实践要求在所有地方尽可能使用 <code>**</code> 和 <code>_</code>。但是这里有一个例外:</p>
<p>由于使用代码或者是其他情况，人们很容易创造出带有下划线的单词 (如 <code>last_updated_time</code>)，在这种情况下，updated 就不会识别为斜体。只有在这种情况下，使用 <code>*</code> 而不是 <code>_</code>。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>A varibale like last_updated_time won’t be <span><span>_</span><span>transformed</span><span>_</span></span> like last<span><span>*</span><span>updated</span><span>*</span></span>time.
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>输出</strong>:</p>
<p>A varibale like last_updated_time won’t be <em>transformed</em> like last<em>updated</em>time.</p>
</details>
</div>
<p>强调也可以直接插在文字中间:</p>
<div><pre><code>un<span><span>*</span><span>frigging</span><span>*</span></span>believable
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="转义" tabindex="-1"> 转义</h3>
<details><summary>如果要在文字前后直接插入普通的星号或底线，您可以用 \</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>\*this text is surrounded by literal asterisks\*

\_this text is surrounded by literal underscores\_
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<p>*this text is surrounded by literal asterisks*</p>
<p>_this text is surrounded by literal underscores_</p>
</details>
<h2 id="代码" tabindex="-1"> 代码</h2>
<p>如果要标记一小段行内代码，您可以用反引号 (<code>`</code>) 把它包起来。</p>
<div><p>反引号</p>
<p>反引号在键盘的左上角，ESC 键的下方</p>
</div>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>Use the <span>`printf()`</span> function.
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Use the <span><span><span>&lt;</span>code</span><span>></span></span>printf()<span><span><span>&lt;/</span>code</span><span>></span></span> function.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>输出</strong>:</p>
<p>Use the <code>printf()</code> function.</p>
</details>
<h3 id="转义-1" tabindex="-1"> 转义</h3>
<p>如果要在代码内插入反引号，您可以用多个反引号来开启和结束行内代码</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code><span>`` There is a literal backtick (`) here. ``</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>code</span><span>></span></span>There is a literal backtick (`) here.<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>输出</strong>:</p>
<p><code>There is a literal backtick (`) here.</code></p>
</details>
<p>代码码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样您就可以在区段的一开始就插入反引号。</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>A single backtick in a code span: <span>`` ` ``</span>

A backtick-delimited string in a code span: <span>`` `foo` ``</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>A single backtick in a code span: <span><span><span>&lt;</span>code</span><span>></span></span>`<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>

<span><span><span>&lt;</span>p</span><span>></span></span>A backtick-delimited string in a code span: <span><span><span>&lt;</span>code</span><span>></span></span>`foo`<span><span><span>&lt;/</span>code</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>输出</strong>:</p>
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
</details>
<p>在代码码区段内，<code>&amp;</code> 和方括号都会被转成 HTML 实体，这样会比较容易插入 HTML 原始码.</p>
<details><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div><pre><code>Please don’t use any <span>`&lt;blink>`</span> tags.
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>渲染结果</strong>:</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>Please don’t use any <span><span><span>&lt;</span>code</span><span>></span></span><span title="&lt;">&amp;lt;</span>blink<span title="&gt;">&amp;gt;</span><span><span><span>&lt;/</span>code</span><span>></span></span> tags.<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>输出</strong>:</p>
<p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p>
</details>
<h2 id="图片" tabindex="-1"> 图片</h2>
<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式: <em>行内</em> 和 <em>参考</em>。</p>
<ul>
<li>
<p>行内图片的语法如下:</p>
<div><pre><code><span><span>!</span>[<span>Alt text</span>](<span>/path/to/img.jpg</span>)</span>

<span><span>!</span>[<span>Alt text</span>](<span>/path/to/img.jpg</span> <span>"Optional title"</span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>详细叙述如下:</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>一个方括号，里面放上图片的替代文字</li>
<li>一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 title 文字。</li>
</ul>
</li>
<li>
<p>参考式的图片语法如下:</p>
<div><pre><code><span><span>!</span>[<span>Alt text</span>][<span>id</span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>id</code> 是图片参考的名称，图片参考的定义方式则和链接参考一样:</p>
<div><pre><code><span><span>[</span><span>id</span><span>]</span><span>:</span> url/to/image <span>"Optional title attribute"</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div></li>
</ul>
<p>它们的优劣与链接相同。</p>
<div><p>提示</p>
<p>Markdown 无法指定图片的宽高，如果您需要的话，您可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
</div>
]]></content:encoded>
      <enclosure url="https://shimonzhan.com/path/to/img.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Markdown 介绍</title>
      <link>https://shimonzhan.com/code/language/markdown/intro.html</link>
      <guid>https://shimonzhan.com/code/language/markdown/intro.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Markdown 介绍</source>
      <description>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。
Markdown 的目标是实现「易读易写」。它的扩展名为 .md。
</description>
      <category>Markdown</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。它的扩展名为 <code>.md</code>。</p>

<h2 id="设计理念" tabindex="-1"> 设计理念</h2>
<p>Markdown 最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文字发布，并且看起来不会像是由许多标签或是格式指令所构成。</p>
<p>其语法在设计时受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener noreferrer">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener noreferrer">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener noreferrer">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener noreferrer">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener noreferrer">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener noreferrer">EtText</a>，然而最大灵感来源其实是纯文字的电子邮件格式。因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。假如您有使用过电子邮件，引言写法看起来就真的像是引用一段文字。</p>
<p>Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能 (如表格、脚注、内嵌 HTML 等等) ，这些功能并不在最初的设计中，但它们能让 Markdown 转换成更多的格式，例如 LaTeX，Docbook。Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、 Maruku 等。这些衍生版本要么基于工具，如 Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
<h2 id="用途" tabindex="-1"> 用途</h2>
<p>Markdown 的语法有个主要的目的: 用来作为一种网络内容的<strong>写作用语言</strong>。Markdown 的重点在于，它能让文件<strong>更容易阅读、编写</strong>。因此，Markdown 的格式语法只涵盖纯文字可以涵盖的范围。</p>
<p>Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台 WordPress 能很好的支持 Markdown。</p>
<p>用于编写说明文档，并且以 “README.md” 的文件名保存在软件的目录下面。</p>
<p>除此之外，我们还可以快速将 Markdown 转化为演讲 PPT、Word 产品文档、LaTex 论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown 已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p>
<h2 id="特点" tabindex="-1"> 特点</h2>
<h3 id="行内-html" tabindex="-1"> 行内 HTML</h3>
<p>不在 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>只有块元素 ── 比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以利与内容区隔。而且这些 (元素) 的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 的解析器有智慧型判断，可以避免在块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>举例来说，在 Markdown 文件里加上一段 HTML 表格:</p>
<div><pre><code>This is a regular paragraph.

<span><span><span>&lt;</span>table</span><span>></span></span>
    <span><span><span>&lt;</span>tr</span><span>></span></span>
        <span><span><span>&lt;</span>td</span><span>></span></span>Foo<span><span><span>&lt;/</span>td</span><span>></span></span>
    <span><span><span>&lt;/</span>tr</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>

This is another regular paragraph.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><p>注意</p>
<p>Markdown 语法在 HTML 块标签中将不会被进行处理。</p>
<p>例如，您无法在 HTML 块内使用 Markdown 形式的 <code>*强调*</code>。</p>
</div>
<h3 id="特殊字符自动转换" tabindex="-1"> 特殊字符自动转换</h3>
<p>简单来说，在 Markdown 中，您无需考虑 HTML 本应考虑的特殊字符转义的问题。</p>
<p>比如对于 <code>AT&amp;T</code>，Markdown 就会将它转为 <code>AT&amp;amp;T</code>。</p>
<div><p>HTML 中的特殊字符</p>
<p>在 HTML 文件中，有两个字符需要特殊处理: <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果您只是想要使用这些符号，您必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p>使用 HTML 时，<code>&amp;</code> 符号其实很容易让写作网络文件的人感到困扰。</p>
<p>如果您要打 「AT&amp;T」 ，您必须要写成 <code>「AT&amp;amp;T」</code>。</p>
<p>同时您还得转换网址内的 <code>&amp;</code> 符号，如果您要链接到 <code>http://images.google.com/images?num=30&amp;q=larry+bird</code>，您必须要把网址转成 <code>http://images.google.com/images?num=30&amp;amp;q=larry+bird</code>，才能放到链接标签的 <code>href</code> 属性里。</p>
<p>不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p>
</div>
<p>Markdown 即允许您直接使用这些符号。也允许您使用转义符号。</p>
<p>比如您如果要在文件中插入一个著作权的符号，但是您又不想费力地输入这个不常见的特殊符号，您可以直接在 Markdown 中输入 <code>&amp;copy;</code>，Markdown 会推测出它是转移符号，并把它输出为 ©。</p>
<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持  ，如果您是使用 <code>&lt;</code> 符号作为 HTML 标签使用，那 Markdown 也不会对它做任何转换，但是如果您是写:</p>
<div><pre><code>4 &lt; 5
</code></pre><div aria-hidden="true"><div></div></div></div><p>Markdown 将会把它转换为:</p>
<div><pre><code>4 <span title="&lt;">&amp;lt;</span> 5
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>需要注意的是，code 范围内，不论是行内还是块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让您可以很容易地用 Markdown 写 HTML code (和 HTML 相对而言， HTML 语法中，您要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。)</p>
</div>
<h2 id="编写" tabindex="-1"> 编写</h2>
<p>Markdown 就是一个扩展名为 <code>.md</code> 的文本文件。</p>
<p>理论上您可以使用任何编辑器 (如 <a href="/software/vscode/">VS Code</a>)编辑 Markdown，也可以使用专门的 Markdown 编辑器 (如 <a href="https://typora.io" target="_blank" rel="noopener noreferrer">Typora</a>) 进行编写。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Python 语言教程</title>
      <link>https://shimonzhan.com/code/language/python/</link>
      <guid>https://shimonzhan.com/code/language/python/</guid>
      <source url="https://shimonzhan.com/rss.xml">Python 语言教程</source>
      <description>
优点: Python 是一种高级语言，它可以用更少的代码量完成相同工作。
缺点: Python 是一种脚本语言，它的执行效率不是很高。

</description>
      <category>Python</category>
      <pubDate>Mon, 18 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>优点: Python 是一种高级语言，它可以用更少的代码量完成相同工作。</li>
<li>缺点: Python 是一种脚本语言，它的执行效率不是很高。</li>
</ul>

<div><p>注意</p>
<p>本教程基于 Python3, Python2 已经过时停止维护多年，请不要使用学习。</p>
</div>
<h2 id="python-简介" tabindex="-1"> Python 简介</h2>
<ul>
<li>
<p><a href="/code/language/python/intro/intro.html">Python 介绍</a></p>
</li>
<li>
<p><a href="/code/language/python/intro/install.html">Python 安装</a></p>
</li>
<li>
<p><a href="/code/language/python/intro/interpreter.html">Python 解释器</a></p>
</li>
</ul>
<h2 id="python-快速入门" tabindex="-1"> Python 快速入门</h2>
<ul>
<li>
<p><a href="/code/language/python/guide/write.html">第一个 Python 程序</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/io.html">输入与输出</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/basic.html">基础语法</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/string.html">字符串</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/list-and-tuple.html">List 和 Tuple</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/condition.html">条件判断</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/loop.html">循环</a></p>
</li>
<li>
<p><a href="/code/language/python/guide/dict-and-set.html">Dictionary 和 Set</a></p>
</li>
</ul>
<h2 id="python-函数" tabindex="-1"> Python 函数</h2>
<ul>
<li>
<p><a href="/code/language/python/function/intro.html">函数介绍</a></p>
</li>
<li>
<p><a href="/code/language/python/function/define.html">函数定义</a></p>
</li>
<li>
<p><a href="/code/language/python/function/call.html">函数调用</a></p>
</li>
<li>
<p><a href="/code/language/python/function/argument.html">函数参数</a></p>
</li>
<li>
<p><a href="/code/language/python/function/recursive.html">递归调用</a></p>
</li>
</ul>
<h2 id="python-高级语法" tabindex="-1"> Python 高级语法</h2>
<ul>
<li>
<p><a href="/code/language/python/advance/slice.html">切片</a></p>
</li>
<li>
<p><a href="/code/language/python/advance/iteration.html">迭代</a></p>
</li>
<li>
<p><a href="/code/language/python/advance/list-comprehensions.html">列表生成式</a></p>
</li>
<li>
<p><a href="/code/language/python/advance/generator.html">生成器</a></p>
</li>
<li>
<p><a href="/code/language/python/advance/iterator.html">迭代器</a></p>
</li>
</ul>
<h2 id="函数式编程" tabindex="-1"> 函数式编程</h2>
<ul>
<li>
<p><a href="/code/language/python/functional-programming/high-order-function/intro.html">高阶函数介绍</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/high-order-function/map-and-reduce.html">map / reduce</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/high-order-function/filter.html">filter</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/high-order-function/sorted.html">sorted</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/return-function.html">返回函数</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/anonymous-function.html">匿名函数</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/decorator.html">装饰器</a></p>
</li>
<li>
<p><a href="/code/language/python/functional-programming/parital-function.html">偏函数</a></p>
</li>
</ul>
<h2 id="相关工具" tabindex="-1"> 相关工具</h2>
<ul>
<li><a href="https://c.runoob.com/compile/9" target="_blank" rel="noopener noreferrer">Python 在线运行器</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>TypeScript 教程</title>
      <link>https://shimonzhan.com/code/language/typescript/</link>
      <guid>https://shimonzhan.com/code/language/typescript/</guid>
      <source url="https://shimonzhan.com/rss.xml">TypeScript 教程</source>
      <description>TypeScript 是一种由微软开发的自由和开源的编程语言，它是 JavaScript 的一个超集，扩展了 JavaScript 的语法。
</description>
      <category>TypeScript</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>TypeScript 是一种由微软开发的自由和开源的编程语言，它是 JavaScript 的一个超集，扩展了 JavaScript 的语法。</p>

<h2 id="语法特性" tabindex="-1"> 语法特性</h2>
<ul>
<li>类 Classes</li>
<li>接口 Interfaces</li>
<li>模块 Modules</li>
<li>类型注解 Type annotations</li>
<li>编译时类型检查 Compile time type checking</li>
<li>Arrow 函数 (类似 C# 的 Lambda 表达式)</li>
</ul>
<blockquote>
<p>更多内容可以参考: 下方目录。</p>
</blockquote>
<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/code/language/typescript/intro/">简介</a></p>
<ul>
<li><a href="/code/language/typescript/intro/what-is-typescript.html">什么是 TypeScript</a></li>
<li><a href="/code/language/typescript/intro/get-typescript.html">安装 TypeScript</a></li>
<li><a href="/code/language/typescript/intro/hello-typescript.html">Hello TypeScript</a></li>
</ul>
</li>
<li>
<p><a href="/code/language/typescript/basics/">基础</a></p>
<ul>
<li><a href="/code/language/typescript/basics/primitive-data-types.html">原始数据类型</a></li>
<li><a href="/code/language/typescript/basics/any.html">任意值</a></li>
<li><a href="/code/language/typescript/basics/type-inference.html">类型推论</a></li>
<li><a href="/code/language/typescript/basics/union-types.html">联合类型</a></li>
<li><a href="/code/language/typescript/basics/type-of-object-interfaces.html">对象的类型——接口</a></li>
<li><a href="/code/language/typescript/basics/type-of-array.html">数组的类型</a></li>
<li><a href="/code/language/typescript/basics/type-of-function.html">函数的类型</a></li>
<li><a href="/code/language/typescript/basics/type-assertion.html">类型断言</a></li>
<li><a href="/code/language/typescript/basics/declaration-files.html">声明文件</a></li>
<li><a href="/code/language/typescript/basics/built-in-objects.html">内置对象</a></li>
</ul>
</li>
<li>
<p><a href="/code/language/typescript/advanced/">进阶</a></p>
<ul>
<li><a href="/code/language/typescript/advanced/type-aliases.html">类型别名</a></li>
<li><a href="/code/language/typescript/advanced/string-literal-types.html">字符串字面量类型</a></li>
<li><a href="/code/language/typescript/advanced/tuple.html">元组</a></li>
<li><a href="/code/language/typescript/advanced/enum.html">枚举</a></li>
<li><a href="/code/language/typescript/advanced/class.html">类</a></li>
<li><a href="/code/language/typescript/advanced/class-and-interfaces.html">类与接口</a></li>
<li><a href="/code/language/typescript/advanced/generics.html">泛型</a></li>
<li><a href="/code/language/typescript/advanced/declaration-merging.html">声明合并</a></li>
<li><a href="/code/language/typescript/advanced/further-reading.html">扩展阅读</a></li>
</ul>
</li>
<li>
<p><a href="/code/language/typescript/engineering/">工程</a></p>
<ul>
<li><a href="/code/language/typescript/engineering/lint.html">代码检查</a></li>
</ul>
</li>
</ul>
<h2 id="javascript-与-typescript-的区别" tabindex="-1"> JavaScript 与 TypeScript 的区别</h2>
<p>TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。</p>
<p>TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。</p>
<h2 id="typescript-官网文档" tabindex="-1"> TypeScript 官网文档</h2>
<ul>
<li><a href="http://www.typescriptlang.org/docs/home.html" target="_blank" rel="noopener noreferrer">点击查看官网</a></li>
<li><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener noreferrer">点击查看第三方中文文档</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>YAML 教程</title>
      <link>https://shimonzhan.com/code/language/yaml/</link>
      <guid>https://shimonzhan.com/code/language/yaml/</guid>
      <source url="https://shimonzhan.com/rss.xml">YAML 教程</source>
      <category>YAML</category>
      <pubDate>Sun, 26 Jul 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>编程免不了要写配置文件，怎么写配置也是一门学问。</p>
<p>YAML 是专门用来写配置文件的语言，非常简洁和强大。</p>
<h2 id="yaml-介绍" tabindex="-1"> yaml 介绍</h2>
<p>YAML 语言(发音 /ˈjæməl/ )的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p>
<p>YAML 的全称是 YAML Ain’t Markup Language。</p>
<p>它的基本语法规则如下。</p>
<ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时不允许使用 Tab 键，只允许使用空格。</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
</ul>
<p><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
<p>YAML 支持的数据结构有三种。</p>
<ul>
<li>对象: 键值对的集合，又称为映射(mapping)/ 哈希(hashes) / 字典(dictionary)</li>
<li>数组: 一组按次序排列的值，又称为序列(sequence) / 列表(list)</li>
<li>纯量(scalars): 单个的、不可再分的值</li>
</ul>
<h2 id="如何打开或编辑-yaml" tabindex="-1"> 如何打开或编辑 yaml</h2>
<p>推荐使用 VS Code，具体详见<a href="/software/vscode/simple.html">VS Code 简单介绍</a>。</p>
<h2 id="数据结构介绍" tabindex="-1"> 数据结构介绍</h2>
<h3 id="对象" tabindex="-1"> 对象</h3>
<p>对象的一组键值对，使用冒号结构表示。</p>
<div><pre><code><span>animal</span><span>:</span> pets
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>animal</span><span>:</span> <span>"pets"</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。</p>
<div><pre><code><span>hash</span><span>:</span> <span>{</span> <span>name</span><span>:</span> Steve<span>,</span> <span>foo</span><span>:</span> bar <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span> <span>hash</span><span>:</span> <span>{</span> <span>name</span><span>:</span> <span>'Steve'</span><span>,</span> <span>foo</span><span>:</span> <span>'bar'</span> <span>}</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="数组" tabindex="-1"> 数组</h3>
<p>一组连词线开头的行，构成一个数组。</p>
<div><pre><code><span>-</span> Cat
<span>-</span> Dog
<span>-</span> Goldfish
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>[</span><span>"Cat"</span><span>,</span> <span>"Dog"</span><span>,</span> <span>"Goldfish"</span><span>]</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p>
<div><pre><code><span>-</span> <span>-</span> Cat
  <span>-</span> Dog
  <span>-</span> Goldfish
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>[</span><span>[</span><span>"Cat"</span><span>,</span> <span>"Dog"</span><span>,</span> <span>"Goldfish"</span><span>]</span><span>]</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>数组也可以采用行内表示法。</p>
<div><pre><code><span>animal</span><span>:</span> <span>[</span>Cat<span>,</span> Dog<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>animal</span><span>:</span> <span>[</span><span>"Cat"</span><span>,</span> <span>"Dog"</span><span>]</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h3 id="复合结构" tabindex="-1"> 复合结构</h3>
<p>对象和数组可以结合使用，形成复合结构。</p>
<div><pre><code><span>languages</span><span>:</span>
  <span>-</span> Ruby
  <span>-</span> Perl
  <span>-</span> Python

<span>websites</span><span>:</span>
  <span>YAML</span><span>:</span> yaml.org
  <span>Ruby</span><span>:</span> ruby<span>-</span>lang.org
  <span>Python</span><span>:</span> python.org
  <span>Perl</span><span>:</span> use.perl.org
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>languages</span><span>:</span> <span>[</span><span>"Ruby"</span><span>,</span> <span>"Perl"</span><span>,</span> <span>"Python"</span><span>]</span><span>,</span>
  <span>websites</span><span>:</span>
    <span>{</span>
      <span>YAML</span><span>:</span> <span>"yaml.org"</span><span>,</span>
      <span>Ruby</span><span>:</span> <span>"ruby-lang.org"</span><span>,</span>
      <span>Python</span><span>:</span> <span>"python.org"</span><span>,</span>
      <span>Perl</span><span>:</span> <span>"use.perl.org"</span><span>,</span>
    <span>}</span><span>,</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="纯量" tabindex="-1"> 纯量</h3>
<p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>数值直接以字面量的形式表示。</p>
<div><pre><code><span>number</span><span>:</span> <span>12.30</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>number</span><span>:</span> <span>12.3</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>布尔值用 <code>true</code> 和 <code>false</code> 表示。</p>
<div><pre><code><span>isSet</span><span>:</span> <span>true</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>isSet</span><span>:</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>null</code> 用 <code>~</code> 表示。</p>
<div><pre><code><span>parent</span><span>:</span> <span>~</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>parent</span><span>:</span> <span>null</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>时间采用 ISO8601 格式。</p>
<div><pre><code><span>iso8601</span><span>:</span> <span>2001-12-14t21:59:43.10-05:00</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>iso8601</span><span>:</span> <span>new</span> <span>Date</span><span>(</span><span>"2001-12-14t21:59:43.10-05:00"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>日期采用复合 iso8601 格式的年、月、日表示。</p>
<div><pre><code><span>date</span><span>:</span> <span>1976-07-31</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>date</span><span>:</span> <span>new</span> <span>Date</span><span>(</span><span>"1976-07-31"</span><span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>YAML 允许使用两个感叹号，强制转换数据类型。</p>
<div><pre><code><span>e</span><span>:</span> <span>!!str</span> <span>123</span>
<span>f</span><span>:</span> <span>!!str</span> <span>true</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span> <span>e</span><span>:</span> <span>'123'</span><span>,</span> <span>f</span><span>:</span> <span>'true'</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="字符串" tabindex="-1"> 字符串</h3>
<p>字符串是最常见，也是最复杂的一种数据类型。</p>
<p>字符串默认不使用引号表示。</p>
<div><pre><code><span>str</span><span>:</span> 这是一行字符串
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>str</span><span>:</span> <span>"这是一行字符串"</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>如果字符串之中包含空格或特殊字符，需要放在引号之中。</p>
<div><pre><code><span>str</span><span>:</span> <span>"内容: 字符串"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>str</span><span>:</span> <span>"内容: 字符串"</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>单引号和双引号都可以使用，双引号不会对特殊字符转义。</p>
<div><pre><code><span>s1</span><span>:</span> <span>'内容\n字符串'</span>
<span>s2</span><span>:</span> <span>"内容\n字符串"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span> <span>s1</span><span>:</span> <span>'内容\\n字符串'</span><span>,</span> <span>s2</span><span>:</span> <span>'内容\n字符串'</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>单引号之中如果还有单引号，必须连续使用两个单引号转义。</p>
<div><pre><code><span>str</span><span>:</span> <span>"labor's day"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>str</span><span>:</span> <span>"labor's day"</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。</p>
<div><pre><code><span>str</span><span>:</span> 这是一段
  多行
  字符串
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>转为 JavaScript 如下。</p>
<div><pre><code><span>{</span>
  <span>str</span><span>:</span> <span>"这是一段 多行 字符串"</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>多行字符串可以使用 <code>|</code> 保留换行符，也可以使用 <code>&gt;</code> 折叠换行。</p>
<div><pre><code><span>this</span><span>:</span> <span>|</span><span>
  Foo
  Bar</span>
<span>that</span><span>:</span> <span>></span><span>
  Foo
  Bar</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>转为 JavaScript 代码如下。</p>
<div><pre><code><span>{</span> <span>this</span><span>:</span> <span>'Foo\nBar\n'</span><span>,</span> <span>that</span><span>:</span> <span>'Foo Bar\n'</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>+</code> 表示保留文字块末尾的换行，<code>-</code> 表示删除字符串末尾的换行。</p>
<div><pre><code><span>s1</span><span>:</span> <span>|</span><span>
  Foo</span>

<span>s2</span><span>:</span> <span>|</span>+
  Foo

<span>s3</span><span>:</span> <span>|</span><span>-</span>
  Foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>转为 JavaScript 代码如下。</p>
<div><pre><code><span>{</span> <span>s1</span><span>:</span> <span>'Foo\n'</span><span>,</span> <span>s2</span><span>:</span> <span>'Foo\n\n\n'</span><span>,</span> <span>s3</span><span>:</span> <span>'Foo'</span> <span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="引用" tabindex="-1"> 引用</h2>
<p>锚点 <code>&amp;</code> 和别名 <code>*</code>，可以用来引用。</p>
<div><pre><code><span>defaults</span><span>:</span> <span>&amp;defaults</span>
  <span>adapter</span><span>:</span> postgres
  <span>host</span><span>:</span> localhost

<span>development</span><span>:</span>
  <span>database</span><span>:</span> myapp_development
  <span>&lt;&lt;</span><span>:</span> <span>*defaults</span>

<span>test</span><span>:</span>
  <span>database</span><span>:</span> myapp_test
  <span>&lt;&lt;</span><span>:</span> <span>*defaults</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>等同于下面的代码。</p>
<div><pre><code><span>defaults</span><span>:</span>
  <span>adapter</span><span>:</span> postgres
  <span>host</span><span>:</span> localhost

<span>development</span><span>:</span>
  <span>database</span><span>:</span> myapp_development
  <span>adapter</span><span>:</span> postgres
  <span>host</span><span>:</span> localhost

<span>test</span><span>:</span>
  <span>database</span><span>:</span> myapp_test
  <span>adapter</span><span>:</span> postgres
  <span>host</span><span>:</span> localhost
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>&amp;</code> 用来建立锚点(defaults)，<code>&lt;&lt;</code> 表示合并到当前数据，<code>*</code> 用来引用锚点。</p>
<p>下面是另一个例子。</p>
<div><pre><code><span>-</span> <span>&amp;showell</span> Steve
<span>-</span> Clark
<span>-</span> Brian
<span>-</span> Oren
<span>-</span> <span>*showell</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>转为 JavaScript 代码如下。</p>
<div><pre><code><span>[</span><span>"Steve"</span><span>,</span> <span>"Clark"</span><span>,</span> <span>"Brian"</span><span>,</span> <span>"Oren"</span><span>,</span> <span>"Steve"</span><span>]</span><span>;</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="函数和正则表达式的转换" tabindex="-1"> 函数和正则表达式的转换</h2>
<p>这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。(官方 yaml 标准里不包含这个部分)</p>
<div><pre><code><span># example.yml</span>

<span>fn</span><span>:</span> function () <span>{</span> return 1 <span>}</span>
<span>reg</span><span>:</span> /test/
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>解析上面的 yml 文件的代码如下。</p>
<div><pre><code><span>var</span> yaml <span>=</span> <span>require</span><span>(</span><span>"js-yaml"</span><span>)</span><span>;</span>
<span>var</span> fs <span>=</span> <span>require</span><span>(</span><span>"fs"</span><span>)</span><span>;</span>

<span>try</span> <span>{</span>
  <span>var</span> doc <span>=</span> yaml<span>.</span><span>load</span><span>(</span>fs<span>.</span><span>readFileSync</span><span>(</span><span>"./example.yml"</span><span>,</span> <span>"utf8"</span><span>)</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>doc<span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>从 JavaScript 对象还原到 yaml 文件的代码如下。</p>
<div><pre><code><span>var</span> yaml <span>=</span> <span>require</span><span>(</span><span>"js-yaml"</span><span>)</span><span>;</span>
<span>var</span> fs <span>=</span> <span>require</span><span>(</span><span>"fs"</span><span>)</span><span>;</span>

<span>var</span> obj <span>=</span> <span>{</span>
  <span>fn</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>1</span><span>;</span>
  <span>}</span><span>,</span>
  <span>reg</span><span>:</span> <span><span>/</span><span>test</span><span>/</span></span><span>,</span>
<span>}</span><span>;</span>

<span>try</span> <span>{</span>
  fs<span>.</span><span>writeFileSync</span><span>(</span><span>"./example.yml"</span><span>,</span> yaml<span>.</span><span>dump</span><span>(</span>obj<span>)</span><span>,</span> <span>"utf8"</span><span>)</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Bash 教程</title>
      <link>https://shimonzhan.com/code/linux/bash/</link>
      <guid>https://shimonzhan.com/code/linux/bash/</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 教程</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/code/linux/bash/intro.html">简介</a></p>
</li>
<li>
<p><a href="/code/linux/bash/grammar.html">基本语法</a></p>
</li>
<li>
<p><a href="/code/linux/bash/expansion.html">模式扩展</a></p>
</li>
<li>
<p><a href="/code/linux/bash/quotation.html">引号和转义</a></p>
</li>
<li>
<p><a href="/code/linux/bash/variable.html">变量</a></p>
</li>
<li>
<p><a href="/code/linux/bash/string.html">字符串操作</a></p>
</li>
<li>
<p><a href="/code/linux/bash/arithmetic.html">算术运算</a></p>
</li>
<li>
<p><a href="/code/linux/bash/readline.html">行操作</a></p>
</li>
<li>
<p><a href="/code/linux/bash/stack.html">目录堆栈</a></p>
</li>
<li>
<p><a href="/code/linux/bash/script.html">脚本入门</a></p>
</li>
<li>
<p><a href="/code/linux/bash/read.html">read 命令</a></p>
</li>
<li>
<p><a href="/code/linux/bash/condition.html">条件判断</a></p>
</li>
<li>
<p><a href="/code/linux/bash/loop.html">循环</a></p>
</li>
<li>
<p><a href="/code/linux/bash/function.html">函数</a></p>
</li>
<li>
<p><a href="/code/linux/bash/array.html">数组</a></p>
</li>
<li>
<p><a href="/code/linux/bash/set.html">set 命令</a></p>
</li>
<li>
<p><a href="/code/linux/bash/debug.html">脚本除错</a></p>
</li>
<li>
<p><a href="/code/linux/bash/mktemp.html">mktemp 命令，trap 命令</a></p>
</li>
<li>
<p><a href="/code/linux/bash/startup.html">启动环境</a></p>
</li>
<li>
<p><a href="/code/linux/bash/prompt.html">命令提示符</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的算术运算</title>
      <link>https://shimonzhan.com/code/linux/bash/arithmetic.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/arithmetic.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 的算术运算</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="算术表达式" tabindex="-1"> 算术表达式</h2>
<p><code>((...))</code> 语法可以进行整数的算术运算。</p>
<div><pre><code>$ <span><span>((</span>foo <span>=</span> <span>5</span> <span>+</span> <span>5</span><span>))</span></span>
$ <span>echo</span> <span>$foo</span>
<span>10</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div><pre><code><span><span>((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>
<span><span>((</span> <span>2</span><span>+</span><span>2</span> <span>))</span></span>
<span><span>((</span> <span>2</span> <span>+</span> <span>2</span> <span>))</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>+</span> <span>2</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>
<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>
<div><pre><code>$ <span><span>((</span> <span>3</span> <span>-</span> <span>3</span> <span>))</span></span>
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>: 加法</li>
<li><code>-</code>: 减法</li>
<li><code>*</code>: 乘法</li>
<li><code>/</code>: 除法(整除)</li>
<li><code>%</code>: 余数</li>
<li><code>**</code>: 指数</li>
<li><code>++</code>: 自增运算(前缀或后缀)</li>
<li><code>--</code>: 自减运算(前缀或后缀)</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>5</span> <span>/</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div><pre><code>$ <span>i</span><span>=</span><span>0</span>
$ <span>echo</span> <span>$i</span>
<span>0</span>
$ <span>echo</span> <span><span>$((</span>i<span>++</span><span>))</span></span>
<span>0</span>
$ <span>echo</span> <span>$i</span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>++</span>i<span>))</span></span>
<span>2</span>
$ <span>echo</span> <span>$i</span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>
<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> <span>(</span><span>2</span> <span>+</span> <span>3</span><span>)</span> <span>*</span> <span>4</span> <span>))</span></span>
<span>20</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code> 结构可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>(</span><span>5</span><span>**</span><span>2</span><span>)</span> <span>*</span> <span>3</span><span>))</span></span>
<span>75</span>
<span># 等同于</span>
$ <span>echo</span> <span><span>$((</span><span>$((</span><span>5</span><span>**</span><span>2</span><span>))</span></span> * <span>3</span><span>))</span>
<span>75</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这个语法只能计算整数，否则会报错。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span><span>$((</span><span>1.5</span> <span>+</span> <span>1</span><span>))</span></span>
bash: 语法错误
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>
<div><pre><code>$ <span>number</span><span>=</span><span>2</span>
$ <span>echo</span> <span><span>$((</span>$number <span>+</span> <span>1</span><span>))</span></span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>
<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span> "hello" <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
$ <span>echo</span> <span><span>$((</span> "hello" <span>*</span> <span>2</span><span>))</span></span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span><span>))</span></span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>hello</span><span>=</span><span>3</span>
$ <span>echo</span> <span><span>$((</span> foo <span>+</span> <span>2</span> <span>))</span></span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>
<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>
<div><pre><code>$ <span>echo</span> $<span>[</span><span>2</span>+2<span>]</span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="数值的进制" tabindex="-1"> 数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>
<li><code>0number</code>: 八进制数。</li>
<li><code>0xnumber</code>: 十六进制数。</li>
<li><code>base#number</code>: <code>base</code> 进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>0xff</span><span>))</span></span>
<span>255</span>
$ <span>echo</span> <span><span>$((</span><span>2</span>#<span>11111111</span><span>))</span></span>
<span>255</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>
<h2 id="位运算" tabindex="-1"> 位运算</h2>
<p><code>$((...))</code> 支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>
<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>
<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>>></span><span>2</span><span>))</span></span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>16</span><span>&lt;&lt;</span><span>2</span><span>))</span></span>
<span>64</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>17</span><span>&amp;</span><span>3</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>|</span><span>3</span><span>))</span></span>
<span>19</span>
$ <span>echo</span> <span><span>$((</span><span>17</span><span>^</span><span>3</span><span>))</span></span>
<span>18</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="逻辑运算" tabindex="-1"> 逻辑运算</h2>
<p><code>$((...))</code> 支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>: 小于</li>
<li><code>&gt;</code>: 大于</li>
<li><code>&lt;=</code>: 小于或相等</li>
<li><code>&gt;=</code>: 大于或相等</li>
<li><code>==</code>: 相等</li>
<li><code>!=</code>: 不相等</li>
<li><code>&amp;&amp;</code>: 逻辑与</li>
<li><code>||</code>: 逻辑或</li>
<li><code>!</code>: 逻辑否</li>
<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span> <span>(</span><span>3</span> <span>></span> <span>2</span><span>)</span> <span>||</span> <span>(</span><span>4</span> <span>&lt;=</span> <span>1</span><span>)</span> <span>))</span></span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>
<div><pre><code>$ <span>a</span><span>=</span><span>0</span>
$ <span>echo</span> <span><span>$((</span>a<span>&lt;</span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span><span>$((</span>a<span>></span><span>1</span> <span>?</span> <span>1</span> <span>:</span> <span>0</span><span>))</span></span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2 id="赋值运算" tabindex="-1"> 赋值运算</h2>
<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>a<span>=</span><span>1</span><span>))</span></span>
<span>1</span>
$ <span>echo</span> <span>$a</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>: 简单赋值。</li>
<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>5</span>
$ <span>echo</span> <span><span>$((</span>foo<span>*=</span><span>2</span><span>))</span></span>
<span>10</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div><pre><code><span>echo</span> <span><span>$((</span> a<span>&lt;</span><span>1</span> <span>?</span> <span>(</span>a<span>+=</span><span>1</span><span>)</span> <span>:</span> <span>(</span>a<span>-=</span><span>1</span><span>)</span> <span>))</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="求值运算" tabindex="-1"> 求值运算</h2>
<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span>foo <span>=</span> <span>1</span> <span>+</span> <span>2</span><span>,</span> <span>3</span> <span>*</span> <span>4</span><span>))</span></span>
<span>12</span>
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>
<h2 id="expr-命令" tabindex="-1"> expr 命令</h2>
<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>
<div><pre><code>$ <span>expr</span> <span>3</span> + <span>2</span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>expr</code> 命令支持变量替换。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>3</span>
$ <span>expr</span> <span>$foo</span> + <span>2</span>
<span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>
<div><pre><code>$ <span>expr</span> <span>3.5</span> + <span>2</span>
expr: 非整数参数
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数组</title>
      <link>https://shimonzhan.com/code/linux/bash/array.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/array.html</guid>
      <source url="https://shimonzhan.com/rss.xml">数组</source>
      <description>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>

<h2 id="创建数组" tabindex="-1"> 创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div><pre><code>ARRAY<span>[</span>INDEX<span>]</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>
<p>下面创建一个三个成员的数组。</p>
<div><pre><code>array<span>[</span><span>0</span><span>]</span><span>=</span>val
array<span>[</span><span>1</span><span>]</span><span>=</span>val
array<span>[</span><span>2</span><span>]</span><span>=</span>val
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>数组也可以采用一次性赋值的方式创建。</p>
<div><pre><code><span>ARRAY</span><span>=</span><span>(</span>value1 value2 <span>..</span>. valueN<span>)</span>

<span># 等同于</span>

<span>ARRAY</span><span>=</span><span>(</span>
  value1
  value2
  value3
<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div><pre><code><span>array</span><span>=</span><span>(</span>a b c<span>)</span>
<span>array</span><span>=</span><span>(</span><span>[</span><span>2</span><span>]</span><span>=</span>c <span>[</span><span>0</span><span>]</span><span>=</span>a <span>[</span><span>1</span><span>]</span><span>=</span>b<span>)</span>

<span>days</span><span>=</span><span>(</span>Sun Mon Tue Wed Thu Fri Sat<span>)</span>
<span>days</span><span>=</span><span>(</span><span>[</span><span>0</span><span>]</span><span>=</span>Sun <span>[</span><span>1</span><span>]</span><span>=</span>Mon <span>[</span><span>2</span><span>]</span><span>=</span>Tue <span>[</span><span>3</span><span>]</span><span>=</span>Wed <span>[</span><span>4</span><span>]</span><span>=</span>Thu <span>[</span><span>5</span><span>]</span><span>=</span>Fri <span>[</span><span>6</span><span>]</span><span>=</span>Sat<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>只为某些值指定位置，也是可以的。</p>
<div><pre><code><span>names</span><span>=</span><span>(</span>hatter <span>[</span><span>5</span><span>]</span><span>=</span>duchess alice<span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div><pre><code><span>mp3s</span><span>=</span><span>(</span> *.mp3 <span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>
<div><pre><code><span>declare</span> -a ARRAYNAME
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>
<div><pre><code><span>read</span> -a dice
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>
<h2 id="读取数组" tabindex="-1"> 读取数组</h2>
<h3 id="读取单个元素" tabindex="-1"> 读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div><pre><code><span>echo</span> <span>${array<span>[</span>i<span>]</span>}</span>     <span># i 是索引</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>
<div><pre><code>$ array<span>[</span><span>0</span><span>]</span><span>=</span>a

$ <span>echo</span> <span>${array<span>[</span>0<span>]</span>}</span>
a

$ <span>echo</span> <span>$array</span><span>[</span><span>0</span><span>]</span>
a<span>[</span><span>0</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>
<h3 id="读取所有成员" tabindex="-1"> 读取所有成员</h3>
<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>"<span>${names<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>
<div><pre><code>$ <span>activities</span><span>=</span><span>(</span> swimming <span>"water skiing"</span> canoeing <span>"white-water rafting"</span> surfing <span>)</span>
$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>@<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water skiing
Activity: canoeing
Activity: white-water rafting
Activity: surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>${activities<span>[</span>*<span>]</span>}</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming
Activity: water
Activity: skiing
Activity: canoeing
Activity: white-water
Activity: rafting
Activity: surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div><pre><code>$ <span>for</span> <span>act</span> <span>in</span> <span>"<span>${activities<span>[</span>*<span>]</span>}</span>"</span><span>;</span> <span>\</span>
<span>do</span> <span>\</span>
<span>echo</span> <span>"Activity: <span>$act</span>"</span><span>;</span> <span>\</span>
<span>done</span>

Activity: swimming water skiing canoeing white-water rafting surfing
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"<span>${activities<span>[</span>@<span>]</span>}</span>"</span> <span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div><pre><code><span>hobbies</span><span>=</span><span>(</span> <span>"${activities[@]"</span> diving <span>)</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>
<h3 id="默认位置" tabindex="-1"> 默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>
<div><pre><code>$ <span>declare</span> -a foo
$ <span>foo</span><span>=</span>A
$ <span>echo</span> <span>${foo<span>[</span>0<span>]</span>}</span>
A
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo}</span>
a
$ <span>echo</span> <span>$foo</span>
a
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>
<h2 id="数组的长度" tabindex="-1"> 数组的长度</h2>
<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>
<div><pre><code><span>${<span>#</span>array<span>[</span>*<span>]</span>}</span>
<span>${<span>#</span>array<span>[</span>@<span>]</span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>*<span>]</span>}</span>
<span>1</span>

$ <span>echo</span> <span>${<span>#</span>a<span>[</span>@<span>]</span>}</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div><pre><code>$ a<span>[</span><span>100</span><span>]</span><span>=</span>foo
$ <span>echo</span> <span>${<span>#</span>a<span>[</span>100<span>]</span>}</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>
<h2 id="提取数组序号" tabindex="-1"> 提取数组序号</h2>
<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div><pre><code>$ <span>arr</span><span>=</span><span>(</span><span>[</span><span>5</span><span>]</span><span>=</span>a <span>[</span><span>9</span><span>]</span><span>=</span>b <span>[</span><span>23</span><span>]</span><span>=</span>c<span>)</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
$ <span>echo</span> <span>${<span>!</span>arr<span>[</span>*<span>]</span>}</span>
<span>5</span> <span>9</span> <span>23</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>
<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>
<div><pre><code><span>arr</span><span>=</span><span>(</span>a b c d<span>)</span>

<span>for</span> <span>i</span> <span>in</span> <span>${<span>!</span>arr<span>[</span>@<span>]</span>}</span><span>;</span><span>do</span>
  <span>echo</span> <span>${arr<span>[</span>i<span>]</span>}</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="提取数组成员" tabindex="-1"> 提取数组成员</h2>
<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>
<div><pre><code>$ <span>food</span><span>=</span><span>(</span> apples bananas cucumbers dates eggs fajitas grapes <span>)</span>
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>1}</span>
bananas
$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>1<span>:</span>3}</span>
bananas cucumbers dates
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>
<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>
<div><pre><code>$ <span>echo</span> <span>${food<span>[</span>@<span>]</span><span>:</span>4}</span>
eggs fajitas grapes
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>
<h2 id="追加数组成员" tabindex="-1"> 追加数组成员</h2>
<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c

$ <span>foo</span><span>+=</span><span>(</span>d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="删除数组" tabindex="-1"> 删除数组</h2>
<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b c d e f

$ <span>unset</span> foo<span>[</span><span>2</span><span>]</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a b d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ foo<span>[</span><span>1</span><span>]</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
a c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div><pre><code>foo<span>[</span><span>1</span><span>]</span><span>=</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>(</span>a b c d e f<span>)</span>
$ <span>foo</span><span>=</span><span>''</span>
$ <span>echo</span> <span>${foo<span>[</span>@<span>]</span>}</span>
b c d e f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code> 可以清空整个数组。</p>
<div><pre><code>$ <span>unset</span> ARRAY

$ <span>echo</span> <span>${ARRAY<span>[</span>*<span>]</span>}</span>
<span>&lt;</span>--no output--<span>></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="关联数组" tabindex="-1"> 关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code> 可以声明关联数组。</p>
<div><pre><code><span>declare</span> -A colors
colors<span>[</span><span>"red"</span><span>]</span><span>=</span><span>"#ff0000"</span>
colors<span>[</span><span>"green"</span><span>]</span><span>=</span><span>"#00ff00"</span>
colors<span>[</span><span>"blue"</span><span>]</span><span>=</span><span>"#0000ff"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div><pre><code><span>echo</span> <span>${colors<span>[</span>"blue"<span>]</span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>条件判断</title>
      <link>https://shimonzhan.com/code/linux/bash/condition.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/condition.html</guid>
      <source url="https://shimonzhan.com/rss.xml">条件判断</source>
      <description>本章介绍 Bash 脚本的条件判断语法。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>

<h2 id="if-结构" tabindex="-1"> if 结构</h2>
<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div><pre><code><span>if</span> commands<span>;</span> <span>then</span>
  commands
<span>[</span>elif commands<span>;</span> <span>then</span>
  commands<span>..</span>.<span>]</span>
<span>[</span>else
  commands<span>]</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>
<div><pre><code><span>if</span> <span>test</span> <span>$USER</span> <span>=</span> <span>"foo"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Hello foo."</span>
<span>else</span>
  <span>echo</span> <span>"You are not foo."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div><pre><code><span>if</span> <span>true</span>
<span>then</span>
  <span>echo</span> <span>'hello world'</span>
<span>fi</span>

<span>if</span> <span>false</span>
<span>then</span>
  <span>echo</span> <span>'it is false'</span> <span># 本行不会执行</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>
<div><pre><code>$ <span>if</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world

$ <span>if</span> <span>false</span><span>;</span> <span>then</span> <span>echo</span> <span>"It's true."</span><span>;</span> <span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>
<div><pre><code>$ <span>if</span> <span>echo</span> <span>'hi'</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hi
hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>
<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>
<div><pre><code>$ <span>if</span> <span>false</span><span>;</span> <span>true</span><span>;</span> <span>then</span> <span>echo</span> <span>'hello world'</span><span>;</span> <span>fi</span>
hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>
<p><code>elif</code> 部分可以有多个。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>if</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>1</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"2"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>2</span>
<span>elif</span> <span>[</span> <span>"<span>$character</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>3</span>
<span>else</span>
    <span>echo</span> 输入不符合要求
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>
<h2 id="test-命令" tabindex="-1"> test 命令</h2>
<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>
<div><pre><code><span># 写法一</span>
<span>test</span> expression

<span># 写法二</span>
<span>[</span> expression <span>]</span>

<span># 写法三</span>
<span>[</span><span>[</span> expression <span>]</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>
<div><pre><code>$ <span>test</span> -f /etc/hosts
$ <span>echo</span> <span>$?</span>
<span>0</span>

$ <span>[</span> -f /etc/hosts <span>]</span>
$  <span>echo</span> <span>$?</span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>
<div><pre><code><span># 写法一</span>
<span>if</span> <span>test</span> -e /tmp/foo.txt <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法二</span>
<span>if</span> <span>[</span> -e /tmp/foo.txt <span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>

<span># 写法三</span>
<span>if</span> <span>[</span><span>[</span> -e /tmp/foo.txt <span>]</span><span>]</span> <span>;</span> <span>then</span>
  <span>echo</span> <span>"Found foo.txt"</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="判断表达式" tabindex="-1"> 判断表达式</h2>
<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3 id="文件判断" tabindex="-1"> 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>
<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>
<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>
<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>
<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>
<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>
<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>
<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>
<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>
<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>
<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>
<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>
<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>
<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>
<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>
<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>FILE</span><span>=~</span>/.bashrc

<span>if</span> <span>[</span> -e <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span> -f <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a regular file."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -d <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is a directory."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -r <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is readable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -w <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is writable."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> -x <span>"<span>$FILE</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$FILE</span> is executable/searchable."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"<span>$FILE</span> does not exist"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e &quot;&quot; ]</code> 会判断为伪。</p>
<h3 id="字符串判断" tabindex="-1"> 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>
<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>ANSWER</span><span>=</span>maybe

<span>if</span> <span>[</span> -z <span>"<span>$ANSWER</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"There is no answer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"yes"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is YES."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"no"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is NO."</span>
<span>elif</span> <span>[</span> <span>"<span>$ANSWER</span>"</span> <span>=</span> <span>"maybe"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"The answer is MAYBE."</span>
<span>else</span>
  <span>echo</span> <span>"The answer is UNKNOWN."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n &quot;$COUNT&quot; ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n &quot;&quot; ]</code> 就判断为伪。</p>
<h3 id="整数判断" tabindex="-1"> 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span> -z <span>"<span>$INT</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is empty."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>[</span> <span>$INT</span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is zero."</span>
<span>else</span>
  <span>if</span> <span>[</span> <span>$INT</span> -lt <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is negative."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is positive."</span>
  <span>fi</span>
  <span>if</span> <span>[</span> <span><span>$((</span>INT <span>%</span> <span>2</span><span>))</span></span> -eq <span>0</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is even."</span>
  <span>else</span>
    <span>echo</span> <span>"INT is odd."</span>
  <span>fi</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3 id="正则判断" tabindex="-1"> 正则判断</h3>
<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>
<div><pre><code><span>[</span><span>[</span> string1 <span>=~</span> regex <span>]</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"INT is an integer."</span>
  <span>exit</span> <span>0</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>
<h3 id="test-判断的逻辑运算" tabindex="-1"> test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>
<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>
<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>
</ul>
<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>MIN_VAL</span><span>=</span><span>1</span>
<span>MAX_VAL</span><span>=</span><span>100</span>

<span>INT</span><span>=</span><span>50</span>

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span>[</span><span>[</span> <span>$INT</span> -ge <span>$MIN_VAL</span> <span>&amp;&amp;</span> <span>$INT</span> -le <span>$MAX_VAL</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is within <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
  <span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is out of range."</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>
<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>
<div><pre><code><span>if</span> <span>[</span> <span>!</span> <span>\</span><span>(</span> <span>$INT</span> -ge <span>$MIN_VAL</span> -a <span>$INT</span> -le <span>$MAX_VAL</span> <span>\</span><span>)</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"<span>$INT</span> is outside <span>$MIN_VAL</span> to <span>$MAX_VAL</span>."</span>
<span>else</span>
    <span>echo</span> <span>"<span>$INT</span> is in range."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3 id="算术判断" tabindex="-1"> 算术判断</h3>
<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>
<div><pre><code><span>if</span> <span><span>((</span><span>3</span> <span>></span> <span>2</span><span>))</span></span><span>;</span> <span>then</span>
  <span>echo</span> <span>"true"</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>
<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span><span>1</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>fi</span>
It is true.
$ <span>if</span> <span><span>((</span><span>0</span><span>))</span></span><span>;</span> <span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span> <span>else</span> <span>echo</span> <span>"it is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>
<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>5</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"foo is <span>$foo</span>"</span><span>;</span> <span>fi</span>
foo is <span>5</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>
<div><pre><code>$ <span>if</span> <span><span>((</span> foo <span>=</span> <span>0</span> <span>))</span></span><span>;</span><span>then</span> <span>echo</span> <span>"It is true."</span><span>;</span><span>else</span> <span>echo</span> <span>"It is false."</span><span>;</span> <span>fi</span>
It is false.
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是用算术条件改写的数值判断脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>INT</span><span>=</span>-5

<span>if</span> <span>[</span><span>[</span> <span>"<span>$INT</span>"</span> <span>=~</span> ^-?<span>[</span><span>0</span>-9<span>]</span>+$ <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>if</span> <span><span>((</span>INT <span>==</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
    <span>echo</span> <span>"INT is zero."</span>
  <span>else</span>
    <span>if</span> <span><span>((</span>INT <span>&lt;</span> <span>0</span><span>))</span></span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is negative."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is positive."</span>
    <span>fi</span>
    <span>if</span> <span><span>((</span> <span>((</span>INT <span>%</span> <span>2</span><span>))</span></span> <span>==</span> <span>0</span><span>))</span><span>;</span> <span>then</span>
      <span>echo</span> <span>"INT is even."</span>
    <span>else</span>
      <span>echo</span> <span>"INT is odd."</span>
    <span>fi</span>
  <span>fi</span>
<span>else</span>
  <span>echo</span> <span>"INT is not an integer."</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href="/code/linux/bash/arithmetic.html">Bash 的算术运算</a> 一章。</p>
<h3 id="普通命令的逻辑运算" tabindex="-1"> 普通命令的逻辑运算</h3>
<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
command1 <span>||</span> command2
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>
<div><pre><code><span>mkdir</span> temp <span>&amp;&amp;</span> <span>cd</span> temp
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div><pre><code><span>[</span> -d temp <span>]</span> <span>||</span> <span>mkdir</span> temp
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div><pre><code><span>[</span> <span>!</span> -d temp <span>]</span> <span>&amp;&amp;</span> <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>
<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>
<div><pre><code><span>if</span> <span>[</span> condition <span>]</span> <span>&amp;&amp;</span> <span>[</span> condition <span>]</span><span>;</span> <span>then</span>
  <span>command</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面是一个示例。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>filename</span><span>=</span><span>$1</span>
<span>word1</span><span>=</span><span>$2</span>
<span>word2</span><span>=</span><span>$3</span>

<span>if</span> <span>grep</span> <span>$word1</span> <span>$filename</span> <span>&amp;&amp;</span> <span>grep</span> <span>$word2</span> <span>$filename</span>
<span>then</span>
  <span>echo</span> <span>"<span>$word1</span> and <span>$word2</span> are both in <span>$filename</span>."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>
<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>"<span>$dir_name</span>"</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 等同于</span>

<span>if</span> <span>[</span><span>[</span> <span>!</span> -d <span>"<span>$dir_name</span>"</span> <span>]</span><span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"No such directory: '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>cd</span> <span>"<span>$dir_name</span>"</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Cannot cd to '<span>$dir_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
<span>if</span> <span>!</span> <span>rm</span> *<span>;</span> <span>then</span>
  <span>echo</span> <span>"File deletion failed. Check results"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="case-结构" tabindex="-1"> case 结构</h2>
<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>
<div><pre><code><span>case</span> expression <span>in</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  pattern <span>)</span>
    commands <span>;</span><span>;</span>
  <span>..</span>.
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个 1 到 3 之间的数字(包含两端)> "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>1</span> <span>)</span> <span>echo</span> <span>1</span>
    <span>;</span><span>;</span>
  <span>2</span> <span>)</span> <span>echo</span> <span>2</span>
    <span>;</span><span>;</span>
  <span>3</span> <span>)</span> <span>echo</span> <span>3</span>
    <span>;</span><span>;</span>
  * <span>)</span> <span>echo</span> 输入不符合要求
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>
<p>下面是另一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>OS</span><span>=</span><span><span>$(</span><span>uname</span> -s<span>)</span></span>

<span>case</span> <span>"<span>$OS</span>"</span> <span>in</span>
  FreeBSD<span>)</span> <span>echo</span> <span>"This is FreeBSD"</span> <span>;</span><span>;</span>
  Darwin<span>)</span> <span>echo</span> <span>"This is Mac OSX"</span> <span>;</span><span>;</span>
  AIX<span>)</span> <span>echo</span> <span>"This is AIX"</span> <span>;</span><span>;</span>
  Minix<span>)</span> <span>echo</span> <span>"This is Minix"</span> <span>;</span><span>;</span>
  Linux<span>)</span> <span>echo</span> <span>"This is Linux"</span> <span>;</span><span>;</span>
  *<span>)</span> <span>echo</span> <span>"Failed to identify this OS"</span> <span>;</span><span>;</span>
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>: 匹配 <code>a</code>。</li>
<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>
<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>
<li><code>???)</code>: 匹配 3 个字符的单词。</li>
<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>
<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>
</ul>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一个字母或数字 > "</span>
<span>read</span> character
<span>case</span> <span>$character</span> <span>in</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span> <span>|</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span> <span>)</span> <span>echo</span> <span>"输入了字母 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  <span>[</span><span>0</span>-9<span>]</span> <span>)</span>                     <span>echo</span> <span>"输入了数字 <span>$character</span>"</span>
                              <span>;</span><span>;</span>
  * <span>)</span>                         <span>echo</span> <span>"输入不符合要求"</span>
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>
<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>read</span> -n <span>1</span> -p <span>"Type a character > "</span>
<span>echo</span>
<span>case</span> <span>$REPLY</span> <span>in</span>
  <span>[</span><span>[</span>:upper:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is upper case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:lower:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is lower case."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:alpha:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is alphabetic."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:digit:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a digit."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:graph:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a visible character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:punct:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a punctuation symbol."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:space:<span>]</span><span>]</span><span>)</span>    <span>echo</span> <span>"'<span>$REPLY</span>' is a whitespace character."</span> <span>;</span><span>;</span><span>&amp;</span>
  <span>[</span><span>[</span>:xdigit:<span>]</span><span>]</span><span>)</span>   <span>echo</span> <span>"'<span>$REPLY</span>' is a hexadecimal digit."</span> <span>;</span><span>;</span><span>&amp;</span>
<span>esac</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，会得到下面的结果。</p>
<div><pre><code>$ test.sh
Type a character <span>></span> a
<span>'a'</span> is lower case.
<span>'a'</span> is alphabetic.
<span>'a'</span> is a visible character.
<span>'a'</span> is a hexadecimal digit.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener noreferrer">The Linux command-line</a>, William Shotts</li>
<li><a href="https://www.pcwdld.com/linux-commands-cheat-sheet" target="_blank" rel="noopener noreferrer">Linux Commands Cheat Sheet</a> (一个很简短的 CheatSheet)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>脚本除错</title>
      <link>https://shimonzhan.com/code/linux/bash/debug.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/debug.html</guid>
      <source url="https://shimonzhan.com/rss.xml">脚本除错</source>
      <description>本章介绍如何对 Shell 脚本除错。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>

<h2 id="常见错误" tabindex="-1"> 常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div><pre><code><span>#! /bin/bash</span>

<span>dir_name</span><span>=</span>/path/not/exist

<span>cd</span> <span>$dir_name</span>
<span>rm</span> *
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div><pre><code><span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>rm</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div><pre><code><span>[</span><span>[</span> -d <span>$dir_name</span> <span>]</span><span>]</span> <span>&amp;&amp;</span> <span>cd</span> <span>$dir_name</span> <span>&amp;&amp;</span> <span>echo</span> <span>rm</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>
<h2 id="bash-的-x-参数" tabindex="-1"> <code>bash</code> 的 <code>-x</code> 参数</h2>
<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本 <code>script.sh</code>。</p>
<div><pre><code><span># script.sh</span>
<span>echo</span> hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>
<div><pre><code>$ <span>bash</span> -x script.sh
+ <span>echo</span> hello world
hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>
<div><pre><code><span>#! /bin/bash -x</span>
<span># trouble: script to demonstrate common errors</span>

<span>number</span><span>=</span><span>1</span>
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>1</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number is equal to 1."</span>
<span>else</span>
  <span>echo</span> <span>"Number is not equal to 1."</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>
<div><pre><code>$ trouble
+ <span>number</span><span>=</span><span>1</span>
+ <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
+ <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>
<div><pre><code>$ <span>export</span> <span><span>PS4</span></span><span>=</span><span>'$LINENO + '</span>
$ trouble
<span>5</span> + <span>number</span><span>=</span><span>1</span>
<span>7</span> + <span>'['</span> <span>1</span> <span>=</span> <span>1</span> <span>']'</span>
<span>8</span> + <span>echo</span> <span>'Number is equal to 1.'</span>
Number is equal to <span>1</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href="/code/linux/bash/set.html">set 命令</a> 一章。</p>
<h2 id="环境变量" tabindex="-1"> 环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3 id="lineno" tabindex="-1"> LINENO</h3>
<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"This is line <span>$LINENO</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>
<div><pre><code>$ ./test.sh
This is line <span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h3 id="funcname" tabindex="-1"> FUNCNAME</h3>
<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>

<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: FUNCNAME0 is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME1 is <span>${FUNCNAME<span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME2 is <span>${FUNCNAME<span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>

func1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>
<div><pre><code>$ ./test.sh
func1: FUNCNAME0 is func1
func1: FUNCNAME1 is main
func1: FUNCNAME2 is
func2: FUNCNAME0 is func2
func2: FUNCNAME1 is func1
func2: FUNCNAME2 is main
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>
<h3 id="bash-source" tabindex="-1"> BASH_SOURCE</h3>
<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
  func2
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_SOURCE0 is <span>${<span>BASH_SOURCE</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE1 is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE2 is <span>${<span>BASH_SOURCE</span><span>[</span>2<span>]</span>}</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: BASH_SOURCE0 is lib1.sh
func1: BASH_SOURCE1 is ./main.sh
func1: BASH_SOURCE2 is
func2: BASH_SOURCE0 is lib2.sh
func2: BASH_SOURCE1 is lib1.sh
func2: BASH_SOURCE2 is ./main.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>
<h3 id="bash-lineno" tabindex="-1"> BASH_LINENO</h3>
<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div><pre><code><span># lib1.sh</span>
<span>function</span> <span>func1</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func1: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func1: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>

  func2
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><div><pre><code><span># lib2.sh</span>
<span>function</span> <span>func2</span><span>(</span><span>)</span>
<span>{</span>
  <span>echo</span> <span>"func2: BASH_LINENO is <span>${<span>BASH_LINENO</span><span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: FUNCNAME is <span>${FUNCNAME<span>[</span>0<span>]</span>}</span>"</span>
  <span>echo</span> <span>"func2: BASH_SOURCE is <span>${<span>BASH_SOURCE</span><span>[</span>1<span>]</span>}</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># main.sh</span>

<span>source</span> lib1.sh
<span>source</span> lib2.sh

func1
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div><pre><code>$ ./main.sh
func1: <span>BASH_LINENO</span> is <span>7</span>
func1: FUNCNAME is func1
func1: <span>BASH_SOURCE</span> is main.sh
func2: <span>BASH_LINENO</span> is <span>8</span>
func2: FUNCNAME is func2
func2: <span>BASH_SOURCE</span> is lib1.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的模式扩展</title>
      <link>https://shimonzhan.com/code/linux/bash/expansion.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/expansion.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 的模式扩展</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div><pre><code>$ <span>set</span> -o noglob
<span># 或者</span>
$ <span>set</span> -f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面的命令可以重新打开扩展。</p>
<div><pre><code>$ <span>set</span> +o noglob
<span># 或者</span>
$ <span>set</span> +f
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="波浪线扩展" tabindex="-1"> 波浪线扩展</h2>
<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>
<div><pre><code>$ <span>echo</span> ~
/home/me
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>
<div><pre><code><span># 进入 /home/me/foo 目录</span>
$ <span>cd</span> ~/foo
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>
<div><pre><code>$ <span>echo</span> ~foo
/home/foo

$ <span>echo</span> ~root
/root
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>
<div><pre><code>$ <span>echo</span> ~nonExistedUser
~nonExistedUser
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>
<div><pre><code>$ <span>cd</span> ~/foo
$ <span>echo</span> ~+
/home/me/foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="字符扩展" tabindex="-1"> <code>?</code> 字符扩展</h2>
<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> ?.txt
a.txt b.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> ??.txt
ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div><pre><code><span># 当前目录有 a.txt 文件</span>
$ <span>echo</span> ?.txt
a.txt

<span># 当前目录为空目录</span>
$ <span>echo</span> ?.txt
?.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>
<h2 id="字符扩展-1" tabindex="-1"> <code>*</code> 字符扩展</h2>
<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> *.txt
a.txt b.txt ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>
<div><pre><code><span>ls</span> *
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 ab.txt</span>
$ <span>ls</span> a*.txt
a.txt ab.txt

$ <span>ls</span> *b*
b.txt ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>
<div><pre><code><span># 显示所有隐藏文件</span>
$ <span>echo</span> .*
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>
<div><pre><code><span>echo</span> .<span>[</span><span>!</span>.<span>]</span>*
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div><pre><code><span># 当前目录不存在 c 开头的文件</span>
$ <span>echo</span> c*.txt
c*.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>
<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>
<div><pre><code><span># 子目录有一个 a.txt</span>
<span># 无效的写法</span>
$ <span>ls</span> *.txt

<span># 有效的写法</span>
$ <span>ls</span> */*.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>
<h2 id="方括号扩展" tabindex="-1"> 方括号扩展</h2>
<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>
<div><pre><code><span># 存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt b.txt

<span># 只存在文件 a.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
a.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div><pre><code><span># 不存在文件 a.txt 和 b.txt</span>
$ <span>ls</span> <span>[</span>ab<span>]</span>.txt
ls: 无法访问<span>'[ab].txt'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>
<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>
<div><pre><code><span># 存在 aaa、bbb、aba 三个文件</span>
$ <span>ls</span> ?<span>[</span><span>!</span>a<span>]</span>?
aba bbb
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>
<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>
<h2 id="start-end-扩展" tabindex="-1"> [start-end] 扩展</h2>
<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>
<div><pre><code><span># 存在文件 a.txt、b.txt 和 c.txt</span>
$ <span>ls</span> <span>[</span>a-c<span>]</span>.txt
a.txt
b.txt
c.txt

<span># 存在文件 report1.txt、report2.txt 和 report3.txt</span>
$ <span>ls</span> report<span>[</span><span>0</span>-9<span>]</span>.txt
report1.txt
report2.txt
report3.txt
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>: 所有小写字母。</li>
<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>
<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>
<div><pre><code>$ <span>echo</span> report<span>[</span><span>!</span><span>1</span>–3<span>]</span>.txt
report4.txt report5.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>
<h2 id="大括号扩展" tabindex="-1"> 大括号扩展</h2>
<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1,2</span>,3<span>}</span>
<span>1</span> <span>2</span> <span>3</span>

$ <span>echo</span> d<span>{</span>a,e,i,u,o<span>}</span>g
dag deg <span>dig</span> dug dog

$ <span>echo</span> Front-<span>{</span>A,B,C<span>}</span>-Back
Front-A-Back Front-B-Back Front-C-Back
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div><pre><code>$ <span>ls</span> <span>{</span>a,b,c<span>}</span>.txt
ls: 无法访问<span>'a.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'b.txt'</span><span>:</span> 没有那个文件或目录
ls: 无法访问<span>'c.txt'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>1</span> , <span>2</span><span>}</span>
<span>{</span><span>1</span> , <span>2</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div><pre><code>$ <span>cp</span> a.log<span>{</span>,.bak<span>}</span>

<span># 等同于</span>
<span># cp a.log a.log.bak</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>大括号可以嵌套。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>j<span>{</span>p,pe<span>}</span>g,png<span>}</span>
jpg jpeg png

$ <span>echo</span> a<span>{</span>A<span>{</span><span>1,2</span><span>}</span>,B<span>{</span><span>3,4</span><span>}</span><span>}</span>b
aA1b aA2b aB3b aB4b
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,d*<span>}</span>
<span>cat</span> dawg dg <span>dig</span> dog doug dug
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>cat,dog<span>}</span>
<span>cat</span> dog
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div><pre><code><span># 不存在 a.txt 和 b.txt</span>
$ <span>echo</span> <span>[</span>ab<span>]</span>.txt
<span>[</span>ab<span>]</span>.txt

$ <span>echo</span> <span>{</span>a,b<span>}</span>.txt
a.txt b.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>
<h2 id="start-end-扩展-1" tabindex="-1"> {start..end} 扩展</h2>
<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span>
a b c

$ <span>echo</span> d<span>{</span>a<span>..</span>d<span>}</span>g
dag dbg dcg ddg

$ <span>echo</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>1</span> <span>2</span> <span>3</span> <span>4</span>

$ <span>echo</span> Number_<span>{</span><span>1</span><span>..</span><span>5</span><span>}</span>
Number_1 Number_2 Number_3 Number_4 Number_5
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这种简写形式支持逆序。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>c<span>..</span>a<span>}</span>
c b a

$ <span>echo</span> <span>{</span><span>5</span><span>..</span><span>1</span><span>}</span>
<span>5</span> <span>4</span> <span>3</span> <span>2</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a1<span>..</span>3c<span>}</span>
<span>{</span>a1<span>..</span>3c<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div><pre><code>$ <span>echo</span> .<span>{</span>mp<span>{</span><span>3</span><span>..</span><span>4</span><span>}</span>,m4<span>{</span>a,b,p,v<span>}</span><span>}</span>
.mp3 .mp4 .m4a .m4b .m4p .m4v
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>
<div><pre><code><span>mkdir</span> <span>{</span><span>2007</span><span>..</span><span>2009</span><span>}</span>-<span>{</span>01<span>..</span><span>12</span><span>}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> <span>{</span><span>1</span><span>..</span><span>4</span><span>}</span>
<span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>01<span>..</span><span>5</span><span>}</span>
01 02 03 04 05

$ <span>echo</span> <span>{</span>001<span>..</span><span>5</span><span>}</span>
001 002 003 004 005
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>
<div><pre><code>$ <span>echo</span> <span>{</span><span>0</span><span>..</span><span>8</span><span>..</span><span>2</span><span>}</span>
<span>0</span> <span>2</span> <span>4</span> <span>6</span> <span>8</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div><pre><code>$ <span>echo</span> <span>{</span>a<span>..</span>c<span>}</span><span>{</span><span>1</span><span>..</span><span>3</span><span>}</span>
a1 a2 a3 b1 b2 b3 c1 c2 c3
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="变量扩展" tabindex="-1"> 变量扩展</h2>
<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href="/code/linux/bash/variable.html">Bash 变量</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>SHELL</span>}</span>
/bin/bash
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>
<div><pre><code>$ <span>echo</span> <span>${<span>!</span>S*}</span>
<span>SECONDS</span> <span>SHELL</span> <span>SHELLOPTS</span> <span>SHLVL</span> SSH_AGENT_PID <span>SSH_AUTH_SOCK</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>
<h2 id="子命令扩展" tabindex="-1"> 子命令扩展</h2>
<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div><pre><code>$ <span>echo</span> <span><span>$(</span><span>date</span><span>)</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div><pre><code>$ <span>echo</span> <span><span>`</span><span>date</span><span>`</span></span>
Tue Jan <span>28</span> 00:01:13 CST <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>
<h2 id="算术扩展" tabindex="-1"> 算术扩展</h2>
<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href="/code/linux/bash/arithmetic.html">Bash 的算术运算</a> 一章。</p>
<div><pre><code>$ <span>echo</span> <span><span>$((</span><span>2</span> <span>+</span> <span>2</span><span>))</span></span>
<span>4</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="字符类" tabindex="-1"> 字符类</h2>
<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>
<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>
<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>
<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>
</ul>
<p>请看下面的例子。</p>
<div><pre><code><span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>
<div><pre><code><span>echo</span> <span>[</span><span>!</span><span>[</span>:digit:<span>]</span><span>]</span>*
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div><pre><code><span># 不存在以大写字母开头的文件</span>
$ <span>echo</span> <span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
<span>[</span><span>[</span>:upper:<span>]</span><span>]</span>*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2 id="使用注意点" tabindex="-1"> 使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p>(1)<strong>通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div><pre><code>$ <span>ls</span> a*.txt
ab.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>
<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div><pre><code><span># 不存在 r 开头的文件名</span>
$ <span>echo</span> r*
r*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>
<p>下面是另一个例子。</p>
<div><pre><code>$ <span>ls</span> *.csv
ls: *.csv: No such <span>file</span> or directory
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>
<p>(3)<strong>只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div><pre><code><span>ls</span> */*.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>
<p>(4)<strong>文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div><pre><code>$ <span>touch</span> <span>'fo*'</span>
$ <span>ls</span>
fo*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>
<h2 id="量词语法" tabindex="-1"> 量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>
<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>.<span>)</span>txt
abctxt abc.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>
<div><pre><code>$ <span>ls</span> abc?<span>(</span>def<span>)</span>
abc abcdef
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>|</span>.php<span>)</span>
abc.php abc.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>
<div><pre><code>$ <span>ls</span> abc+<span>(</span>.txt<span>)</span>
abc.txt abc.txt.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div><pre><code><span># 没有 abc 开头的文件名</span>
$ <span>ls</span> abc?<span>(</span>def<span>)</span>
ls: 无法访问<span>'abc?(def)'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>
<h2 id="shopt-命令" tabindex="-1"> shopt 命令</h2>
<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code> 命令的使用方法如下。</p>
<div><pre><code><span># 打开某个参数</span>
$ <span>shopt</span> -s <span>[</span>optionname<span>]</span>

<span># 关闭某个参数</span>
$ <span>shopt</span> -u <span>[</span>optionname<span>]</span>

<span># 查询某个参数关闭还是打开</span>
$ <span>shopt</span> <span>[</span>optionname<span>]</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><ol>
<li>
<p><strong>dotglob 参数</strong></p>
<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div><pre><code>$ <span>ls</span> *
abc.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>
<div><pre><code>$ <span>shopt</span> -s dotglob
$ <span>ls</span> *
abc.txt .config
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
<li>
<p><strong>nullglob 参数</strong></p>
<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div><pre><code>$ <span>rm</span> b*
rm: 无法删除<span>'b*'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>
<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>
<div><pre><code>$ <span>shopt</span> -s nullglob
$ <span>rm</span> b*
rm: 缺少操作数
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>
</li>
<li>
<p><strong>failglob 参数</strong></p>
<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div><pre><code>$ <span>shopt</span> -s failglob
$ <span>rm</span> b*
bash: 无匹配: b*
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>
</li>
<li>
<p><strong>extglob 参数</strong></p>
<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div><pre><code>$ <span>shopt</span> extglob
extglob         on
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div><pre><code><span>shopt</span> -u extglob
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong>nocaseglob 参数</strong></p>
<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>
<div><pre><code>$ <span>shopt</span> -s nocaseglob
$ <span>ls</span> /windows/program*
/windows/ProgramData
/windows/Program Files
/windows/Program Files <span>(</span>x86<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>
</li>
<li>
<p><strong>globstar 参数</strong></p>
<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div><pre><code>a.txt
sub1/b.txt
sub1/sub2/c.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>
<p>默认情况下，只能写成下面这样。</p>
<div><pre><code>$ <span>ls</span> *.txt */*.txt */*/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>
<div><pre><code>$ <span>shopt</span> -s globstar
$ <span>ls</span> **/*.txt
a.txt  sub1/b.txt  sub1/sub2/c.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
</ol>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener noreferrer">Think You Understand Wildcards? Think Again</a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener noreferrer">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 函数</title>
      <link>https://shimonzhan.com/code/linux/bash/function.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/function.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 函数</source>
      <description>本章介绍 Bash 函数的用法。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 函数的用法。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div><pre><code><span># 第一种</span>
<span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>

<span># 第二种</span>
<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span># codes</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div><pre><code><span>hello</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> <span>"Hello <span>$1</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div><pre><code>$ hello world
hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div><pre><code><span>today</span><span>(</span><span>)</span> <span>{</span>
  <span>echo</span> -n <span>"Today's date is: "</span>
  <span>date</span> +<span>"%A, %B %-d, %Y"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>
<div><pre><code><span>unset</span> -f functionName
</code></pre><div aria-hidden="true"><div></div></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>
<div><pre><code><span>declare</span> -f
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>
<p><code>declare</code> 命令还支持查看单个函数的定义。</p>
<div><pre><code><span>declare</span> -f functionName
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>
<div><pre><code><span>declare</span> -F
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="参数变量" tabindex="-1"> 参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>
<li><code>$0</code>: 函数所在的脚本名。</li>
<li><code>$#</code>: 函数的参数总数。</li>
<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>下面是一个示例脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>

<span>function</span> <span>alice</span> <span>{</span>
  <span>echo</span> <span>"alice: <span>$@</span>"</span>
  <span>echo</span> <span>"<span>$0</span>: <span>$1</span> <span>$2</span> <span>$3</span> <span>$4</span>"</span>
  <span>echo</span> <span>"<span>$#</span> arguments"</span>

<span>}</span>

alice <span>in</span> wonderland
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>运行该脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
alice: <span>in</span> wonderland
test.sh: <span>in</span> wonderland
<span>2</span> arguments
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div><pre><code><span>function</span> <span>log_msg</span> <span>{</span>
  <span>echo</span> <span>"[<span><span>`</span><span>date</span> <span>'+ %F %T'</span><span>`</span></span> ]: <span>$@</span>"</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>使用方法如下。</p>
<div><pre><code>$ log_msg <span>"This is sample log message"</span>
<span>[</span> <span>2018</span>-08-16 <span>19</span>:56:34 <span>]</span>: This is sample log message
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="return-命令" tabindex="-1"> return 命令</h2>
<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div><pre><code><span>function</span> <span>func_return_value</span> <span>{</span>
  <span>return</span> <span>10</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>
<div><pre><code>$ func_return_value
$ <span>echo</span> <span>"Value returned by function is: <span>$?</span>"</span>
Value returned by <span>function</span> is: <span>10</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>
<div><pre><code><span>function</span> <span>name</span> <span>{</span>
  commands
  <span>return</span>
<span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h2 id="全局变量和局部变量-local-命令" tabindex="-1"> 全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div><pre><code><span>foo</span><span>=</span><span>1</span>

<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>foo</span><span>=</span><span>2</span>
<span>}</span>

<span>echo</span> <span>$foo</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>
<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>
<div><pre><code><span># 脚本 test.sh</span>
<span>fn</span> <span>(</span><span>)</span> <span>{</span>
  <span>local</span> foo
  <span>foo</span><span>=</span><span>1</span>
  <span>echo</span> <span>"fn: foo = <span>$foo</span>"</span>
<span>}</span>

fn
<span>echo</span> <span>"global: foo = <span>$foo</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ <span>bash</span> test.sh
fn: foo <span>=</span> <span>1</span>
global: foo <span>=</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/" target="_blank" rel="noopener noreferrer">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的基本语法</title>
      <link>https://shimonzhan.com/code/linux/bash/grammar.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/grammar.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 的基本语法</source>
      <description>本章介绍 Bash 的最基本语法。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>

<h2 id="echo-命令" tabindex="-1"> echo 命令</h2>
<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>
<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div><pre><code>$ <span>echo</span> hello world
hello world
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div><pre><code>$ <span>echo</span> <span>"&lt;HTML>
    &lt;HEAD>
          &lt;TITLE>Page Title&lt;/TITLE>
    &lt;/HEAD>
    &lt;BODY>
          Page body.
    &lt;/BODY>
&lt;/HTML>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>
<h3 id="n-参数" tabindex="-1"> <code>-n</code> 参数</h3>
<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div><pre><code>$ <span>echo</span> -n hello world
hello world$
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>
<div><pre><code>$ <span>echo</span> a<span>;</span><span>echo</span> b
a
b

$ <span>echo</span> -n a<span>;</span><span>echo</span> b
ab
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>
<h3 id="e-参数" tabindex="-1"> <code>-e</code> 参数</h3>
<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>
<div><pre><code>$ <span>echo</span> <span>"Hello<span title="\n">\n</span>World"</span>
Hello<span>\</span>nWorld

<span># 双引号的情况</span>
$ <span>echo</span> -e <span>"Hello<span title="\n">\n</span>World"</span>
Hello
World

<span># 单引号的情况</span>
$ <span>echo</span> -e <span>'Hello\nWorld'</span>
Hello
World
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\n</code> 解释为换行符，导致输出内容里面出现换行。</p>
<h2 id="命令格式" tabindex="-1"> 命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div><pre><code><span>command</span> <span>[</span> arg1 <span>..</span>. <span>[</span> argN <span>]</span><span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>
<div><pre><code><span>ls</span> -l
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div><pre><code><span># 短形式</span>
$ <span>ls</span> -r

<span># 长形式</span>
$ <span>ls</span> --reverse
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div><pre><code>$ <span>echo</span> foo bar

<span># 等同于</span>
$ <span>echo</span> foo <span>\</span>
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="空格" tabindex="-1"> 空格</h2>
<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>
<div><pre><code><span>command</span> foo bar
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div><pre><code>$ <span>echo</span> this is a     <span>test</span>
this is a <span>test</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>
<h2 id="分号" tabindex="-1"> 分号</h2>
<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div><pre><code><span>clear</span><span>;</span> <span>ls</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2 id="命令的组合符-和" tabindex="-1"> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div><pre><code>Command1 <span>&amp;&amp;</span> Command2
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>
<div><pre><code>Command1 <span>||</span> Command2
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>
<p>下面是一些例子。</p>
<div><pre><code><span>cat</span> filelist.txt <span>;</span> <span>ls</span> -l filelist.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>
<div><pre><code><span>cat</span> filelist.txt <span>&amp;&amp;</span> <span>ls</span> -l filelist.txt
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>
<div><pre><code><span>mkdir</span> foo <span>||</span> <span>mkdir</span> bar
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>
<h2 id="type-命令" tabindex="-1"> type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>
<p><code>type</code> 命令用来判断命令的来源。</p>
<div><pre><code>$ <span>type</span> <span>echo</span>
<span>echo</span> is a shell <span>builtin</span>
$ <span>type</span> <span>ls</span>
<span>ls</span> is hashed <span>(</span>/bin/ls<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>
<p><code>type</code> 命令本身也是内置命令。</p>
<div><pre><code>$ <span>type</span> <span>type</span>
<span>type</span> is a shell <span>builtin</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>
<div><pre><code>$ <span>type</span> -a <span>echo</span>
<span>echo</span> is shell <span>builtin</span>
<span>echo</span> is /usr/bin/echo
<span>echo</span> is /bin/echo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>
<div><pre><code>$ <span>type</span> -t <span>bash</span>
<span>file</span>
$ <span>type</span> -t <span>if</span>
keyword
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>
<h2 id="快捷键" tabindex="-1"> 快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href="/code/linux/bash/readline.html">行操作</a> 一章。</p>
<ul>
<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>: 向上滚动。</li>
<li><code>Shift + PageDown</code>: 向下滚动。</li>
<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 简介</title>
      <link>https://shimonzhan.com/code/linux/bash/intro.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/intro.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 简介</source>
      <description>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>

<h2 id="shell-的含义" tabindex="-1"> Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2 id="shell-的种类" tabindex="-1"> Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell(sh)</li>
<li>Bourne Again shell(bash)</li>
<li>C Shell(csh)</li>
<li>TENEX C Shell(tcsh)</li>
<li>Korn shell(ksh)</li>
<li>Z Shell(zsh)</li>
<li>Friendly Interactive Shell(fish)</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div><pre><code>$ <span>echo</span> <span>$SHELL</span>
/bin/bash
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div><pre><code><span>cat</span> /etc/shells
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2 id="命令行环境" tabindex="-1"> 命令行环境</h2>
<h3 id="终端模拟器" tabindex="-1"> 终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3 id="命令行提示符" tabindex="-1"> 命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>
<div><pre><code><span>[</span>user@hostname<span>]</span> $
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>
<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>
<h3 id="进入和退出方法" tabindex="-1"> 进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>
<div><pre><code><span>bash</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>
<div><pre><code><span>exit</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>
<div><pre><code>$ <span>pwd</span>
/home/me
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div><pre><code>$ pwe
bash: pwe: 未找到命令
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="shell-和-bash-的历史" tabindex="-1"> Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>
<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>
<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989 年，Bash 发布 1.0 版。</p>
<p>1996 年，Bash 发布 2.0 版。</p>
<p>2004 年，Bash 发布 3.0 版。</p>
<p>2009 年，Bash 发布 4.0 版。</p>
<p>2019 年，Bash 发布 5.0 版。</p>
<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div><pre><code>$ <span>bash</span> --version
GNU bash，版本 <span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release <span>(</span>x86_64-pc-linux-gnu<span>)</span>

<span># 或者</span>
$ <span>echo</span> <span>$BASH_VERSION</span>
<span>5.0</span>.3<span>(</span><span>1</span><span>)</span>-release
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>循环</title>
      <link>https://shimonzhan.com/code/linux/bash/loop.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/loop.html</guid>
      <source url="https://shimonzhan.com/rss.xml">循环</source>
      <description>Bash 提供三种循环语法 for、while 和 until。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>

<h2 id="while-循环" tabindex="-1"> while 循环</h2>
<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div><pre><code><span>while</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>while</span> <span>[</span> <span>"<span>$number</span>"</span> -lt <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>
<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>
<div><pre><code><span>while</span> <span>true</span>
<span>do</span>
  <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>
<p><code>while</code> 循环写成一行，也是可以的。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>
<div><pre><code><span>while</span> <span>echo</span> <span>'ECHO'</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, while looping ...'</span><span>;</span> <span>done</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div><pre><code><span>while</span> <span>true</span><span>;</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, looping ...'</span><span>;</span> <span>done</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>
<h2 id="until-循环" tabindex="-1"> until 循环</h2>
<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div><pre><code><span>until</span> condition<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>
<div><pre><code><span>until</span> condition
<span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>until</span> <span>false</span><span>;</span> <span>do</span> <span>echo</span> <span>'Hi, until looping ...'</span><span>;</span> <span>done</span>
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
Hi, <span>until</span> looping <span>..</span>.
^C
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>0</span>
<span>until</span> <span>[</span> <span>"<span>$number</span>"</span> -ge <span>10</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"Number = <span>$number</span>"</span>
  <span>number</span><span>=</span><span><span>$((</span>number <span>+</span> <span>1</span><span>))</span></span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>
<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div><pre><code><span>until</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div><pre><code><span>while</span> <span>!</span> <span>cp</span> <span>$1</span> <span>$2</span><span>;</span> <span>do</span>
  <span>echo</span> <span>'Attempt to copy failed. waiting...'</span>
  <span>sleep</span> <span>5</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>
<h2 id="for-in-循环" tabindex="-1"> <code>for...in</code> 循环</h2>
<p><code>for...in</code> 循环用于遍历列表的每一项。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list
<span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>
<div><pre><code><span>for</span> <span>variable</span> <span>in</span> list<span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> word1 word2 word3<span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div><pre><code><span>for</span> <span>i</span> <span>in</span> *.png<span>;</span> <span>do</span>
  <span>ls</span> -l <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>count</span><span>=</span><span>0</span>
<span>for</span> <span>i</span> <span>in</span> <span><span>$(</span><span>cat</span> ~/.bash_profile<span>)</span></span><span>;</span> <span>do</span>
  <span>count</span><span>=</span><span><span>$((</span>count <span>+</span> <span>1</span><span>))</span></span>
  <span>echo</span> <span>"Word <span>$count</span> (<span>$i</span>) contains <span><span>$(</span><span>echo</span> -n $i <span>|</span> <span>wc</span> -c<span>)</span></span> characters"</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div><pre><code><span>for</span> filename<span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>

<span># 等同于</span>

<span>for</span> <span>filename</span> <span>in</span> <span>"<span>$@</span>"</span> <span>;</span> <span>do</span>
  <span>echo</span> <span>"<span>$filename</span>"</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>
<h2 id="for-循环" tabindex="-1"> for 循环</h2>
<p><code>for</code> 循环还支持 C 语言的循环语法。</p>
<div><pre><code><span>for</span> <span><span>((</span> expression1<span>;</span> expression2<span>;</span> expression3 <span>))</span></span><span>;</span> <span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>
<p>它等同于下面的 <code>while</code> 循环。</p>
<div><pre><code><span><span>((</span> expression1 <span>))</span></span>
<span>while</span> <span><span>((</span> expression2 <span>))</span></span><span>;</span> <span>do</span>
  commands
  <span><span>((</span> expression3 <span>))</span></span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code><span>for</span> <span><span>((</span> i<span>=</span><span>0</span><span>;</span> i<span>&lt;</span><span>5</span><span>;</span> i<span>=</span>i<span>+</span><span>1</span> <span>))</span></span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>
<p><code>for</code> 条件部分的三个语句，都可以省略。</p>
<div><pre><code><span>for</span> <span><span>((</span><span>;</span><span>;</span><span>))</span></span>
<span>do</span>
  <span>read</span> var
  <span>if</span> <span>[</span> <span>"<span>$var</span>"</span> <span>=</span> <span>"."</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>
<h2 id="break-continue" tabindex="-1"> break，continue</h2>
<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>number</span> <span>in</span> <span>1</span> <span>2</span> <span>3</span> <span>4</span> <span>5</span> <span>6</span>
<span>do</span>
  <span>echo</span> <span>"number is <span>$number</span>"</span>
  <span>if</span> <span>[</span> <span>"<span>$number</span>"</span> <span>=</span> <span>"3"</span> <span>]</span><span>;</span> <span>then</span>
    <span>break</span>
  <span>fi</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>while</span> <span>read</span> -p <span>"What file do you want to test?"</span> filename
<span>do</span>
  <span>if</span> <span>[</span> <span>!</span> -e <span>"<span>$filename</span>"</span> <span>]</span><span>;</span> <span>then</span>
    <span>echo</span> <span>"The file does not exist."</span>
    <span>continue</span>
  <span>fi</span>

  <span>echo</span> <span>"You entered a valid file.."</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>
<h2 id="select-结构" tabindex="-1"> select 结构</h2>
<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>
<div><pre><code><span>select</span> name
<span>[</span>in list<span>]</span>
<span>do</span>
  commands
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>
<ol>
<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体 <code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># select.sh</span>

<span>select</span> <span>brand</span> <span>in</span> Samsung Sony iphone symphony Walton
<span>do</span>
  <span>echo</span> <span>"You have chosen <span>$brand</span>"</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div><pre><code>$ ./select.sh
<span>1</span><span>)</span> Samsung
<span>2</span><span>)</span> Sony
<span>3</span><span>)</span> iphone
<span>4</span><span>)</span> symphony
<span>5</span><span>)</span> Walton
<span>#?</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"Which Operating System do you like?"</span>

<span>select</span> <span>os</span> <span>in</span> Ubuntu LinuxMint Windows8 Windows7 WindowsXP
<span>do</span>
  <span>case</span> <span>$os</span> <span>in</span>
    <span>"Ubuntu"</span><span>|</span><span>"LinuxMint"</span><span>)</span>
      <span>echo</span> <span>"I also use <span>$os</span>."</span>
    <span>;</span><span>;</span>
    <span>"Windows8"</span> <span>|</span> <span>"Windows10"</span> <span>|</span> <span>"WindowsXP"</span><span>)</span>
      <span>echo</span> <span>"Why don't you try Linux?"</span>
    <span>;</span><span>;</span>
    *<span>)</span>
      <span>echo</span> <span>"Invalid entry."</span>
      <span>break</span>
    <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/" target="_blank" rel="noopener noreferrer">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>mktemp 命令，trap 命令</title>
      <link>https://shimonzhan.com/code/linux/bash/mktemp.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/mktemp.html</guid>
      <source url="https://shimonzhan.com/rss.xml">mktemp 命令，trap 命令</source>
      <description>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 /tmp 目录里面创建文件或目录，这样做有很多弊端，使用 mktemp 命令是最安全的做法。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>

<h2 id="临时文件的安全问题" tabindex="-1"> 临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在 <code>/tmp</code> 目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code> 目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div><pre><code>$ <span>touch</span> /tmp/info.txt
$ <span>ls</span> -l /tmp/info.txt
-rw-r--r-- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>17</span>:12 /tmp/info.txt
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令在 <code>/tmp</code> 目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件(使用 <code>trap</code> 命令)。</li>
</ul>
</blockquote>
<h2 id="mktemp-命令的用法" tabindex="-1"> mktemp 命令的用法</h2>
<p><code>mktemp</code> 命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行 <code>mktemp</code> 命令，就能生成一个临时文件。</p>
<div><pre><code>$ mktemp
/tmp/tmp.4GcsWSG4vj

$ <span>ls</span> -l /tmp/tmp.4GcsWSG4vj
-rw------- <span>1</span> ruanyf ruanyf <span>0</span> <span>12</span>月 <span>28</span> <span>12</span>:49 /tmp/tmp.4GcsWSG4vj
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，<code>mktemp</code> 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用 <code>mktemp</code> 命令的用法如下。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>为了确保临时文件创建成功，<code>mktemp</code> 命令后面最好使用 OR 运算符 (<code>||</code>)，保证创建失败时退出脚本。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>为了保证脚本退出时临时文件被删除，可以使用 <code>trap</code> 命令指定退出时的清除操作。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>echo</span> <span>"Our temp file is <span>$TMPFILE</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="mktemp-命令的参数" tabindex="-1"> mktemp 命令的参数</h2>
<p><code>-d</code> 参数可以创建一个临时目录。</p>
<div><pre><code>$ mktemp -d
/tmp/tmp.Wcau5UjmN6
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>-p</code> 参数可以指定临时文件所在的目录。默认是使用 <code>$TMPDIR</code> 环境变量指定的目录，如果这个变量没设置，那么使用 <code>/tmp</code> 目录。</p>
<div><pre><code>$ mktemp -p /home/ruanyf/
/home/ruanyf/tmp.FOKEtvs2H3
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>-t</code> 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 <code>X</code> 字符，表示随机字符，建议至少使用六个 <code>X</code>。默认的文件名模板是 <code>tmp.</code> 后接十个随机字符。</p>
<div><pre><code>$ mktemp -t mytemp.XXXXXXX
/tmp/mytemp.yZ1HgZV
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="trap-命令" tabindex="-1"> trap 命令</h2>
<p><code>trap</code> 命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT(中断)，即按 <code>Ctrl + C</code> 所产生的信号。<code>trap</code> 命令的 <code>-l</code> 参数，可以列出所有的系统信号。</p>
<div><pre><code>$ <span>trap</span> -l
 <span>1</span><span>)</span> SIGHUP  <span>2</span><span>)</span> SIGINT  <span>3</span><span>)</span> SIGQUIT  <span>4</span><span>)</span> SIGILL  <span>5</span><span>)</span> SIGTRAP
 <span>6</span><span>)</span> SIGABRT  <span>7</span><span>)</span> SIGBUS  <span>8</span><span>)</span> SIGFPE  <span>9</span><span>)</span> SIGKILL <span>10</span><span>)</span> SIGUSR1
<span>11</span><span>)</span> SIGSEGV <span>12</span><span>)</span> SIGUSR2 <span>13</span><span>)</span> SIGPIPE <span>14</span><span>)</span> SIGALRM <span>15</span><span>)</span> SIGTERM
<span>16</span><span>)</span> SIGSTKFLT <span>17</span><span>)</span> SIGCHLD <span>18</span><span>)</span> SIGCONT <span>19</span><span>)</span> SIGSTOP <span>20</span><span>)</span> SIGTSTP
<span>21</span><span>)</span> SIGTTIN <span>22</span><span>)</span> SIGTTOU <span>23</span><span>)</span> SIGURG <span>24</span><span>)</span> SIGXCPU <span>25</span><span>)</span> SIGXFSZ
<span>26</span><span>)</span> SIGVTALRM <span>27</span><span>)</span> SIGPROF <span>28</span><span>)</span> SIGWINCH <span>29</span><span>)</span> SIGIO <span>30</span><span>)</span> SIGPWR
<span>31</span><span>)</span> SIGSYS <span>34</span><span>)</span> SIGRTMIN <span>35</span><span>)</span> SIGRTMIN+1 <span>36</span><span>)</span> SIGRTMIN+2 <span>37</span><span>)</span> SIGRTMIN+3
<span>38</span><span>)</span> SIGRTMIN+4 <span>39</span><span>)</span> SIGRTMIN+5 <span>40</span><span>)</span> SIGRTMIN+6 <span>41</span><span>)</span> SIGRTMIN+7 <span>42</span><span>)</span> SIGRTMIN+8
<span>43</span><span>)</span> SIGRTMIN+9 <span>44</span><span>)</span> SIGRTMIN+10 <span>45</span><span>)</span> SIGRTMIN+11 <span>46</span><span>)</span> SIGRTMIN+12 <span>47</span><span>)</span> SIGRTMIN+13
<span>48</span><span>)</span> SIGRTMIN+14 <span>49</span><span>)</span> SIGRTMIN+15 <span>50</span><span>)</span> SIGRTMAX-14 <span>51</span><span>)</span> SIGRTMAX-13 <span>52</span><span>)</span> SIGRTMAX-12
<span>53</span><span>)</span> SIGRTMAX-11 <span>54</span><span>)</span> SIGRTMAX-10 <span>55</span><span>)</span> SIGRTMAX-9 <span>56</span><span>)</span> SIGRTMAX-8 <span>57</span><span>)</span> SIGRTMAX-7
<span>58</span><span>)</span> SIGRTMAX-6 <span>59</span><span>)</span> SIGRTMAX-5 <span>60</span><span>)</span> SIGRTMAX-4 <span>61</span><span>)</span> SIGRTMAX-3 <span>62</span><span>)</span> SIGRTMAX-2
<span>63</span><span>)</span> SIGRTMAX-1 <span>64</span><span>)</span> SIGRTMAX
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p><code>trap</code> 的命令格式如下。</p>
<div><pre><code><span>trap</span> <span>[</span>动作<span>]</span> <span>[</span>信号1<span>]</span> <span>[</span>信号2<span>]</span> <span>..</span>.
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP: 编号 1，脚本与所在的终端脱离联系。</li>
<li>INT: 编号 2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT: 编号 3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL: 编号 9，该信号用于杀死进程。</li>
<li>TERM: 编号 15，这是 <code>kill</code> 命令发出的默认信号。</li>
<li>EXIT: 编号 0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code> 命令响应 <code>EXIT</code> 信号的写法如下。</p>
<div><pre><code><span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，脚本遇到 <code>EXIT</code> 信号时，就会执行 <code>rm -f &quot;$TMPFILE&quot;</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>trap</span> <span>'rm -f "$TMPFILE"'</span> EXIT

<span>TMPFILE</span><span>=</span><span><span>$(</span>mktemp<span>)</span></span> <span>||</span> <span>exit</span> <span>1</span>
<span>ls</span> /etc <span>></span> <span>$TMPFILE</span>
<span>if</span> <span>grep</span> -qi <span>"kernel"</span> <span>$TMPFILE</span><span>;</span> <span>then</span>
  <span>echo</span> <span>'find'</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，不管是脚本正常执行结束，还是用户按 <code>Ctrl + C</code> 终止，都会产生 <code>EXIT</code> 信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code> 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果 <code>trap</code> 需要触发多条命令，可以封装一个 Bash 函数。</p>
<div><pre><code><span>function</span> <span>egress</span> <span>{</span>
  command1
  command2
  command3
<span>}</span>

<span>trap</span> egress EXIT
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html" target="_blank" rel="noopener noreferrer">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html" target="_blank" rel="noopener noreferrer">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener noreferrer">Sending and Trapping Signals</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令提示符</title>
      <link>https://shimonzhan.com/code/linux/bash/prompt.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/prompt.html</guid>
      <source url="https://shimonzhan.com/rss.xml">命令提示符</source>
      <description>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>

<h2 id="环境变量-ps1" tabindex="-1"> 环境变量 PS1</h2>
<p>命令提示符通常是美元符号 <code>$</code>，对于根用户则是井号 <code>#</code>。这个符号是环境变量 <code>PS1</code> 决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div><pre><code><span>echo</span> <span>$PS1</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后 的 <code>PS1</code>，可以放在用户的 Bash 配置文件 <code>.bashrc</code> 里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>: 响铃，计算机发出一记声音。</li>
<li><code>\d</code>: 以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>: 本机的主机名。</li>
<li><code>\H</code>: 完整的主机名。</li>
<li><code>\j</code>: 运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>: 当前终端设备名。</li>
<li><code>\n</code>: 一个换行符。</li>
<li><code>\r</code>: 一个回车符。</li>
<li><code>\s</code>: Shell 的名称。</li>
<li><code>\t</code>: 24 小时制的 <code>hours:minutes:seconds</code> 格式表示当前时间。</li>
<li><code>\T</code>: 12 小时制的当前时间。</li>
<li><code>\@</code>: 12 小时制的 <code>AM/PM</code> 格式表示当前时间。</li>
<li><code>\A</code>: 24 小时制的 <code>hours:minutes</code> 表示当前时间。</li>
<li><code>\u</code>: 当前用户名。</li>
<li><code>\v</code>: Shell 的版本号。</li>
<li><code>\V</code>: Shell 的版本号和发布号。</li>
<li><code>\w</code>: 当前的工作路径。</li>
<li><code>\W</code>: 当前目录名。</li>
<li><code>\!</code>: 当前命令在命令历史中的编号。</li>
<li><code>\#</code>: 当前 shell 会话中的命令数。</li>
<li><code>\$</code>: 普通用户显示为 <code>$</code> 字符，根用户显示为 <code>#</code> 字符。</li>
<li><code>\[</code>: 非打印字符序列的开始标志。</li>
<li><code>\]</code>: 非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code> 这个提示符定义，显示出来就是 <code>[user@host ~]$</code> (具体的显示内容取决于您的系统)。</p>
<div><pre><code><span>[</span>user@host ~<span>]</span>$ <span>echo</span> <span>$PS1</span>
<span>[</span><span>\</span>u@<span>\</span>h <span>\</span>W<span>]</span><span>\</span>$
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>改写 <code>PS1</code> 变量，就可以改变这个命令提示符。</p>
<div><pre><code>$ <span><span>PS1</span></span><span>=</span><span>"\A \h \$ "</span>
<span>17</span>:33 <span>host</span> $
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>注意，<code>$</code> 后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2 id="颜色" tabindex="-1"> 颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>: 黑色</li>
<li><code>\033[1;30m</code>: 深灰色</li>
<li><code>\033[0;31m</code>: 红色</li>
<li><code>\033[1;31m</code>: 浅红色</li>
<li><code>\033[0;32m</code>: 绿色</li>
<li><code>\033[1;32m</code>: 浅绿色</li>
<li><code>\033[0;33m</code>: 棕色</li>
<li><code>\033[1;33m</code>: 黄色</li>
<li><code>\033[0;34m</code>: 蓝色</li>
<li><code>\033[1;34m</code>: 浅蓝色</li>
<li><code>\033[0;35m</code>: 粉红</li>
<li><code>\033[1;35m</code>: 浅粉色</li>
<li><code>\033[0;36m</code>: 青色</li>
<li><code>\033[1;36m</code>: 浅青色</li>
<li><code>\033[0;37m</code>: 浅灰色</li>
<li><code>\033[1;37m</code>: 白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将 <code>PS1</code> 设成下面的代码。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码 <code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;31m\]&lt;\u@\h \W>\$\[\033[00m\]'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>: 蓝色</li>
<li><code>\033[1;44m</code>: 黑色</li>
<li><code>\033[0;41m</code>: 红色</li>
<li><code>\033[1;45m</code>: 粉红</li>
<li><code>\033[0;42m</code>: 绿色</li>
<li><code>\033[1;46m</code>: 青色</li>
<li><code>\033[0;43m</code>: 棕色</li>
<li><code>\033[1;47m</code>: 浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div><pre><code><span><span>PS1</span></span><span>=</span><span>'\[\033[0;41m\]&lt;\u@\h \W>\$\[\033[0m\] '</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="环境变量-ps2-ps3-ps4" tabindex="-1"> 环境变量 PS2，PS3，PS4</h2>
<p>除了 <code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量 <code>PS2</code> 是命令行折行输入时系统的提示符，默认为 <code>&gt;</code>。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
> world"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令中，输入 <code>hello</code> 以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是 <code>PS2</code> 定义的 <code>&gt;</code>。</p>
<p>环境变量 <code>PS3</code> 是使用 <code>select</code> 命令时，系统输入菜单的提示符。</p>
<p>环境变量 <code>PS4</code> 默认为 <code>+</code>。它是使用 Bash 的 <code>-x</code> 参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本 <code>test.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"hello world"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>使用 <code>-x</code> 参数执行这个脚本。</p>
<div><pre><code>$ <span>bash</span> -x test.sh
+ <span>echo</span> <span>'hello world'</span>
hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，输出的第一行前面有一个 <code>+</code>，这就是变量 <code>PS4</code> 定义的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>引号和转义</title>
      <link>https://shimonzhan.com/code/linux/bash/quotation.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/quotation.html</guid>
      <source url="https://shimonzhan.com/rss.xml">引号和转义</source>
      <description>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。</p>

<h2 id="转义" tabindex="-1"> 转义</h2>
<p>某些字符在 Bash 里面有特殊含义(比如<code>$</code>、<code>&amp;</code>、<code>*</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>$date</span>

$
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，输出 <code>$date</code> 不会有任何结果，因为 <code>$</code> 是一个特殊字符。</p>
<p>如果想要原样输出这些特殊字符，就必须在它们前面加上反斜杠，使其变成普通字符。这就叫做“转义”(escape)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>$date</span>
<span>$date</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令中，只有在特殊字符 <code>$</code> 前面加反斜杠，才能原样输出。</p>
<p>反斜杠本身也是特殊字符，如果想要原样输出反斜杠，就需要对它自身转义，连续使用两个反斜线 (<code>\\</code>)。</p>
<div><pre><code>$ <span>echo</span> <span>\</span><span>\</span>
<span>\</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子输出了反斜杠本身。</p>
<p>反斜杠除了用于转义，还可以表示一些不可打印的字符。</p>
<ul>
<li><code>\a</code>: 响铃</li>
<li><code>\b</code>: 退格</li>
<li><code>\n</code>: 换行</li>
<li><code>\r</code>: 回车</li>
<li><code>\t</code>: 制表符</li>
</ul>
<p>如果想要在命令行使用这些不可打印的字符，可以把它们放在引号里面，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<div><pre><code>$ <span>echo</span> a<span>\</span>tb
atb

$ <span>echo</span> -e <span>"a<span title="\t">\t</span>b"</span>
a        b
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，命令行直接输出不可打印字符，Bash 不能正确解释。必须把它们放在引号之中，然后使用 <code>echo</code> 命令的 <code>-e</code> 参数。</p>
<p>由于反斜杠可以对换行符转义，使得 Bash 认为换行符是一个普通字符，从而可以将一行命令写成多行。</p>
<div><pre><code>$ <span>mv</span> <span>\</span>
/path/to/foo <span>\</span>
/path/to/bar

<span># 等同于</span>
$ <span>mv</span> /path/to/foo /path/to/bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果一条命令过长，就可以在行尾使用反斜杠，将其改写成多行。这是常见的多行命令的写法。</p>
<h2 id="单引号" tabindex="-1"> 单引号</h2>
<p>Bash 允许字符串放在单引号或双引号之中，加以引用。</p>
<p>单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符，比如星号 (<code>*</code>)、美元符号( <code>$</code>)、反斜杠 (<code>\</code>)等。</p>
<div><pre><code>$ <span>echo</span> <span>'*'</span>
*

$ <span>echo</span> <span>'$USER'</span>
<span>$USER</span>

$ <span>echo</span> <span>'$((2+2))'</span>
<span><span>$((</span><span>2</span><span>+</span><span>2</span><span>))</span></span>

$ <span>echo</span> <span>'$(echo foo)'</span>
<span><span>$(</span><span>echo</span> foo<span>)</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面命令中，单引号使得 Bash 扩展、变量引用、算术运算和子命令，都失效了。如果不使用单引号，它们都会被 Bash 自动扩展。</p>
<p>由于反斜杠在单引号里面变成了普通字符，所以如果单引号之中，还要使用单引号，不能使用转义，需要在外层的单引号前面加上一个美元符号 (<code>$</code>)，然后再对里层的单引号转义。</p>
<div><pre><code><span># 不正确</span>
$ <span>echo</span> it<span>'s

# 不正确
$ echo '</span>it<span>\</span>'s<span>'

# 正确
$ echo $'</span>it<span>\</span>'s'
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>不过，更合理的方法是改在双引号之中使用单引号。</p>
<div><pre><code>$ <span>echo</span> <span>"it's"</span>
it's
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><h2 id="双引号" tabindex="-1"> 双引号</h2>
<p>双引号比单引号宽松，可以保留大部分特殊字符的本来含义，但是三个字符除外: 美元符号(<code>$</code>)、反引号(<code>`</code>)和反斜杠(<code>\</code>)。也就是说，这三个字符在双引号之中，会被 Bash 自动扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"*"</span>
*
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，通配符 <code>*</code> 放在双引号之中，就变成了普通字符，会原样输出。这一点需要特别留意，双引号里面不会进行文件名扩展。</p>
<div><pre><code>$ <span>echo</span> <span>"<span>$SHELL</span>"</span>
/bin/bash

$ <span>echo</span> <span>"<span><span>`</span><span>date</span><span>`</span></span>"</span>
Mon Jan <span>27</span> <span>13</span>:33:18 CST <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，美元符号和反引号在双引号中，都保持特殊含义。美元符号用来引用变量，反引号则是执行子命令。</p>
<div><pre><code>$ <span>echo</span> <span>"I'd say: <span title="\&quot;">\"</span>hello!<span title="\&quot;">\"</span>"</span>
I'd say: <span>"hello!"</span>

$ <span>echo</span> <span>"<span title="\\">\\</span>"</span>
<span>\</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，反斜杠在双引号之中保持特殊含义，用来转义。所以，可以使用反斜杠，在双引号之中插入双引号，或者插入反斜杠本身。</p>
<p>由于双引号将换行符解释为普通字符，所以可以利用双引号，在命令行输入多行文本。</p>
<div><pre><code>$ <span>echo</span> <span>"hello
world"</span>
hello
world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面命令中，Bash 正常情况下会将换行符解释为命令结束，但是换行符在双引号之中就是普通字符，所以可以输入多行。<code>echo</code> 命令会将换行符原样输出，显示的时候正常解释为换行。</p>
<p>双引号的另一个常见的使用场合是，文件名包含空格。这时就必须使用双引号，将文件名放在里面。</p>
<div><pre><code><span>ls</span> <span>"two words.txt"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>two words.txt</code> 是一个包含空格的文件名，否则就会被 Bash 当作两个文件。</p>
<p>双引号会原样保存多余的空格。</p>
<div><pre><code>$ <span>echo</span> <span>"this is a     test"</span>
this is a     <span>test</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>双引号还有一个作用，就是保存原始命令的输出格式。</p>
<div><pre><code><span># 单行输出</span>
$ <span>echo</span> <span><span>$(</span><span>cal</span><span>)</span></span>
一月 <span>2020</span> 日 一 二 三 四 五 六 <span>1</span> <span>2</span> <span>3</span> <span>..</span>. <span>31</span>

<span># 原始格式输出</span>
$ <span>echo</span> <span>"<span><span>$(</span><span>cal</span><span>)</span></span>"</span>
      一月 <span>2020</span>
日 一 二 三 四 五 六
          <span>1</span>  <span>2</span>  <span>3</span>  <span>4</span>
 <span>5</span>  <span>6</span>  <span>7</span>  <span>8</span>  <span>9</span> <span>10</span> <span>11</span>
<span>12</span> <span>13</span> <span>14</span> <span>15</span> <span>16</span> <span>17</span> <span>18</span>
<span>19</span> <span>20</span> <span>21</span> <span>22</span> <span>23</span> <span>24</span> <span>25</span>
<span>26</span> <span>27</span> <span>28</span> <span>29</span> <span>30</span> <span>31</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果 <code>$(cal)</code> 不放在双引号之中，<code>echo</code> 就会将所有结果以单行输出，丢弃了所有原始的格式。</p>
<h2 id="here-文档" tabindex="-1"> Here 文档</h2>
<p>Here 文档(here document)是一种输入多行字符串的方法，格式如下。</p>
<div><pre><code><span>&lt;&lt;</span> <span>token
text
token</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>它的格式分成开始标记(<code>&lt;&lt; token</code>)和结束标记(<code>token</code>)。开始标记是两个小于号 + Here 文档的名称，名称可以随意取，后面必须是一个换行符；结束标记是单独一行顶格写的 Here 文档名称，如果不是顶格，结束标记不起作用。两者之间就是多行字符串的内容。</p>
<p>下面是一个通过 Here 文档输出 HTML 代码的例子。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;</span> <span>_EOF_
&lt;html>
&lt;head>
    &lt;title>
    The title of your page
    &lt;/title>
&lt;/head>

&lt;body>
    Your page content goes here.
&lt;/body>
&lt;/html>
_EOF_</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>_example_
<span>$foo</span>
"<span>$foo</span>"
'<span>$foo</span>'
_example_</span>

hello world
<span>"hello world"</span>
<span>'hello world'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>$foo</code> 发生了替换，但是双引号和单引号都原样输出了，表明它们已经失去了引用的功能。</p>
<p>如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>'hello world'</span>
$ <span>cat</span> <span>&lt;&lt;</span> <span>'_example_'
$foo
"$foo"
'$foo'
_example_</span>

<span>$foo</span>
<span>"<span>$foo</span>"</span>
<span>'$foo'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，Here 文档的开始标记(<code>_example_</code>)放在单引号之中，导致变量替换失效了。</p>
<p>Here 文档的本质是重定向，它将字符串重定向输出给某个命令，相当于包含了 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>command</span> <span>&lt;&lt;</span> <span>token
  string
token</span>

<span># 等同于</span>

$ <span>echo</span> string <span>|</span> <span>command</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，Here 文档相当于 <code>echo</code> 命令的重定向。</p>
<p>所以，Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如 <code>echo</code> 命令就不能用 Here 文档作为参数。</p>
<div><pre><code>$ <span>echo</span> <span>&lt;&lt;</span> <span>_example_
hello
_example_</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子不会有任何输出，因为 Here 文档对于 <code>echo</code> 命令无效。</p>
<p>此外，Here 文档也不能作为变量的值，只能用于命令的参数。</p>
<h2 id="here-字符串" tabindex="-1"> Here 字符串</h2>
<p>Here 文档还有一个变体，叫做 Here 字符串(Here string)，使用三个小于号(<code>&lt;&lt;&lt;</code>)表示。</p>
<div><pre><code><span>&lt;&lt;&lt;</span> string
</code></pre><div aria-hidden="true"><div></div></div></div><p>它的作用是将字符串通过标准输入，传递给命令。</p>
<p>有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，比如 <code>cat</code> 命令只接受标准输入传入的字符串。</p>
<div><pre><code>$ <span>cat</span> <span>&lt;&lt;&lt;</span> <span>'hi there'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'hi there'</span> <span>|</span> <span>cat</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的第一种语法使用了 Here 字符串，要比第二种语法看上去语义更好，也更简洁。</p>
<div><pre><code>$ md5sum <span>&lt;&lt;&lt;</span> <span>'ddd'</span>
<span># 等同于</span>
$ <span>echo</span> <span>'ddd'</span> <span>|</span> md5sum
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>md5sum</code> 命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，即 <code>md5sum ddd</code> 里面的 <code>ddd</code> 会被解释成文件名。这时就可以用 Here 字符串，将字符串传给 <code>md5sum</code> 命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>read 命令</title>
      <link>https://shimonzhan.com/code/linux/bash/read.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/read.html</guid>
      <source url="https://shimonzhan.com/rss.xml">read 命令</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="用法" tabindex="-1"> 用法</h2>
<p>有时，脚本需要在执行过程中，由用户提供一部分数据，这时可以使用 <code>read</code> 命令。它将用户的输入存入一个变量，方便后面的代码使用。用户按下回车键，就表示输入结束。</p>
<p><code>read</code> 命令的格式如下。</p>
<div><pre><code><span>read</span> <span>[</span>-options<span>]</span> <span>[</span>variable<span>..</span>.<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法中，<code>options</code> 是参数选项，<code>variable</code> 是用来保存输入数值的一个或多个变量名。如果没有提供变量名，环境变量 <code>REPLY</code> 会包含用户输入的一整行数据。</p>
<p>下面是一个例子 <code>demo.sh</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>read</span> text
<span>echo</span> <span>"您的输入: <span>$text</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，先显示一行提示文本，然后会等待用户输入文本。用户输入的文本，存入变量 <code>text</code>，在下一行显示出来。</p>
<div><pre><code>$ <span>bash</span> demo.sh
输入一些文本 <span>></span> 您好，世界
您的输入: 您好，世界
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>read</code> 可以接受用户输入的多个值。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>echo</span> Please, enter your firstname and lastname
<span>read</span> FN LN
<span>echo</span> <span>"Hi! <span>$LN</span>, <span>$FN</span> !"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>read</code> 根据用户的输入，同时为两个变量赋值。</p>
<p>如果用户的输入项少于 <code>read</code> 命令给出的变量数目，那么额外的变量值为空。如果用户的输入项多于定义的变量，那么多余的输入项会包含到最后一个变量中。</p>
<p>如果 <code>read</code> 命令之后没有定义变量名，那么环境变量 <code>REPLY</code> 会包含所有的输入。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-single: read multiple values into default variable</span>
<span>echo</span> -n <span>"Enter one or more values > "</span>
<span>read</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本的运行结果如下。</p>
<div><pre><code>$ read-single
Enter one or <span>more</span> values <span>></span> a b c d
<span>REPLY</span> <span>=</span> <span>'a b c d'</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>read</code> 命令除了读取键盘输入，可以用来读取文件。</p>
<div><pre><code><span>while</span> <span>read</span> myline
<span>do</span>
  <span>echo</span> <span>"<span>$myline</span>"</span>
<span>done</span> <span>&lt;</span> <span>$filename</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的例子通过 <code>read</code> 命令，读取一个文件的内容。<code>done</code> 命令后面的定向符 <code>&lt;</code>，将文件导向 <code>read</code> 命令，每次读取一行，存入变量 <code>myline</code>，直到文件读取完毕。</p>
<h2 id="参数" tabindex="-1"> 参数</h2>
<p><code>read</code> 命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-t</code> 参数</strong></p>
<p><code>read</code> 命令的 <code>-t</code> 参数，设置了超时的秒数。如果超过了指定时间，用户仍然没有输入，脚本将放弃等待，继续向下执行。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> -n <span>"输入一些文本 > "</span>
<span>if</span> <span>read</span> -t <span>3</span> response<span>;</span> <span>then</span>
  <span>echo</span> <span>"用户已经输入了"</span>
<span>else</span>
  <span>echo</span> <span>"用户没有输入"</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，输入命令会等待 3 秒，如果用户超过这个时间没有输入，这个命令就会执行失败。<code>if</code> 根据命令的返回值，转入 <code>else</code> 代码块，继续往下执行。</p>
<p>环境变量 <code>TMOUT</code> 也可以起到同样作用，指定 <code>read</code> 命令等待用户输入的时间(单位为秒)。</p>
<div><pre><code><span>TMOUT</span><span>=</span><span>3</span>
<span>read</span> response
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子也是等待 3 秒，如果用户还没有输入，就会超时。</p>
</li>
<li>
<p><strong><code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数指定用户输入的提示信息。</p>
<div><pre><code><span>read</span> -p <span>"Enter one or more values > "</span>
<span>echo</span> <span>"REPLY = '<span>$REPLY</span>'"</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，先显示 <code>Enter one or more values &gt;</code>，再接受用户的输入。</p>
</li>
<li>
<p><strong><code>-a</code> 参数</strong></p>
<p><code>-a</code> 参数把用户的输入赋值给一个数组，从零号位置开始。</p>
<div><pre><code>$ <span>read</span> -a people
alice duchess dodo
$ <span>echo</span> <span>${people<span>[</span>2<span>]</span>}</span>
dodo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，用户输入被赋值给一个数组 <code>people</code>，这个数组的 2 号成员就是 <code>dodo</code>。</p>
</li>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 参数指定只读取若干个字符作为变量值，而不是整行读取。</p>
<div><pre><code>$ <span>read</span> -n <span>3</span> letter
abcdefghij
$ <span>echo</span> <span>$letter</span>
abc
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>letter</code> 只包含 3 个字母。</p>
</li>
<li>
<p><strong>-e 参数</strong></p>
<p><code>-e</code> 参数允许用户输入的时候，使用 <code>readline</code> 库提供的快捷键，比如自动补全。具体的快捷键可以参阅《行操作》一章。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> Please input the path to the file:

<span>read</span> -e fileName

<span>echo</span> <span>$fileName</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>read</code> 命令接受用户输入的文件名。这时，用户可能想使用 Tab 键的文件名“自动补全”功能，但是 <code>read</code> 命令的输入默认不支持 <code>readline</code> 库的功能。<code>-e</code> 参数就可以允许用户使用自动补全。</p>
</li>
<li>
<p><strong>其他参数</strong></p>
<ul>
<li><code>-d delimiter</code>: 定义字符串 <code>delimiter</code> 的第一个字符作为用户输入的结束，而不是一个换行符。</li>
<li><code>-r</code>: raw 模式，表示不把用户输入的反斜杠字符解释为转义字符。</li>
<li><code>-s</code>: 使得用户的输入不显示在屏幕上，这常常用于输入密码或保密信息。</li>
<li><code>-u fd</code>: 使用文件描述符 <code>fd</code> 作为输入。</li>
</ul>
</li>
</ol>
<h2 id="ifs-变量" tabindex="-1"> IFS 变量</h2>
<p><code>read</code> 命令读取的值，默认是以空格分隔。可以通过自定义环境变量 <code>IFS</code>(内部字段分隔符，Internal Field Separator 的缩写)，修改分隔标志。</p>
<p><code>IFS</code> 的默认值是空格、Tab 符号、换行符号，通常取第一个(即空格)。</p>
<p>如果把 <code>IFS</code> 定义成冒号(<code>:</code>)或分号(<code>;</code>)，就可以分隔以这两个符号分隔的值，这对读取文件很有用。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># read-ifs: read fields from a file</span>

<span>FILE</span><span>=</span>/etc/passwd

<span>read</span> -p <span>"Enter a username > "</span> user_name
<span>file_info</span><span>=</span><span>"<span><span>$(</span><span>grep</span> <span>"^<span>$user_name</span>:"</span> $FILE<span>)</span></span>"</span>

<span>if</span> <span>[</span> -n <span>"<span>$file_info</span>"</span> <span>]</span><span>;</span> <span>then</span>
  <span><span>IFS</span></span><span>=</span><span>":"</span> <span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
  <span>echo</span> <span>"User = '<span>$user</span>'"</span>
  <span>echo</span> <span>"UID = '<span>$uid</span>'"</span>
  <span>echo</span> <span>"GID = '<span>$gid</span>'"</span>
  <span>echo</span> <span>"Full Name = '<span>$name</span>'"</span>
  <span>echo</span> <span>"Home Dir. = '<span>$home</span>'"</span>
  <span>echo</span> <span>"Shell = '<span>$shell</span>'"</span>
<span>else</span>
  <span>echo</span> <span>"No such user '<span>$user_name</span>'"</span> <span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>IFS</code> 设为冒号，然后用来分解 <code>/etc/passwd</code> 文件的一行。<code>IFS</code> 的赋值命令和 <code>read</code> 命令写在一行，这样的话，<code>IFS</code> 的改变仅对后面的命令生效，该命令执行后 <code>IFS</code> 会自动恢复原来的值。如果不写在一行，就要采用下面的写法。</p>
<div><pre><code><span>OLD_IFS</span><span>=</span><span>"<span>$IFS</span>"</span>
<span><span>IFS</span></span><span>=</span><span>":"</span>
<span>read</span> user pw uid gid name home shell <span>&lt;&lt;&lt;</span> <span>"<span>$file_info</span>"</span>
<span><span>IFS</span></span><span>=</span><span>"<span>$OLD_IFS</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>另外，上面例子中，<code>&lt;&lt;&lt;</code> 是 Here 字符串，用于将变量值转为标准输入，因为 <code>read</code> 命令只能解析标准输入。</p>
<p>如果 <code>IFS</code> 设为空字符串，就等同于将整行读入一个变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>input</span><span>=</span><span>"/path/to/txt/file"</span>
<span>while</span> <span><span>IFS</span></span><span>=</span> <span>read</span> -r line
<span>do</span>
  <span>echo</span> <span>"<span>$line</span>"</span>
<span>done</span> <span>&lt;</span> <span>"<span>$input</span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的命令可以逐行读取文件，每一行存入变量 <code>line</code>，打印出来以后再读取下一行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 行操作</title>
      <link>https://shimonzhan.com/code/linux/bash/readline.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/readline.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 行操作</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="简介" tabindex="-1"> 简介</h2>
<p>Bash 内置了 Readline 库，具有这个库提供的很多“行操作”功能，比如命令的自动补全，可以大大加快操作速度。</p>
<p>这个库默认采用 Emacs 快捷键，也可以改成 Vi 快捷键。</p>
<div><pre><code><span>set</span> -o <span>vi</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>下面的命令可以改回 Emacs 快捷键。</p>
<div><pre><code><span>set</span> -o emacs
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果想永久性更改编辑模式(Emacs / Vi)，可以将命令写在 <code>~/.inputrc</code> 文件，这个文件是 Readline 的配置文件。</p>
<div><pre><code><span>set</span> editing-mode <span>vi</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>本章介绍的快捷键都属于 Emacs 模式。Vi 模式的快捷键，读者可以参考 Vi 编辑器的教程。</p>
<p>Bash 默认开启这个库，但是允许关闭。</p>
<div><pre><code><span>bash</span> --noediting
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>--noediting</code> 参数关闭了 Readline 库，启动的 Bash 就不带有行操作功能。</p>
<h2 id="光标移动" tabindex="-1"> 光标移动</h2>
<p>Readline 提供快速移动光标的快捷键。</p>
<ul>
<li><code>Ctrl + a</code>: 移到行首。</li>
<li><code>Ctrl + b</code>: 向行首移动一个字符，与左箭头作用相同。</li>
<li><code>Ctrl + e</code>: 移到行尾。</li>
<li><code>Ctrl + f</code>: 向行尾移动一个字符，与右箭头作用相同。</li>
<li><code>Alt + f</code>: 移动到当前单词的词尾。</li>
<li><code>Alt + b</code>: 移动到当前单词的词首。</li>
</ul>
<p>上面快捷键的 Alt 键，也可以用 ESC 键代替。</p>
<h2 id="清除屏幕" tabindex="-1"> 清除屏幕</h2>
<p><code>Ctrl + l</code> 快捷键可以清除屏幕，即将当前行移到屏幕的第一行，与 <code>clear</code> 命令作用相同。</p>
<h2 id="编辑操作" tabindex="-1"> 编辑操作</h2>
<p>下面的快捷键可以编辑命令行内容。</p>
<ul>
<li><code>Ctrl + d</code>: 删除光标位置的字符(delete)。</li>
<li><code>Ctrl + w</code>: 删除光标前面的单词。</li>
<li><code>Ctrl + t</code>: 光标位置的字符与它前面一位的字符交换位置(transpose)。</li>
<li><code>Alt + t</code>: 光标位置的词与它前面一位的词交换位置(transpose)。</li>
<li><code>Alt + l</code>: 将光标位置至词尾转为小写(lowercase)。</li>
<li><code>Alt + u</code>: 将光标位置至词尾转为大写(uppercase)。</li>
</ul>
<p>使用 <code>Ctrl + d</code> 的时候，如果当前行没有任何字符，会导致退出当前 Shell，所以要小心。</p>
<p>剪切和粘贴快捷键如下。</p>
<ul>
<li><code>Ctrl + k</code>: 剪切光标位置到行尾的文本。</li>
<li><code>Ctrl + u</code>: 剪切光标位置到行首的文本。</li>
<li><code>Alt + d</code>: 剪切光标位置到词尾的文本。</li>
<li><code>Alt + Backspace</code>: 剪切光标位置到词首的文本。</li>
<li><code>Ctrl + y</code>: 在光标位置粘贴文本。</li>
</ul>
<p>同样地，Alt 键可以用 Esc 键代替。</p>
<h2 id="自动补全" tabindex="-1"> 自动补全</h2>
<p>命令输入到一半的时候，可以按一下 Tab 键，Readline 会自动补全命令或路径。比如，输入 <code>cle</code>，再按下 Tab 键，Bash 会自动将这个命令补全为 <code>clear</code>。</p>
<p>如果符合条件的命令或路径有多个，就需要连续按两次 Tab 键，Bash 会提示所有符合条件的命令或路径。</p>
<p>除了命令或路径，Tab 还可以补全其他值。如果一个值以 <code>$</code> 开头，则按下 Tab 键会补全变量；如果以 <code>~</code> 开头，则补全用户名；如果以 <code>@</code> 开头，则补全主机名(hostname)，主机名以列在 <code>/etc/hosts</code> 文件里面的主机为准。</p>
<p>自动补全相关的快捷键如下。</p>
<ul>
<li>Tab: 完成自动补全。</li>
<li><code>Alt + ?</code>: 列出可能的补全，与连按两次 Tab 键作用相同。</li>
<li><code>Alt + /</code>: 尝试文件路径补全。</li>
<li><code>Ctrl + x /</code>: 先按 <code>Ctrl + x</code>，再按 <code>/</code>，等同于 <code>Alt + ?</code>，列出可能的文件路径补全。</li>
<li><code>Alt + !</code>: 命令补全。</li>
<li><code>Ctrl + x !</code>: 先按 <code>Ctrl + x</code>，再按 <code>!</code>，等同于 <code>Alt + !</code>，命令补全。</li>
<li><code>Alt + ~</code>: 用户名补全。</li>
<li><code>Ctrl + x ~</code>: 先按 <code>Ctrl + x</code>，再按 <code>~</code>，等同于 <code>Alt + ~</code>，用户名补全。</li>
<li><code>Alt + $</code>: 变量名补全。</li>
<li><code>Ctrl + x $</code>: 先按 <code>Ctrl + x</code>，再按 <code>$</code>，等同于 <code>Alt + $</code>，变量名补全。</li>
<li><code>Alt + @</code>: 主机名补全。</li>
<li><code>Ctrl + x @</code>: 先按 <code>Ctrl + x</code>，再按 <code>@</code>，等同于 <code>Alt + @</code>，主机名补全。</li>
<li><code>Alt + *</code>: 在命令行一次性插入所有可能的补全。</li>
<li><code>Alt + Tab</code>: 尝试用 <code>.bash_history</code> 里面以前执行命令，进行补全。</li>
</ul>
<p>上面的 <code>Alt</code> 键也可以用 ESC 键代替。</p>
<h2 id="操作历史" tabindex="-1"> 操作历史</h2>
<h3 id="基本用法" tabindex="-1"> 基本用法</h3>
<p>Bash 会保留用户的操作历史，即用户输入的每一条命令都会记录。退出当前 Shell 的时候，Bash 会将用户在当前 Shell 的操作历史写入 <code>~/.bash_history</code> 文件，该文件默认储存 500 个操作。</p>
<p>环境变量 <code>HISTFILE</code> 总是指向这个文件。</p>
<div><pre><code>$ <span>echo</span> <span>$HISTFILE</span>
/home/me/.bash_history
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>有了操作历史以后，就可以使用方向键的 <code>↑</code> 和 <code>↓</code>，快速浏览上一条和下一条命令。</p>
<p>下面的方法可以快速执行以前执行过的命令。</p>
<div><pre><code>$ <span>echo</span> Hello World
Hello World

$ <span>echo</span> Goodbye
Goodbye

$ <span>!</span>e
<span>echo</span> Goodbye
Goodbye
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>!e</code> 表示找出操作历史之中，最近的那一条以 <code>e</code> 开头的命令并执行。Bash 会先输出那一条命令 <code>echo Goodbye</code>，然后直接执行。</p>
<p>同理，<code>!echo</code> 也会执行最近一条以 <code>echo</code> 开头的命令。</p>
<div><pre><code>$ <span>!</span>echo
<span>echo</span> Goodbye
Goodbye

$ <span>!</span>echo H
<span>echo</span> Goodbye H
Goodbye H

$ <span>!</span>echo H G
<span>echo</span> Goodbye H G
Goodbye H G
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>!string</code> 语法只会匹配命令，不会匹配参数。所以 <code>!echo H</code> 不会执行 <code>echo Hello World</code>，而是会执行 <code>echo Goodbye</code>，并把参数 <code>H</code> 附加在这条命令之后。同理，<code>!echo H G</code> 也是等同于 <code>echo Goodbye</code> 命令之后附加 <code>H G</code>。</p>
<p>最后，按下 <code>Ctrl + r</code> 会显示操作历史，可以用方向键上下移动，选择其中要执行的命令。也可以键入命令的首字母，Shell 就会自动在历史文件中，查询并显示匹配的结果。</p>
<h3 id="history-命令" tabindex="-1"> history 命令</h3>
<p><code>history</code> 命令能显示操作历史，即 <code>.bash_history</code> 文件的内容。</p>
<div><pre><code>$ <span>history</span>
<span>..</span>.
<span>498</span> <span>echo</span> Goodbye
<span>499</span> <span>ls</span> ~
<span>500</span> <span>cd</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>使用该命令，而不是直接读取 <code>.bash_history</code> 文件的好处是，它会在所有的操作前加上行号，最近的操作在最后面，行号最大。</p>
<p>通过定制环境变量 <code>HISTTIMEFORMAT</code>，可以显示每个操作的时间。</p>
<div><pre><code>$ <span>export</span> <span>HISTTIMEFORMAT</span><span>=</span><span>'%F %T  '</span>
$ <span>history</span>
<span>1</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>cat</span> /etc/issue
<span>2</span>  <span>2013</span>-06-09 <span>10</span>:40:12   <span>clear</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>%F</code> 相当于 <code>%Y - %m - %d</code>，<code>%T</code> 相当于 <code>%H : %M : %S</code>。</p>
<p>只要设置 <code>HISTTIMEFORMAT</code> 这个环境变量，就会在 <code>.bash_history</code> 文件保存命令的执行时间戳。如果不设置，就不会保存时间戳。</p>
<p>如果不希望保存本次操作的历史，可以设置环境变量 <code>HISTSIZE</code> 等于 0。</p>
<div><pre><code><span>export</span> <span><span>HISTSIZE</span></span><span>=</span><span>0</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>如果 <code>HISTSIZE=0</code> 写入用户主目录的 <code>~/.bashrc</code> 文件，那么就不会保留该用户的操作历史。如果写入 <code>/etc/profile</code>，整个系统都不会保留操作历史。</p>
<p>如果想搜索某个以前执行的命令，可以配合 <code>grep</code> 命令搜索操作历史。</p>
<div><pre><code><span>history</span> <span>|</span> <span>grep</span> /usr/bin
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令返回 <code>.bash_history</code> 文件里面，那些包含 <code>/usr/bin</code> 的命令。</p>
<p>操作历史的每一条记录都有编号。知道了命令的编号以后，可以用 <code>感叹号 + 编号</code> 执行该命令。如果想要执行 <code>.bash_history</code> 里面的第 8 条命令，可以像下面这样操作。</p>
<div><pre><code><span>!</span><span>8</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>history</code> 命令的 <code>-c</code> 参数可以清除操作历史。</p>
<div><pre><code><span>history</span> -c
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="相关快捷键" tabindex="-1"> 相关快捷键</h3>
<p>下面是一些与操作历史相关的快捷键。</p>
<ul>
<li><code>Ctrl + p</code>: 显示上一个命令，与向上箭头效果相同(previous)。</li>
<li><code>Ctrl + n</code>: 显示下一个命令，与向下箭头效果相同(next)。</li>
<li><code>Alt + &lt;</code>: 显示第一个命令。</li>
<li><code>Alt + &gt;</code>: 显示最后一个命令，即当前的命令。</li>
<li><code>Ctrl + o</code>: 执行历史文件里面的当前条目，并自动显示下一条命令。这对重复执行某个序列的命令很有帮助。</li>
</ul>
<p>感叹号<code>!</code>的快捷键如下。</p>
<ul>
<li><code>!!</code>: 执行上一个命令。</li>
<li><code>!n</code>: 执行历史文件里面行号为 <code>n</code> 的命令。</li>
<li><code>!-n</code>: 执行当前命令之前 <code>n</code> 条的命令。</li>
<li><code>!string</code>: 执行最近一个以指定字符串 <code>string</code> 开头的命令。</li>
<li><code>!?string</code>: 执行最近一条包含字符串 <code>string</code> 的命令。</li>
<li><code>^string1^string2</code>: 执行最近一条包含 <code>string1</code> 的命令，将其替换成 <code>string2</code>。</li>
</ul>
<h2 id="其他快捷键" tabindex="-1"> 其他快捷键</h2>
<ul>
<li><code>Ctrl + j</code>: 等同于回车键(LINEFEED)。</li>
<li><code>Ctrl + m</code>: 等同于回车键(CARRIAGE RETURN)。</li>
<li><code>Ctrl + o</code>: 等同于回车键，并展示操作历史的下一个命令。</li>
<li><code>Ctrl + v</code>: 将下一个输入的特殊字符变成字面量，比如回车变成 <code>^M</code>。</li>
<li><code>Ctrl + [</code>: 等同于 ESC。</li>
<li><code>Alt + .</code>: 插入上一个命令的最后一个词。</li>
<li><code>Alt + _</code>: 等同于 <code>Alt + .</code>。</li>
</ul>
<p>上面的 <code>Alt + .</code> 快捷键，对于很长的文件路径，有时会非常方便。因为 Unix 命令的最后一个参数通常是文件路径。</p>
<div><pre><code><span>mkdir</span> foo_bar
<span>cd</span> <span>#按下 Alt + .</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，在 <code>cd</code> 命令后按下 <code>Alt + .</code>，就会自动插入 <code>foo_bar</code>。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 脚本入门</title>
      <link>https://shimonzhan.com/code/linux/bash/script.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/script.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 脚本入门</source>
      <description>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。
脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>脚本(script)就是包含一系列命令的一个文本文件。Shell 读取这个文件，依次执行里面的所有命令，就好像这些命令直接输入到命令行一样。所有能够在命令行完成的任务，都能够用脚本完成。</p>
<p>脚本的好处是可以重复使用，也可以指定在特定场合自动调用，比如系统启动或关闭时自动执行脚本。</p>

<h2 id="shebang-行" tabindex="-1"> Shebang 行</h2>
<p>脚本的第一行通常是指定解释器，即这个脚本必须通过什么解释器执行。这一行以 <code>#!</code> 字符开头，这个字符称为 Shebang，所以这一行就叫做 Shebang 行。</p>
<p><code>#!</code> 后面就是脚本解释器的位置，Bash 脚本的解释器一般是 <code>/bin/sh</code> 或 <code>/bin/bash</code>。</p>
<div><pre><code><span>#!/bin/sh</span>
<span># 或者</span>
<span>#!/bin/bash</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><code>#!</code> 与脚本解释器之间有没有空格，都是可以的。</p>
<p>如果 Bash 解释器不放在目录 <code>/bin</code>，脚本就无法执行了。为了保险，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令使用 <code>env</code> 命令(这个命令总是在 <code>/usr/bin</code> 目录)，返回 Bash 可执行文件的位置。<code>env</code> 命令的详细介绍，请看后文。</p>
<p>Shebang 行不是必需的，但是建议加上这行。如果缺少该行，就需要手动将脚本传给解释器。举例来说，脚本是 <code>script.sh</code>，有 Shebang 行的时候，可以直接调用执行。</p>
<div><pre><code>./script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，<code>script.sh</code> 是脚本文件名。脚本通常使用 <code>.sh</code> 后缀名，不过这不是必需的。</p>
<p>如果没有 Shebang 行，就只能手动将脚本传给解释器来执行。</p>
<div><pre><code>$ /bin/sh ./script.sh
<span># 或者</span>
$ <span>bash</span> ./script.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="执行权限和路径" tabindex="-1"> 执行权限和路径</h2>
<p>前面说过，只要指定了 Shebang 行的脚本，可以直接执行。这有一个前提条件，就是脚本需要有执行权限。可以使用下面的命令，赋予脚本执行权限。</p>
<div><pre><code><span># 给所有用户执行权限</span>
$ <span>chmod</span> +x script.sh

<span># 给所有用户读权限和执行权限</span>
$ <span>chmod</span> +rx script.sh
<span># 或者</span>
$ <span>chmod</span> <span>755</span> script.sh

<span># 只给脚本拥有者读权限和执行权限</span>
$ <span>chmod</span> u+rx script.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>脚本的权限通常设为 <code>755</code> (拥有者有所有权限，其他人有读和执行权限)或者 <code>700</code>(只有拥有者可以执行)。</p>
<p>除了执行权限，脚本调用时，一般需要指定脚本的路径(比如 <code>path/script.sh</code>)。如果将脚本放在环境变量 <code>$PATH</code> 指定的目录中，就不需要指定路径了。因为 Bash 会自动到这些目录中，寻找是否存在同名的可执行文件。</p>
<p>建议在主目录新建一个 <code>~/bin</code> 子目录，专门存放可执行脚本，然后把 <code>~/bin</code> 加入 <code>$PATH</code>。</p>
<div><pre><code><span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span>:~/bin
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令改变环境变量 <code>$PATH</code>，将 <code>~/bin</code> 添加到 <code>$PATH</code> 的末尾。可以将这一行加到 <code>~/.bashrc</code> 文件里面，然后重新加载一次 <code>.bashrc</code>，这个配置就可以生效了。</p>
<div><pre><code><span>source</span> ~/.bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><p>以后不管在什么目录，直接输入脚本文件名，脚本就会执行。</p>
<div><pre><code>script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令没有指定脚本路径，因为 <code>script.sh</code> 在 <code>$PATH</code> 指定的目录中。</p>
<h2 id="env-命令" tabindex="-1"> env 命令</h2>
<p><code>env</code> 命令总是指向 <code>/usr/bin/env</code> 文件，或者说，这个二进制文件总是在目录 <code>/usr/bin</code>。</p>
<p><code>#!/usr/bin/env NAME</code> 这个语法的意思是，让 Shell 查找 <code>$PATH</code> 环境变量里面第一个匹配的 <code>NAME</code>。如果您不知道某个命令的具体路径，或者希望兼容其他用户的机器，这样的写法就很有用。</p>
<p><code>/usr/bin/env bash</code> 的意思就是，返回 <code>bash</code> 可执行文件的位置，前提是 <code>bash</code> 的路径是在 <code>$PATH</code> 里面。其他脚本文件也可以使用这个命令。比如 Node.js 脚本的 Shebang 行，可以写成下面这样。</p>
<div><pre><code><span>#!/usr/bin/env node</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>env</code> 命令的参数如下。</p>
<ul>
<li><code>-i</code>, <code>--ignore-environment</code>: 不带环境变量启动。</li>
<li><code>-u</code>, <code>--unset=NAME</code>: 从环境变量中删除一个变量。</li>
<li><code>--help</code>: 显示帮助。</li>
<li><code>--version</code>: 输出版本信息。</li>
</ul>
<p>下面是一个例子，新建一个不带任何环境变量的 Shell。</p>
<div><pre><code><span>env</span> -i /bin/sh
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="注释" tabindex="-1"> 注释</h2>
<p>Bash 脚本中，<code>#</code> 表示注释，可以放在行首，也可以放在行尾。</p>
<div><pre><code><span># 本行是注释</span>
<span>echo</span> <span>'Hello World!'</span>

<span>echo</span> <span>'Hello World!'</span> <span># 井号后面的部分也是注释</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>建议在脚本开头，使用注释说明当前脚本的作用，这样有利于日后的维护。</p>
<h2 id="脚本参数" tabindex="-1"> 脚本参数</h2>
<p>调用脚本的时候，脚本文件名后面可以带有参数。</p>
<div><pre><code>script.sh word1 word2 word3
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，<code>script.sh</code> 是一个脚本文件，<code>word1</code>、<code>word2</code> 和 <code>word3</code> 是三个参数。</p>
<p>脚本文件内部，可以使用特殊变量，引用这些参数。</p>
<ul>
<li><code>$0</code>: 脚本文件名，即 <code>script.sh</code>。</li>
<li><code>$1</code>~<code>$9</code>: 对应脚本的第一个参数到第九个参数。</li>
<li><code>$#</code>: 参数的总数。</li>
<li><code>$@</code>: 全部的参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 全部的参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果脚本的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>注意，如果命令是 <code>command -o foo bar</code>，那么 <code>-o</code> 是 <code>$1</code>，<code>foo</code> 是 <code>$2</code>，<code>bar</code> 是 <code>$3</code>。</p>
<p>下面是一个脚本内部读取命令行参数的例子。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># script.sh</span>

<span>echo</span> <span>"全部参数: "</span> <span>$@</span>
<span>echo</span> <span>"命令行参数数量: "</span> <span>$#</span>
<span>echo</span> <span>'$0 = '</span> <span>$0</span>
<span>echo</span> <span>'$1 = '</span> <span>$1</span>
<span>echo</span> <span>'$2 = '</span> <span>$2</span>
<span>echo</span> <span>'$3 = '</span> <span>$3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>执行结果如下。</p>
<div><pre><code>$ ./script.sh a b c
全部参数: a b c
命令行参数数量: <span>3</span>
<span>$0</span> <span>=</span>  script.sh
<span>$1</span> <span>=</span>  a
<span>$2</span> <span>=</span>  b
<span>$3</span> <span>=</span>  c
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>用户可以输入任意数量的参数，利用 <code>for</code> 循环，可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>for</span> <span>i</span> <span>in</span> <span>"<span>$@</span>"</span><span>;</span> <span>do</span>
  <span>echo</span> <span>$i</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>$@</code> 返回一个全部参数的列表，然后使用 <code>for</code> 循环遍历。</p>
<p>如果多个参数放在双引号里面，视为一个参数。</p>
<div><pre><code>./script.sh <span>"a b"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面例子中，Bash 会认为 <code>&quot;a b&quot;</code> 是一个参数，<code>$1</code> 会返回 <code>a b</code>。注意，返回时不包括双引号。</p>
<h2 id="shift-命令" tabindex="-1"> shift 命令</h2>
<p><code>shift</code> 命令可以改变脚本参数，每次执行都会移除脚本当前的第一个参数 (<code>$1</code>)，使得后面的参数向前一位，即 <code>$2</code> 变成 <code>$1</code>、<code>$3</code> 变成 <code>$2</code>、<code>$4</code> 变成 <code>$3</code>，以此类推。</p>
<p><code>while</code> 循环结合 <code>shift</code> 命令，也可以读取每一个参数。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>echo</span> <span>"一共输入了 <span>$#</span> 个参数"</span>

<span>while</span> <span>[</span> <span>"<span>$1</span>"</span> <span>!=</span> <span>""</span> <span>]</span><span>;</span> <span>do</span>
  <span>echo</span> <span>"剩下 <span>$#</span> 个参数"</span>
  <span>echo</span> <span>"参数: <span>$1</span>"</span>
  <span>shift</span>
<span>done</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>shift</code> 命令每次移除当前第一个参数，从而通过 <code>while</code> 循环遍历所有参数。</p>
<p><code>shift</code> 命令可以接受一个整数作为参数，指定所要移除的参数个数，默认为 <code>1</code>。</p>
<div><pre><code><span>shift</span> <span>3</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令移除前三个参数，原来的 <code>$4</code> 变成 <code>$1</code>。</p>
<h2 id="getopts-命令" tabindex="-1"> getopts 命令</h2>
<p><code>getopts</code> 命令用在脚本内部，可以解析复杂的脚本命令行参数，通常与 <code>while</code> 循环一起使用，取出脚本所有的带有前置连词线 (<code>-</code>) 的参数。</p>
<div><pre><code><span>getopts</span> optstring name
</code></pre><div aria-hidden="true"><div></div></div></div><p>它带有两个参数。第一个参数 <code>optstring</code> 是字符串，给出脚本所有的连词线参数。比如，某个脚本可以有三个配置项参数 <code>-l</code>、<code>-h</code>、<code>-a</code>，其中只有 <code>-a</code> 可以带有参数值，而 <code>-l</code> 和 <code>-h</code> 是开关参数，那么 <code>getopts</code> 的第一个参数写成 <code>lha:</code>，顺序不重要。注意，<code>a</code> 后面有一个冒号，表示该参数带有参数值，<code>getopts</code> 规定带有参数值的配置项参数，后面必须带有一个冒号 (<code>:</code>)。<code>getopts</code> 的第二个参数 <code>name</code> 是一个变量名，用来保存当前取到的配置项参数，即 <code>l</code>、<code>h</code> 或 <code>a</code>。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>while</span> <span>getopts</span> <span>'lha:'</span> OPTION<span>;</span> <span>do</span>
  <span>case</span> <span>"<span>$OPTION</span>"</span> <span>in</span>
    l<span>)</span>
      <span>echo</span> <span>"linuxconfig"</span>
      <span>;</span><span>;</span>

    h<span>)</span>
      <span>echo</span> <span>"h stands for h"</span>
      <span>;</span><span>;</span>

    a<span>)</span>
      <span>avalue</span><span>=</span><span>"<span>$OPTARG</span>"</span>
      <span>echo</span> <span>"The value provided is <span>$OPTARG</span>"</span>
      <span>;</span><span>;</span>
    ?<span>)</span>
      <span>echo</span> <span>"script usage: <span><span>$(</span><span>basename</span> $0<span>)</span></span> [-l] [-h] [-a somevalue]"</span> <span>></span><span>&amp;2</span>
      <span>exit</span> <span>1</span>
      <span>;</span><span>;</span>
  <span>esac</span>
<span>done</span>
<span>shift</span> <span>"<span><span>$((</span>$OPTIND <span>-</span> <span>1</span><span>))</span></span>"</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>while</code> 循环不断执行 <code>getopts 'lha:' OPTION</code> 命令，每次执行就会读取一个连词线参数(以及对应的参数值)，然后进入循环体。变量 <code>OPTION</code> 保存的是，当前处理的那一个连词线参数(即 <code>l</code>、<code>h</code> 或 <code>a</code>)。如果用户输入了没有指定的参数(比如 <code>-x</code>)，那么 <code>OPTION</code> 等于 <code>?</code>。循环体内使用 <code>case</code> 判断，处理这四种不同的情况。</p>
<p>如果某个连词线参数带有参数值，比如 <code>-a foo</code>，那么处理 <code>a</code> 参数的时候，环境变量 <code>$OPTARG</code> 保存的就是参数值。</p>
<p>注意，只要遇到不带连词线的参数，<code>getopts</code> 就会执行失败，从而退出 <code>while</code> 循环。比如，<code>getopts</code> 可以解析 <code>command -l foo</code>，但不可以解析 <code>command foo -l</code>。另外，多个连词线参数写在一起的形式，比如 <code>command -lh</code>，<code>getopts</code> 也可以正确处理。</p>
<p>变量 <code>$OPTIND</code> 在 <code>getopts</code> 开始执行前是 <code>1</code>，然后每次执行就会加 <code>1</code>。等到退出 <code>while</code> 循环，就意味着连词线参数全部处理完毕。这时，<code>$OPTIND - 1</code> 就是已经处理的连词线参数个数，使用 <code>shift</code> 命令将这些参数移除，保证后面的代码可以用 <code>$1</code>、<code>$2</code> 等处理命令的主参数。</p>
<h2 id="配置项参数终止符" tabindex="-1"> 配置项参数终止符 <code>--</code></h2>
<p>变量当作命令的参数时，有时希望指定变量只能作为实体参数，不能当作配置项参数，这时可以使用配置项参数终止符 <code>--</code>。</p>
<div><pre><code><span>myPath</span><span>=</span><span>"~/docs"</span>
<span>ls</span> -- <span>$myPath</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>--</code> 强制变量 <code>$myPath</code> 只能当作实体参数(即路径名)解释。</p>
<p>如果变量不是路径名，就会报错。</p>
<div><pre><code>$ <span>myPath</span><span>=</span><span>"-l"</span>
$ <span>ls</span> -- <span>$myPath</span>
ls: 无法访问<span>'-l'</span><span>:</span> 没有那个文件或目录
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>myPath</code> 的值为 <code>-l</code>，不是路径。但是，<code>--</code> 强制 <code>$myPath</code> 只能作为路径解释，导致报错“不存在该路径”。</p>
<h2 id="exit-命令" tabindex="-1"> exit 命令</h2>
<p><code>exit</code> 命令用于终止当前脚本的执行，并向 Shell 返回一个退出值。</p>
<div><pre><code><span>exit</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中止当前脚本，将最后一条命令的退出状态，作为整个脚本的退出状态。</p>
<p><code>exit</code> 命令后面可以跟参数，该参数就是退出状态。</p>
<div><pre><code><span># 退出值为0(成功)</span>
$ <span>exit</span> <span>0</span>

<span># 退出值为1(失败)</span>
$ <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>退出时，脚本会返回一个退出值。脚本的退出值，<code>0</code> 表示正常，<code>1</code> 表示发生错误，<code>2</code> 表示用法不对，<code>126</code> 表示不是可执行脚本，<code>127</code> 表示命令没有发现。如果脚本被信号 <code>N</code> 终止，则退出值为 <code>128 + N</code>。简单来说，只要退出值非 0，就认为执行出错。</p>
<p>下面是一个例子。</p>
<div><pre><code><span>if</span> <span>[</span> <span><span>$(</span><span>id</span> -u<span>)</span></span> <span>!=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"根用户才能执行当前脚本"</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，<code>id -u</code> 命令返回用户的 ID，一旦用户的 ID 不等于 <code>0</code>(根用户的 ID)，脚本就会退出，并且退出码为 <code>1</code>，表示运行失败。</p>
<p><code>exit</code> 与 <code>return</code> 命令的差别是，<code>return</code> 命令是函数的退出，并返回一个值给调用者，脚本依然执行。<code>exit</code> 是整个脚本的退出，如果在函数之中调用 <code>exit</code>，则退出函数，并终止脚本执行。</p>
<h2 id="命令执行结果" tabindex="-1"> 命令执行结果</h2>
<p>命令执行结束后，会有一个返回值。<code>0</code> 表示执行成功，非 <code>0</code> (通常是 <code>1</code>)表示执行失败。环境变量 <code>$?</code> 可以读取前一个命令的返回值。</p>
<p>利用这一点，可以在脚本中对命令执行结果进行判断。</p>
<div><pre><code><span>cd</span> <span>$some_directory</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> <span>=</span> <span>"0"</span> <span>]</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"无法切换目录!"</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>cd $some_directory</code> 这个命令如果执行成功(返回值等于 <code>0</code>)，就删除该目录里面的文件，否则退出脚本，整个脚本的返回值变为 <code>1</code>，表示执行失败。</p>
<p>由于 <code>if</code> 可以直接判断命令的执行结果，执行相应的操作，上面的脚本可以改写成下面的样子。</p>
<div><pre><code><span>if</span> <span>cd</span> <span>$some_directory</span><span>;</span> <span>then</span>
  <span>rm</span> *
<span>else</span>
  <span>echo</span> <span>"Could not change directory! Aborting."</span> <span><span>1</span>></span><span>&amp;2</span>
  <span>exit</span> <span>1</span>
<span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>更简洁的写法是利用两个逻辑运算符 <code>&amp;&amp;</code>(且)和 <code>||</code>(或)。</p>
<div><pre><code><span># 第一步执行成功，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>&amp;&amp;</span> <span>rm</span> *

<span># 第一步执行失败，才会执行第二步</span>
<span>cd</span> <span>$some_directory</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="source-命令" tabindex="-1"> source 命令</h2>
<p><code>source</code> 命令用于执行一个脚本，通常用于重新加载一个配置文件。</p>
<div><pre><code><span>source</span> .bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>source</code> 命令最大的特点是在当前 Shell 执行脚本，不像直接执行脚本时，会新建一个子 Shell。所以，<code>source</code> 命令执行脚本时，不需要 <code>export</code> 变量。</p>
<div><pre><code><span>#!/bin/bash</span>
<span># test.sh</span>
<span>echo</span> <span>$foo</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面脚本输出 <code>$foo</code> 变量的值。</p>
<div><pre><code><span># 当前 Shell 新建一个变量 foo</span>
$ <span>foo</span><span>=</span><span>1</span>

<span># 打印输出 1</span>
$ <span>source</span> test.sh
<span>1</span>

<span># 打印输出空字符串</span>
$ <span>bash</span> test.sh
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，当前 Shell 的变量 <code>foo</code> 并没有 <code>export</code>，所以直接执行无法读取，但是 <code>source</code> 执行可以读取。</p>
<p><code>source</code> 命令的另一个用途，是在脚本内部加载外部库。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>source</span> ./lib.sh

function_from_lib
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面脚本在内部使用 <code>source</code> 命令加载了一个外部库，然后就可以在脚本里面，使用这个外部库定义的函数。</p>
<p><code>source</code> 有一个简写形式，可以使用一个点 (<code>.</code>) 来表示。</p>
<div><pre><code><span>.</span> .bashrc
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="别名-alias-命令" tabindex="-1"> 别名，alias 命令</h2>
<p><code>alias</code> 命令用来为一个命令指定别名，这样更便于记忆。下面是 <code>alias</code> 的格式。</p>
<div><pre><code><span>alias</span> <span>NAME</span><span>=</span>DEFINITION
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，<code>NAME</code> 是别名的名称，<code>DEFINITION</code> 是别名对应的原始命令。注意，等号两侧不能有空格，否则会报错。</p>
<p>一个常见的例子是为 <code>grep</code> 命令起一个 <code>search</code> 的别名。</p>
<div><pre><code><span>alias</span> <span>search</span><span>=</span>grep
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>alias</code> 也可以用来为长命令指定一个更短的别名。下面是通过别名定义一个 <code>today</code> 的命令。</p>
<div><pre><code>$ <span>alias</span> <span>today</span><span>=</span><span>'date +"%A, %B %-d, %Y"'</span>
$ today
星期一, 一月 <span>6</span>, <span>2020</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>有时为了防止误删除文件，可以指定 <code>rm</code> 命令的别名。</p>
<div><pre><code><span>alias</span> <span>rm</span><span>=</span><span>'rm -i'</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令指定 <code>rm</code> 命令是 <code>rm -i</code>，每次删除文件之前，都会让用户确认。</p>
<p><code>alias</code> 定义的别名也可以接受参数，参数会直接传入原始命令。</p>
<div><pre><code>$ <span>alias</span> <span>echo</span><span>=</span><span>'echo It says: '</span>
$ <span>echo</span> hello world
It says: hello world
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，别名定义了 <code>echo</code> 命令的前两个参数，等同于修改了 <code>echo</code> 命令的默认行为。</p>
<p>指定别名以后，就可以像使用其他命令一样使用别名。一般来说，都会把常用的别名写在 <code>~/.bashrc</code> 的末尾。另外，只能为命令定义别名，为其他部分(比如很长的路径)定义别名是无效的。</p>
<p>直接调用 <code>alias</code> 命令，可以显示所有别名。</p>
<div><pre><code><span>alias</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>unalias</code> 命令可以解除别名。</p>
<div><pre><code><span>unalias</span> lt
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://linuxconfig.org/how-to-use-getopts-to-parse-a-script-options" target="_blank" rel="noopener noreferrer">How to use getopts to parse a script options</a>, Egidio Docile</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>set 命令</title>
      <link>https://shimonzhan.com/code/linux/bash/set.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/set.html</guid>
      <source url="https://shimonzhan.com/rss.xml">set 命令</source>
      <description>set 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 set 的基本用法，帮助您写出更安全的 Bash 脚本。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>set</code> 命令是 Bash 脚本的重要环节，却常常被忽视，导致脚本的安全性和可维护性出问题。本章介绍 <code>set</code> 的基本用法，帮助您写出更安全的 Bash 脚本。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>我们知道，Bash 执行脚本时，会创建一个子 Shell。</p>
<div><pre><code><span>bash</span> script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码中，<code>script.sh</code> 是在一个子 Shell 里面执行。这个子 Shell 就是脚本的执行环境，Bash 默认给定了这个环境的各种参数。</p>
<p><code>set</code> 命令用来修改子 Shell 环境的运行参数，即定制环境。一共有十几个参数可以定制，<a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">官方手册</a>有完整清单，本章介绍其中最常用的几个。</p>
<p>顺便提一下，如果命令行下不带任何参数，直接运行 <code>set</code>，会显示所有的环境变量和 Shell 函数。</p>
<div><pre><code><span>set</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-u" tabindex="-1"> set -u</h2>
<p>执行脚本时，如果遇到不存在的变量，Bash 默认忽略它。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>$a</code> 是一个不存在的变量。执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh

bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，<code>echo $a</code> 输出了一个空行，Bash 忽略了不存在的 <code>$a</code>，然后继续执行 <code>echo bar</code>。大多数情况下，这不是开发者想要的行为，遇到变量不存在，脚本应该报错，而不是一声不响地往下执行。</p>
<p><code>set -u</code> 就用来改变这种行为。脚本在头部加上它，遇到不存在的变量就会报错，并停止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -u

<span>echo</span> <span>$a</span>
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>运行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
bash: script.sh:行4: a: 未绑定的变量
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>可以看到，脚本报错了，并且不再执行后面的语句。</p>
<p><code>-u</code> 还有另一种写法 <code>-o nounset</code>，两者是等价的。</p>
<div><pre><code><span>set</span> -o nounset
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-x" tabindex="-1"> set -x</h2>
<p>默认情况下，脚本执行后，只输出运行结果，没有其他内容。如果多个命令连续执行，它们的运行结果就会连续输出。有时会分不清，某一段内容是什么命令产生的。</p>
<p><code>set -x</code> 用来在运行结果之前，先输出执行的那一行命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -x

<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>执行上面的脚本，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
+ <span>echo</span> bar
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，执行 <code>echo bar</code> 之前，该命令会先打印出来，行首以 <code>+</code> 表示。这对于调试复杂的脚本是很有用的。</p>
<p><code>-x</code> 还有另一种写法 <code>-o xtrace</code>。</p>
<div><pre><code><span>set</span> -o xtrace
</code></pre><div aria-hidden="true"><div></div></div></div><p>脚本当中如果要关闭命令输出，可以使用 <code>set +x</code>。</p>
<div><pre><code><span>#!/bin/bash</span>

<span>number</span><span>=</span><span>1</span>

<span>set</span> -x
<span>if</span> <span>[</span> <span>$number</span> <span>=</span> <span>"1"</span> <span>]</span><span>;</span> <span>then</span>
  <span>echo</span> <span>"Number equals 1"</span>
<span>else</span>
  <span>echo</span> <span>"Number does not equal 1"</span>
<span>fi</span>
<span>set</span> +x
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面的例子中，只对特定的代码段打开命令输出。</p>
<h2 id="bash-的错误处理" tabindex="-1"> Bash 的错误处理</h2>
<p>如果脚本里面有运行失败的命令(返回值非 <code>0</code>)，Bash 默认会继续执行后面的命令。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>

foo
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面脚本中，<code>foo</code> 是一个不存在的命令，执行时会报错。但是，Bash 会忽略这个错误，继续往下执行。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行3: foo: 未找到命令
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，Bash 只是显示有错误，并没有终止执行。</p>
<p>这种行为很不利于脚本安全和除错。实际开发中，如果某个命令失败，往往需要脚本停止执行，防止错误累积。这时，一般采用下面的写法。</p>
<div><pre><code><span>command</span> <span>||</span> <span>exit</span> <span>1</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的写法表示只要 <code>command</code> 有非零返回值，脚本就会停止执行。</p>
<p>如果停止执行之前需要完成多个操作，就要采用下面三种写法。</p>
<div><pre><code><span># 写法一</span>
<span>command</span> <span>||</span> <span>{</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>}</span>

<span># 写法二</span>
<span>if</span> <span>!</span> <span>command</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>

<span># 写法三</span>
<span>command</span>
<span>if</span> <span>[</span> <span>"<span>$?</span>"</span> -ne <span>0</span> <span>]</span><span>;</span> <span>then</span> <span>echo</span> <span>"command failed"</span><span>;</span> <span>exit</span> <span>1</span><span>;</span> <span>fi</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，除了停止执行，还有一种情况。如果两个命令有继承关系，只有第一个命令成功了，才能继续执行第二个命令，那么就要采用下面的写法。</p>
<div><pre><code>command1 <span>&amp;&amp;</span> command2
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-e" tabindex="-1"> set -e</h2>
<p>上面这些写法多少有些麻烦，容易疏忽。<code>set -e</code> 从根本上解决了这个问题，它使得脚本只要发生错误，就终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
script.sh:行4: foo: 未找到命令
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>可以看到，第 4 行执行失败以后，脚本就终止执行了。</p>
<p><code>set -e</code> 根据返回值来判断，一个命令是否运行失败。但是，某些命令的非零返回值可能不表示失败，或者开发者希望在命令失败的情况下，脚本继续执行下去。这时可以暂时关闭 <code>set -e</code>，该命令执行结束后，再重新打开 <code>set -e</code>。</p>
<div><pre><code><span>set</span> +e
command1
command2
<span>set</span> -e
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>set +e</code> 表示关闭 <code>-e</code> 选项，<code>set -e</code> 表示重新打开 <code>-e</code> 选项。</p>
<p>还有一种方法是使用 <code>command || true</code>，使得该命令即使执行失败，脚本也不会终止执行。</p>
<div><pre><code><span>#!/bin/bash</span>
<span>set</span> -e

foo <span>||</span> <span>true</span>
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>true</code> 使得这一行语句总是会执行成功，后面的 <code>echo bar</code> 会执行。</p>
<p><code>-e</code> 还有另一种写法 <code>-o errexit</code>。</p>
<div><pre><code><span>set</span> -o errexit
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="set-o-pipefail" tabindex="-1"> set -o pipefail</h2>
<p><code>set -e</code> 有一个例外情况，就是不适用于管道命令。</p>
<p>所谓管道命令，就是多个子命令通过管道运算符 (<code>|</code>) 组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，<code>set -e</code> 就失效了。</p>
<p>请看下面这个例子。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -e

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>执行结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面代码中，<code>foo</code> 是一个不存在的命令，但是 <code>foo | echo a</code> 这个管道命令会执行成功，导致后面的 <code>echo bar</code> 会继续执行。</p>
<p><code>set -o pipefail</code> 用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。</p>
<div><pre><code><span>#!/usr/bin/env bash</span>
<span>set</span> -eo pipefail

foo <span>|</span> <span>echo</span> a
<span>echo</span> bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>运行后，结果如下。</p>
<div><pre><code>$ <span>bash</span> script.sh
a
script.sh:行4: foo: 未找到命令
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，<code>echo bar</code> 没有执行。</p>
<h2 id="其他参数" tabindex="-1"> 其他参数</h2>
<p><code>set</code> 命令还有一些其他参数。</p>
<ul>
<li><code>set -n</code>: 等同于 <code>set -o noexec</code>，不运行命令，只检查语法是否正确。</li>
<li><code>set -f</code>: 等同于 <code>set -o noglob</code>，表示不对通配符进行文件名扩展。</li>
<li><code>set -v</code>: 等同于 <code>set -o verbose</code>，表示打印 Shell 接收到的每一行输入。</li>
</ul>
<p>上面的 <code>-f</code> 和 <code>-v</code> 参数，可以分别使用 <code>set +f</code>、<code>set +v</code> 关闭。</p>
<h2 id="set-命令总结" tabindex="-1"> set 命令总结</h2>
<p>上面重点介绍的 <code>set</code> 命令的四个参数，一般都放在一起使用。</p>
<div><pre><code><span># 写法一</span>
<span>set</span> -euxo pipefail

<span># 写法二</span>
<span>set</span> -eux
<span>set</span> -o pipefail
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这两种写法建议放在所有 Bash 脚本的头部。</p>
<p>另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。</p>
<div><pre><code><span>bash</span> -euxo pipefail script.sh
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="shopt-命令" tabindex="-1"> shopt 命令</h2>
<p><code>shopt</code> 命令用来调整 Shell 的参数，跟 <code>set</code> 命令的作用很类似。之所以会有这两个类似命令的主要原因是，<code>set</code> 是从 Ksh 继承的，属于 POSIX 规范的一部分，而 <code>shopt</code> 是 Bash 特有的。</p>
<p>直接输入 <code>shopt</code> 可以查看所有参数，以及它们各自打开和关闭的状态。</p>
<div><pre><code><span>shopt</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>shopt</code> 命令后面跟着参数名，可以查询该参数是否打开。</p>
<div><pre><code>$ <span>shopt</span> globstar
globstar  off
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子表示 <code>globstar</code> 参数默认是关闭的。</p>
<ol>
<li>
<p><strong><code>-s</code></strong></p>
<p><code>-s</code> 用来打开某个参数。</p>
<div><pre><code><span>shopt</span> -s optionNameHere
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong><code>-u</code></strong></p>
<p><code>-u</code> 用来关闭某个参数。</p>
<div><pre><code><span>shopt</span> -u optionNameHere
</code></pre><div aria-hidden="true"><div></div></div></div><p>举例来说，<code>histappend</code> 这个参数表示退出当前 Shell 时，将操作历史追加到历史文件中。这个参数默认是打开的，如果使用下面的命令将其关闭，那么当前 Shell 的操作历史将替换掉整个历史文件。</p>
<div><pre><code><span>shopt</span> -u histappend
</code></pre><div aria-hidden="true"><div></div></div></div></li>
<li>
<p><strong><code>-q</code></strong></p>
<p><code>-q</code> 的作用也是查询某个参数是否打开，但不是直接输出查询结果，而是通过命令的执行状态 (<code>$?</code>) 表示查询结果。如果状态为 <code>0</code>，表示该参数打开；如果为 <code>1</code>，表示该参数关闭。</p>
<div><pre><code>$ <span>shopt</span> -q globstar
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面命令查询 <code>globstar</code> 参数是否打开。返回状态为 <code>1</code>，表示该参数是关闭的。</p>
<p>这个用法主要用于脚本，供 <code>if</code> 条件结构使用。</p>
<div><pre><code><span>if</span> <span>shopt</span> -q globstar<span>;</span> <span>then</span>
  <span>..</span>.
<span>if</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div></li>
</ol>
<h2 id="参考链接" tabindex="-1"> 参考链接</h2>
<ul>
<li><a href="https://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html" target="_blank" rel="noopener noreferrer">The Set built-in</a></li>
<li><a href="https://vaneyckt.io/posts/safer_bash_scripts_with_set_euxo_pipefail/" target="_blank" rel="noopener noreferrer">Safer bash scripts with 'set -euxo pipefail’</a></li>
<li><a href="http://www.davidpashley.com/articles/writing-robust-shell-scripts/" target="_blank" rel="noopener noreferrer">Writing Robust Bash Shell Scripts</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录堆栈</title>
      <link>https://shimonzhan.com/code/linux/bash/stack.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/stack.html</guid>
      <source url="https://shimonzhan.com/rss.xml">目录堆栈</source>
      <description>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了方便用户在不同目录之间切换，Bash 提供了目录堆栈功能。</p>

<h2 id="cd" tabindex="-1"> cd -</h2>
<p>Bash 可以记忆用户进入过的目录。默认情况下，只记忆前一次所在的目录，<code>cd -</code> 命令可以返回前一次的目录。</p>
<div><pre><code><span># 当前目录是 /path/to/foo</span>
$ <span>cd</span> bar

<span># 重新回到 /path/to/foo</span>
$ <span>cd</span> -
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，用户原来所在的目录是 <code>/path/to/foo</code>，进入子目录 <code>bar</code> 以后，使用 <code>cd -</code> 可以回到原来的目录。</p>
<h2 id="pushd-popd" tabindex="-1"> pushd，popd</h2>
<p>如果希望记忆多重目录，可以使用 <code>pushd</code> 命令和 <code>popd</code> 命令。它们用来操作目录堆栈。</p>
<p><code>pushd</code> 命令的用法类似 <code>cd</code> 命令，可以进入指定的目录。</p>
<div><pre><code><span>pushd</span> <span>dirname</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令会进入目录 <code>dirname</code>，并将该目录放入堆栈。</p>
<p>第一次使用 <code>pushd</code> 命令时，会将当前目录先放入堆栈，然后将所要进入的目录也放入堆栈，位置在前一个记录的上方。以后每次使用 <code>pushd</code> 命令，都会将所要进入的目录，放在堆栈的顶部。</p>
<p><code>popd</code> 命令不带有参数时，会移除堆栈的顶部记录，并进入新的堆栈顶部目录(即原来的第二条目录)。</p>
<p>下面是一个例子。</p>
<div><pre><code><span># 当前处在主目录，堆栈为空</span>
$ <span>pwd</span>
/home/me

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>pushd</span> ~/foo

<span># 进入 /etc</span>
<span># 当前堆栈为 /etc /home/me/foo /home/me</span>
$ <span>pushd</span> /etc

<span># 进入 /home/me/foo</span>
<span># 当前堆栈为 /home/me/foo /home/me</span>
$ <span>popd</span>

<span># 进入 /home/me</span>
<span># 当前堆栈为 /home/me</span>
$ <span>popd</span>

<span># 目录不变，当前堆栈为空</span>
$ <span>popd</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这两个命令的参数如下。</p>
<ol>
<li>
<p><strong><code>-n</code> 参数</strong></p>
<p><code>-n</code> 的参数表示仅操作堆栈，不改变目录。</p>
<div><pre><code><span>popd</span> -n
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面的命令仅删除堆栈顶部的记录，不改变目录，执行完成后还停留在当前目录。</p>
</li>
<li>
<p><strong>整数参数</strong></p>
<p>这两个命令还可以接受一个整数作为参数，该整数表示堆栈中指定位置的记录(从 0 开始)，作为操作对象。这时不会切换目录。</p>
<div><pre><code><span># 从栈顶算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> +3

<span># 从栈底算起的3号目录(从0开始)，移动到栈顶</span>
$ <span>pushd</span> -3

<span># 删除从栈顶算起的3号目录(从0开始)</span>
$ <span>popd</span> +3

<span># 删除从栈底算起的3号目录(从0开始)</span>
$ <span>popd</span> -3
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子的整数编号都是从 0 开始计算，<code>popd +0</code> 是删除第一个目录，<code>popd +1</code> 是删除第二个，<code>popd -0</code> 是删除最后一个目录，，<code>popd -1</code> 是删除倒数第二个。</p>
</li>
<li>
<p><strong>目录参数</strong></p>
<p><code>pushd</code> 可以接受一个目录作为参数，表示将该目录放到堆栈顶部，并进入该目录。</p>
<div><pre><code><span>pushd</span> <span>dir</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>popd</code> 没有这个参数。</p>
</li>
</ol>
<h2 id="dirs-命令" tabindex="-1"> dirs 命令</h2>
<p><code>dirs</code> 命令可以显示目录堆栈的内容，一般用来查看 <code>pushd</code> 和 <code>popd</code> 操作后的结果。</p>
<div><pre><code><span>dirs</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>它有以下参数。</p>
<ul>
<li><code>-c</code>: 清空目录栈。</li>
<li><code>-l</code>: 用户主目录不显示波浪号前缀，而打印完整的目录。</li>
<li><code>-p</code>: 每行一个条目打印目录栈，默认是打印在一行。</li>
<li><code>-v</code>: 每行一个条目，每个条目之前显示位置编号(从 0 开始)。</li>
<li><code>+N</code>: <code>N</code> 为整数，表示显示堆顶算起的第 N 个目录，从零开始。</li>
<li><code>-N</code>: <code>N</code> 为整数，表示显示堆底算起的第 N 个目录，从零开始。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 启动环境</title>
      <link>https://shimonzhan.com/code/linux/bash/startup.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/startup.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 启动环境</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="session" tabindex="-1"> Session</h2>
<p>用户每次使用 Shell，都会开启一个与 Shell 的 Session(对话)。</p>
<p>Session 有两种类型: 登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。</p>
<h3 id="登录-session" tabindex="-1"> 登录 Session</h3>
<p>登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。</p>
<p>登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/profile</code>: 所有用户的全局配置脚本。</li>
<li><code>/etc/profile.d</code> 目录里面所有 <code>.sh</code> 文件</li>
<li><code>~/.bash_profile</code>: 用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.bash_login</code>: 如果 <code>~/.bash_profile</code> 没找到，则尝试执行这个脚本(C shell 的初始化脚本)。如果该脚本存在，则执行完就不再往下执行。</li>
<li><code>~/.profile</code>: 如果<code>~/.bash_profile</code> 和 <code>~/.bash_login</code> 都没找到，则尝试读取这个脚本(Bourne shell 和 Korn shell 的初始化脚本)。</li>
</ul>
<p>Linux 发行版更新的时候，会更新 <code>/etc</code> 里面的文件，比如 <code>/etc/profile</code>，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在 <code>/etc/profile.d</code> 目录里面新建 <code>.sh</code> 脚本。</p>
<p>如果想修改您个人的登录环境，一般是写在 <code>~/.bash_profile</code> 里面。下面是一个典型的 <code>.bash_profile</code> 文件。</p>
<div><pre><code><span># .bash_profile</span>
<span><span>PATH</span></span><span>=</span>/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin
<span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$HOME</span>/bin

<span><span>SHELL</span></span><span>=</span>/bin/bash
<span>MANPATH</span><span>=</span>/usr/man:/usr/X11/man
<span>EDITOR</span><span>=</span>/usr/bin/vi
<span><span>PS1</span></span><span>=</span><span>'\h:\w\$ '</span>
<span><span>PS2</span></span><span>=</span><span>'> '</span>

<span>if</span> <span>[</span> -f ~/.bashrc <span>]</span><span>;</span> <span>then</span>
<span>.</span> ~/.bashrc
<span>fi</span>

<span>export</span> <span>PATH</span>
<span>export</span> EDITOR
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>可以看到，这个脚本定义了一些最基本的环境变量，然后执行了 <code>~/.bashrc</code>。</p>
<p><code>bash</code> 命令的 <code>--login</code> 参数，会强制执行登录 Session 会执行的脚本。</p>
<div><pre><code><span>bash</span> --login
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>bash</code> 命令的 <code>--noprofile</code> 参数，会跳过上面这些 Profile 脚本。</p>
<div><pre><code><span>bash</span> --noprofile
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="非登录-session" tabindex="-1"> 非登录 Session</h3>
<p>非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行 <code>bash</code> 命令，就会新建一个非登录 Session。</p>
<p>非登录 Session 的初始化脚本依次如下。</p>
<ul>
<li><code>/etc/bash.bashrc</code>: 对全体用户有效。</li>
<li><code>~/.bashrc</code>: 仅对当前用户有效。</li>
</ul>
<p>对用户来说，<code>~/.bashrc</code> 通常是最重要的脚本。非登录 Session 默认会执行它，而登陆 Session 一般也会通过调用执行它。由于每次执行 Bash 脚本，都会新建一个非登录 Session，所以 <code>~/.bashrc</code> 也是每次执行脚本都会执行的。</p>
<p><code>bash</code> 命令的 <code>--norc</code> 参数，可以禁止在非登录 Session 执行 <code>~/.bashrc</code> 脚本。</p>
<div><pre><code><span>bash</span> --norc
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>bash</code> 命令的 <code>--rcfile</code> 参数，指定另一个脚本代替 <code>.bashrc</code>。</p>
<div><pre><code><span>bash</span> --rcfile testrc
</code></pre><div aria-hidden="true"><div></div></div></div><h3 id="bash-logout" tabindex="-1"> .bash_logout</h3>
<p><code>~/.bash_logout</code> 脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。</p>
<p>如果没有退出时要执行的命令，这个文件也可以不存在。</p>
<h2 id="启动选项" tabindex="-1"> 启动选项</h2>
<p>为了方便 Debug，有时在启动 Bash 的时候，可以加上启动参数。</p>
<ul>
<li><code>-n</code>: 不运行脚本，只检查是否有语法错误。</li>
<li><code>-v</code>: 输出每一行语句运行结果前，会先输出该行语句。</li>
<li><code>-x</code>: 每一个命令处理完以后，先输出该命令，再进行下一个命令的处理。</li>
</ul>
<div><pre><code><span>bash</span> -n scriptname
<span>bash</span> -v scriptname
<span>bash</span> -x scriptname
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><h2 id="键盘绑定" tabindex="-1"> 键盘绑定</h2>
<p>Bash 允许用户定义自己的快捷键。全局的键盘绑定文件默认为 <code>/etc/inputrc</code>，您可以在主目录创建自己的键盘绑定文件 <code>.inputrc</code> 文件。如果定义了这个文件，需要在其中加入下面这行，保证全局绑定不会被遗漏。</p>
<div><pre><code><span>$include</span> /etc/inputrc
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>.inputrc</code> 文件里面的快捷键，可以像这样定义，<code>&quot;\C-t&quot;:&quot;pwd\n&quot;</code> 表示将 <code>Ctrl + t</code> 绑定为运行 <code>pwd</code> 命令。</p>
]]></content:encoded>
    </item>
    <item>
      <title>字符串操作</title>
      <link>https://shimonzhan.com/code/linux/bash/string.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/string.html</guid>
      <source url="https://shimonzhan.com/rss.xml">字符串操作</source>
      <description>本章介绍 Bash 字符串操作的语法。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 字符串操作的语法。</p>

<h2 id="字符串的长度" tabindex="-1"> 字符串的长度</h2>
<p>获取字符串长度的语法如下。</p>
<div><pre><code><span>${<span>#</span>varname}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name
$ <span>echo</span> <span>${<span>#</span>myPath}</span>
<span>29</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>大括号 <code>{}</code> 是必需的，否则 Bash 会将 <code>$#</code> 理解成脚本的参数个数，将变量名理解成文本。</p>
<div><pre><code>$ <span>echo</span> <span>$#</span>myvar
0myvar
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，Bash 将 <code>$#</code> 和 <code>myvar</code> 分开解释了。</p>
<h2 id="子字符串" tabindex="-1"> 子字符串</h2>
<p>字符串提取子串的语法如下。</p>
<div><pre><code><span>${varname<span>:</span>offset<span>:</span>length}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是返回变量 <code>$varname</code> 的子字符串，从位置 <code>offset</code> 开始(从 <code>0</code> 开始计算)，长度为 <code>length</code>。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4<span>:</span>4}</span>
foot
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子返回字符串 <code>frogfootman</code> 从 4 号位置开始的长度为 4 的子字符串 <code>foot</code>。</p>
<p>这种语法不能直接操作字符串，只能通过变量来读取字符串，并且不会改变原始字符串。变量前面的美元符号可以省略。</p>
<div><pre><code><span># 报错</span>
$ <span>echo</span> <span>${"hello"<span>:</span>2<span>:</span>3}</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>&quot;hello&quot;</code> 不是变量名，导致 Bash 报错。</p>
<p>如果省略 <code>length</code>，则从位置 <code>offset</code> 开始，一直返回到字符串的结尾。</p>
<div><pre><code>$ <span>count</span><span>=</span>frogfootman
$ <span>echo</span> <span>${count<span>:</span>4}</span>
footman
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子是返回变量 <code>count</code> 从 4 号位置一直到结尾的子字符串。</p>
<p>如果 <code>offset</code> 为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与 <code>${variable:-word}</code> 的变量的设置默认值语法混淆。这时，如果还指定 <code>length</code>，则 <code>length</code> 不能小于零。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>"This string is long."</span>
$ <span>echo</span> <span>${foo<span>:</span> -5}</span>
long.
$ <span>echo</span> <span>${foo<span>:</span> -5<span>:</span>2}</span>
lo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>offset</code> 为 <code>-5</code>，表示从倒数第 5 个字符开始截取，所以返回 <code>long.</code>。如果指定长度为 <code>2</code>，则返回 <code>lo</code>。</p>
<h2 id="搜索和替换" tabindex="-1"> 搜索和替换</h2>
<p>Bash 提供字符串搜索和替换的多种方法。</p>
<h3 id="字符串头部的模式匹配" tabindex="-1"> 字符串头部的模式匹配</h3>
<p>以下两种语法可以检查字符串开头，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>#</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的开头，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>##</span>pattern}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面两种语法会删除变量字符串开头的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<p>匹配模式 <code>pattern</code> 可以使用 <code>*</code>、<code>?</code>、<code>[]</code> 等通配符。</p>
<div><pre><code>$ <span>myPath</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>#</span><span>/</span>*<span>/</span>}</span>
cam/book/long.file.name

$ <span>echo</span> <span>${myPath<span>##</span><span>/</span>*<span>/</span>}</span>
long.file.name
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，匹配的模式是 <code>/*/</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>/home/</code>，最长匹配是 <code>/home/cam/book/</code>。</p>
<p>下面写法可以删除文件路径的目录部分，只留下文件名。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>##</span>*<span>/</span>}</span>
long.file.name
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，模式 <code>*/</code> 匹配目录部分，所以只返回文件名。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>*-}</span>
<span>456</span>-1414
$ <span>echo</span> <span>${phone<span>##</span>*-}</span>
<span>1414</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>#</span>444}</span>
<span>555</span>-456-1414
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，原始字符串里面无法匹配模式 <code>444</code>，所以原样返回。</p>
<p>如果要将头部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>#</span>JPG<span>/</span>jpg}</span>
jpg.JPG
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串头部，所以返回 <code>jpg.JPG</code>。</p>
<h3 id="字符串尾部的模式匹配" tabindex="-1"> 字符串尾部的模式匹配</h3>
<p>以下两种语法可以检查字符串结尾，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，返回剩下的部分。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最短匹配(非贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%</span>pattern}</span>

<span># 如果 pattern 匹配变量 variable 的结尾，</span>
<span># 删除最长匹配(贪婪匹配)的部分，返回剩余部分</span>
<span>${variable<span>%%</span>pattern}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面两种语法会删除变量字符串结尾的匹配部分(将其替换为空)，返回剩下的部分。区别是一个是最短匹配(又称非贪婪匹配)，另一个是最长匹配(又称贪婪匹配)。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span>.*}</span>
/home/cam/book/long.file

$ <span>echo</span> <span>${path<span>%%</span>.*}</span>
/home/cam/book/long
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，匹配模式是 <code>.*</code>，其中 <code>*</code> 可以匹配任意数量的字符，所以最短匹配是 <code>.name</code>，最长匹配是 <code>.file.name</code>。</p>
<p>下面写法可以删除路径的文件名部分，只留下目录部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/book/long.file.name

$ <span>echo</span> <span>${path<span>%</span><span>/</span>*}</span>
/home/cam/book
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，模式 <code>/*</code> 匹配文件名部分，所以只返回目录部分。</p>
<p>下面的写法可以替换文件的后缀名。</p>
<div><pre><code>$ <span>file</span><span>=</span>foo.png
$ <span>echo</span> <span>${file<span>%</span>.png}</span>.jpg
foo.jpg
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的例子将文件的后缀名，从 <code>.png</code> 改成了 <code>.jpg</code>。</p>
<p>下面再看一个例子。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>%</span>-*}</span>
<span>555</span>-456
$ <span>echo</span> <span>${phone<span>%%</span>-*}</span>
<span>555</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果匹配不成功，则返回原始字符串。</p>
<p>如果要将尾部匹配的部分，替换成其他内容，采用下面的写法。</p>
<div><pre><code><span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>

<span># 示例</span>
$ <span>foo</span><span>=</span>JPG.JPG
$ <span>echo</span> <span>${foo<span>/</span><span>%</span>JPG<span>/</span>jpg}</span>
JPG.jpg
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，被替换的 <code>JPG</code> 必须出现在字符串尾部，所以返回 <code>JPG.jpg</code>。</p>
<h3 id="任意位置的模式匹配" tabindex="-1"> 任意位置的模式匹配</h3>
<p>以下两种语法可以检查字符串内部，是否匹配给定的模式。如果匹配成功，就删除匹配的部分，换成其他的字符串返回。原始变量不会发生变化。</p>
<div><pre><code><span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，但仅替换第一个匹配</span>
<span>${variable<span>/</span>pattern<span>/</span>string}</span>

<span># 如果 pattern 匹配变量 variable 的一部分，</span>
<span># 最长匹配(贪婪匹配)的那部分被 string 替换，所有匹配都替换</span>
<span>${variable<span>/</span><span>/</span>pattern<span>/</span>string}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面两种语法都是最长匹配(贪婪匹配)下的替换，区别是前一个语法仅仅替换第一个匹配，后一个语法替换所有匹配。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/foo.name

$ <span>echo</span> <span>${path<span>/</span><span>/</span>foo<span>/</span>bar}</span>
/home/cam/bar/bar.name
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，前一个命令只替换了第一个 <code>foo</code>，后一个命令将两个 <code>foo</code> 都替换了。</p>
<p>下面的例子将分隔符从 <code>:</code> 换成换行符。</p>
<div><pre><code>$ <span>echo</span> -e <span>${<span>PATH</span><span>/</span><span>/</span><span>:</span><span>/</span>'\n'}</span>
/usr/local/bin
/usr/bin
/bin
<span>..</span>.
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>echo</code> 命令的 <code>-e</code> 参数，表示将替换后的字符串的 <code>\n</code> 字符，解释为换行符。</p>
<p>模式部分可以使用通配符。</p>
<div><pre><code>$ <span>phone</span><span>=</span><span>"555-456-1414"</span>
$ <span>echo</span> <span>${phone<span>/</span>5?4<span>/</span>-}</span>
<span>55</span>-56-1414
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的例子将 <code>5-4</code> 替换成 <code>-</code>。</p>
<p>如果省略了 <code>string</code> 部分，那么就相当于匹配的部分替换成空字符串，即删除匹配的部分。</p>
<div><pre><code>$ <span>path</span><span>=</span>/home/cam/foo/foo.name

$ <span>echo</span> <span>${path<span>/</span>.*<span>/</span>}</span>
/home/cam/foo/foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，第二个斜杠后面的 <code>string</code> 部分省略了，所以模式 <code>.*</code> 匹配的部分 <code>.name</code> 被删除后返回。</p>
<p>前面提到过，这个语法还有两种扩展形式。</p>
<div><pre><code><span># 模式必须出现在字符串的开头</span>
<span>${variable<span>/</span><span>#</span>pattern<span>/</span>string}</span>

<span># 模式必须出现在字符串的结尾</span>
<span>${variable<span>/</span><span>%</span>pattern<span>/</span>string}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="改变大小写" tabindex="-1"> 改变大小写</h2>
<p>下面的语法可以改变变量的大小写。</p>
<div><pre><code><span># 转为大写</span>
<span>${varname<span>^^</span>}</span>

<span># 转为小写</span>
<span>${varname<span>,,</span>}</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>下面是一个例子。</p>
<div><pre><code>$ <span>foo</span><span>=</span>heLLo
$ <span>echo</span> <span>${foo<span>^^</span>}</span>
HELLO
$ <span>echo</span> <span>${foo<span>,,</span>}</span>
hello
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Bash 变量</title>
      <link>https://shimonzhan.com/code/linux/bash/variable.html</link>
      <guid>https://shimonzhan.com/code/linux/bash/variable.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Bash 变量</source>
      <description>Bash 变量分成环境变量和自定义变量两类。
</description>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 变量分成环境变量和自定义变量两类。</p>

<h2 id="简介" tabindex="-1"> 简介</h2>
<p>环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，可以直接使用。它们通常是系统定义好的，也可以由用户从父 Shell 传入子 Shell。</p>
<p><code>env</code> 命令或 <code>printenv</code> 命令，可以显示所有环境变量。</p>
<div><pre><code>$ <span>env</span>
<span># 或者</span>
$ <span>printenv</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>下面是一些常见的环境变量。</p>
<ul>
<li><code>BASHPID</code>: Bash 进程的进程 ID。</li>
<li><code>BASHOPTS</code>: 当前 Shell 的参数，可以用 <code>shopt</code> 命令修改。</li>
<li><code>DISPLAY</code>: 图形环境的显示器名字，通常是 <code>:0</code>，表示 X Server 的第一个显示器。</li>
<li><code>EDITOR</code>: 默认的文本编辑器。</li>
<li><code>HOME</code>: 用户的主目录。</li>
<li><code>HOST</code>: 当前主机的名称。</li>
<li><code>IFS</code>: 词与词之间的分隔符，默认为空格。</li>
<li><code>LANG</code>: 字符集以及语言编码，比如 <code>zh_CN.UTF-8</code>。</li>
<li><code>PATH</code>: 由冒号分开的目录列表，当输入可执行程序名后，会搜索这个目录列表。</li>
<li><code>PS1</code>: Shell 提示符。</li>
<li><code>PS2</code>: 输入多行命令时，次要的 Shell 提示符。</li>
<li><code>PWD</code>: 当前工作目录。</li>
<li><code>RANDOM</code>: 返回一个 0 到 32767 之间的随机数。</li>
<li><code>SHELL</code>: Shell 的名字。</li>
<li><code>SHELLOPTS</code>: 启动当前 Shell 的 <code>set</code> 命令的参数，参见《set 命令》一章。</li>
<li><code>TERM</code>: 终端类型名，即终端仿真器所用的协议。</li>
<li><code>UID</code>: 当前用户的 ID 编号。</li>
<li><code>USER</code>: 当前用户的用户名。</li>
</ul>
<p>很多环境变量很少发生变化，而且是只读的，可以视为常量。由于它们的变量名全部都是大写，所以传统上，如果用户要自己定义一个常量，也会使用全部大写的变量名。</p>
<p>注意，Bash 变量名区分大小写，<code>HOME</code> 和 <code>home</code> 是两个不同的变量。</p>
<p>查看单个环境变量的值，可以使用 <code>printenv</code> 命令或 <code>echo</code> 命令。</p>
<div><pre><code>$ <span>printenv</span> <span>PATH</span>
<span># 或者</span>
$ <span>echo</span> <span>$PATH</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>注意，<code>printenv</code> 命令后面的变量名，不用加前缀 <code>$</code>。</p>
<p>自定义变量是用户在当前 Shell 里面自己定义的变量，必须先定义后使用，而且仅在当前 Shell 可用。一旦退出当前 Shell，该变量就不存在了。</p>
<p><code>set</code> 命令可以显示所有变量(包括环境变量和自定义变量)，以及所有的 Bash 函数。</p>
<div><pre><code><span>set</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="创建变量" tabindex="-1"> 创建变量</h2>
<p>用户创建变量的时候，变量名必须遵守下面的规则。</p>
<ul>
<li>字母、数字和下划线字符组成。</li>
<li>第一个字符必须是一个字母或一个下划线，不能是数字。</li>
<li>不允许出现空格和标点符号。</li>
</ul>
<p>变量声明的语法如下。</p>
<div><pre><code><span>variable</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令中，等号左边是变量名，右边是变量。注意，等号两边不能有空格。</p>
<p>如果变量的值包含空格，则必须将值放在引号中。</p>
<div><pre><code><span>myvar</span><span>=</span><span>"hello world"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>Bash 没有数据类型的概念，所有的变量值都是字符串。</p>
<p>下面是一些自定义变量的例子。</p>
<div><pre><code><span>a</span><span>=</span>z                     <span># 变量 a 赋值为字符串 z</span>
<span>b</span><span>=</span><span>"a string"</span>            <span># 变量值包含空格，就必须放在引号里面</span>
<span>c</span><span>=</span><span>"a string and <span>$b</span>"</span>     <span># 变量值可以引用其他变量的值</span>
<span>d</span><span>=</span><span>"<span title="\t">\t</span><span title="\t">\t</span>a string<span title="\n">\n</span>"</span>      <span># 变量值可以使用转义字符</span>
<span>e</span><span>=</span><span><span>$(</span><span>ls</span> -l foo.txt<span>)</span></span>      <span># 变量值可以是命令的执行结果</span>
<span>f</span><span>=</span><span><span>$((</span><span>5</span> <span>*</span> <span>7</span><span>))</span></span>            <span># 变量值可以是数学运算的结果</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>变量可以重复赋值，后面的赋值会覆盖前面的赋值。</p>
<div><pre><code>$ <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
$ <span>echo</span> <span>$foo</span>
<span>2</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>foo</code> 的第二次赋值会覆盖第一次赋值。</p>
<h2 id="读取变量" tabindex="-1"> 读取变量</h2>
<p>读取变量的时候，直接在变量名前加上 <code>$</code> 就可以了。</p>
<div><pre><code>$ <span>foo</span><span>=</span>bar
$ <span>echo</span> <span>$foo</span>
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>每当 Shell 看到以 <code>$</code> 开头的单词时，就会尝试读取这个变量名对应的值。</p>
<p>如果变量不存在，Bash 不会报错，而会输出空字符。</p>
<p>由于 <code>$</code> 在 Bash 中有特殊含义，把它当作美元符号使用时，一定要非常小心，</p>
<div><pre><code>$ <span>echo</span> The total is <span>$100</span>.00
The total is 00.00
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令的原意是输入 <code>$100</code>，但是 Bash 将 <code>$1</code> 解释成了变量，该变量为空，因此输入就变成了 <code>00.00</code>。所以，如果要使用 <code>$</code> 的原义，需要在 <code>$</code> 前面放上反斜杠，进行转义。</p>
<div><pre><code>$ <span>echo</span> The total is <span>\</span><span>$100</span>.00
The total is <span>$100</span>.00
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>读取变量的时候，变量名也可以使用花括号 <code>{}</code> 包围，比如 <code>$a</code> 也可以写成 <code>${a}</code>。这种写法可以用于变量名与其他字符连用的情况。</p>
<div><pre><code>$ <span>a</span><span>=</span>foo
$ <span>echo</span> <span>$a_file</span>

$ <span>echo</span> <span>${a}</span>_file
foo_file
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面代码中，变量名 <code>a_file</code> 不会有任何输出，因为 Bash 将其整个解释为变量，而这个变量是不存在的。只有用花括号区分 <code>$a</code>，Bash 才能正确解读。</p>
<p>事实上，读取变量的语法 <code>$foo</code>，可以看作是 <code>${foo}</code> 的简写形式。</p>
<p>如果变量的值本身也是变量，可以使用 <code>${!varname}</code> 的语法，读取最终的值。</p>
<div><pre><code>$ <span>myvar</span><span>=</span><span>USER</span>
$ <span>echo</span> <span>${<span>!</span>myvar}</span>
ruanyf
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面的例子中，变量 <code>myvar</code> 的值是 <code>USER</code>，<code>${!myvar}</code> 的写法将其展开成最终的值。</p>
<h2 id="删除变量" tabindex="-1"> 删除变量</h2>
<p><code>unset</code> 命令用来删除一个变量。</p>
<div><pre><code><span>unset</span> NAME
</code></pre><div aria-hidden="true"><div></div></div></div><p>这个命令不是很有用。因为不存在的 Bash 变量一律等于空字符串，所以即使 <code>unset</code> 命令删除了变量，还是可以读取这个变量，值为空字符串。</p>
<p>所以，删除一个变量，也可以将这个变量设成空字符串。</p>
<div><pre><code><span>foo</span><span>=</span><span>''</span>
<span>foo</span><span>=</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面两种写法，都是删除了变量 <code>foo</code>。由于不存在的值默认为空字符串，所以后一种写法可以在等号右边不写任何值。</p>
<h2 id="输出变量-export-命令" tabindex="-1"> 输出变量，export 命令</h2>
<p>用户创建的变量仅可用于当前 Shell，子 Shell 默认读取不到父 Shell 定义的变量。为了把变量传递给子 Shell，需要使用 <code>export</code> 命令。这样输出的变量，对于子 Shell 来说就是环境变量。</p>
<p><code>export</code> 命令用来向子 Shell 输出变量。</p>
<div><pre><code><span>NAME</span><span>=</span>foo
<span>export</span> NAME
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面命令输出了变量 <code>NAME</code>。变量的赋值和输出也可以在一个步骤中完成。</p>
<div><pre><code><span>export</span> <span>NAME</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面命令执行后，当前 Shell 及随后新建的子 Shell，都可以读取变量 <code>$NAME</code>。</p>
<p>子 Shell 如果修改继承的变量，不会影响父 Shell。</p>
<div><pre><code><span># 输出变量 $foo</span>
$ <span>export</span> <span>foo</span><span>=</span>bar

<span># 新建子 Shell</span>
$ <span>bash</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar

<span># 修改继承的变量</span>
$ <span>foo</span><span>=</span>baz

<span># 退出子 Shell</span>
$ <span>exit</span>

<span># 读取 $foo</span>
$ <span>echo</span> <span>$foo</span>
bar
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，子 Shell 修改了继承的变量 <code>$foo</code>，对父 Shell 没有影响。</p>
<h2 id="特殊变量" tabindex="-1"> 特殊变量</h2>
<p>Bash 提供一些特殊变量。这些变量的值由 Shell 提供，用户不能进行赋值。</p>
<p>(1) <code>$?</code></p>
<p><code>$?</code> 为上一个命令的退出码，用来判断上一个命令是否执行成功。返回值是 <code>0</code>，表示上一个命令执行成功；如果是非零，上一个命令执行失败。</p>
<div><pre><code>$ <span>ls</span> doesnotexist
ls: doesnotexist: No such <span>file</span> or directory

$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>ls</code> 命令查看一个不存在的文件，导致报错。<code>$?</code> 为 1，表示上一个命令执行失败。</p>
<p>(2) <code>$$</code></p>
<p><code>$$</code> 为当前 Shell 的进程 ID。</p>
<div><pre><code>$ <span>echo</span> <span>$$</span>
<span>10662</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这个特殊变量可以用来命名临时文件。</p>
<div><pre><code><span>LOGFILE</span><span>=</span>/tmp/output_log.<span>$$</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>(3) <code>$_</code></p>
<p><code>$_</code> 为上一个命令的最后一个参数。</p>
<div><pre><code>$ <span>grep</span> dictionary /usr/share/dict/words
dictionary

$ <span>echo</span> <span>$_</span>
/usr/share/dict/words
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>(4) <code>$!</code></p>
<p><code>$!</code> 为最近一个后台执行的异步命令的进程 ID。</p>
<div><pre><code>$ firefox <span>&amp;</span>
<span>[</span><span>1</span><span>]</span> <span>11064</span>

$ <span>echo</span> <span>$!</span>
<span>11064</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>firefox</code> 是后台运行的命令，<code>$!</code> 返回该命令的进程 ID。</p>
<p>(5) <code>$0</code></p>
<p><code>$0</code> 为当前 Shell 的名称(在命令行直接执行时)或者脚本名(在脚本中执行时)。</p>
<div><pre><code>$ <span>echo</span> <span>$0</span>
<span>bash</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>上面例子中，<code>$0</code> 返回当前运行的是 Bash。</p>
<p>(6) <code>$-</code></p>
<p><code>$-</code> 为当前 Shell 的启动参数。</p>
<div><pre><code>$ <span>echo</span> $-
himBHs
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>(7) <code>$@</code> 和 <code>$#</code></p>
<p><code>$@</code> 和 <code>$#</code> 表示脚本的参数数量，参见脚本一章。</p>
<h2 id="变量的默认值" tabindex="-1"> 变量的默认值</h2>
<p>Bash 提供四个特殊语法，跟变量的默认值有关，目的是保证变量不为空。</p>
<div><pre><code><span>${varname<span>:-</span>word}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则返回 <code>word</code>。它的目的是返回一个默认值，比如 <code>${count:-0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:=</span>word}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则将它设为 <code>word</code>，并且返回 <code>word</code>。它的目的是设置变量的默认值，比如 <code>${count:=0}</code> 表示变量 <code>count</code> 不存在时返回 <code>0</code>，且将 <code>count</code> 设为 <code>0</code>。</p>
<div><pre><code><span>${varname<span>:+</span>word}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量名存在且不为空，则返回 <code>word</code>，否则返回空值。它的目的是测试变量是否存在，比如 <code>${count:+1}</code> 表示变量 <code>count</code> 存在时返回 <code>1</code>(表示 <code>true</code>)，否则返回空值。</p>
<div><pre><code><span>${varname<span>:?</span>message}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面语法的含义是，如果变量 <code>varname</code> 存在且不为空，则返回它的值，否则打印出 <code>varname: message</code>，并中断脚本的执行。如果省略了 <code>message</code>，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义，比如 <code>${count:?&quot;undefined!&quot;}</code> 表示变量 <code>count</code> 未定义时就中断执行，抛出错误，返回给定的报错信息 <code>undefined!</code>。</p>
<p>上面四种语法如果用在脚本中，变量名的部分可以用到数字 <code>1</code> 到 <code>9</code>，表示脚本的参数。</p>
<div><pre><code><span>filename</span><span>=</span><span>${1<span>:?</span>"filename missing."}</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>上面代码出现在脚本中，<code>1</code> 表示脚本的第一个参数。如果该参数不存在，就退出脚本并报错。</p>
<h2 id="declare-命令" tabindex="-1"> declare 命令</h2>
<p><code>declare</code> 命令可以声明一些特殊类型的变量，为变量设置一些限制，比如声明只读类型的变量和整数类型的变量。</p>
<p>它的语法形式如下。</p>
<div><pre><code><span>declare</span> OPTION <span>VARIABLE</span><span>=</span>value
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>declare</code> 命令的主要参数(OPTION)如下。</p>
<ul>
<li><code>-a</code>: 声明数组变量。</li>
<li><code>-f</code>: 输出所有函数定义。</li>
<li><code>-F</code>: 输出所有函数名。</li>
<li><code>-i</code>: 声明整数变量。</li>
<li><code>-l</code>: 声明变量为小写字母。</li>
<li><code>-p</code>: 查看变量信息。</li>
<li><code>-r</code>: 声明只读变量。</li>
<li><code>-u</code>: 声明变量为大写字母。</li>
<li><code>-x</code>: 该变量输出为环境变量。</li>
</ul>
<p><code>declare</code> 命令如果用在函数中，声明的变量只在函数内部有效，等同于 <code>local</code> 命令。</p>
<p>不带任何参数时，<code>declare</code> 命令输出当前环境的所有变量，包括函数在内，等同于不带有任何参数的 <code>set</code> 命令。</p>
<div><pre><code><span>declare</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>(1) <code>-i</code> 参数</strong></p>
<p><code>-i</code> 参数声明整数变量以后，可以直接进行数学运算。</p>
<div><pre><code>$ <span>declare</span> -i <span>val1</span><span>=</span><span>12</span> <span>val2</span><span>=</span><span>5</span>
$ <span>declare</span> -i result
$ <span>result</span><span>=</span>val1*val2
$ <span>echo</span> <span>$result</span>
<span>60</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，如果变量 <code>result</code> 不声明为整数，<code>val1*val2</code> 会被当作字面量，不会进行整数运算。另外，<code>val1</code> 和 <code>val2</code> 其实不需要声明为整数，因为只要 <code>result</code> 声明为整数，它的赋值就会自动解释为整数运算。</p>
<p>注意，一个变量声明为整数以后，依然可以被改写为字符串。</p>
<div><pre><code>$ <span>declare</span> -i <span>var</span><span>=</span><span>12</span>
$ <span>var</span><span>=</span>foo
$ <span>echo</span> <span>$var</span>
<span>0</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>上面例子中，变量 <code>var</code> 声明为整数，覆盖以后，Bash 不会报错，但会赋以不确定的值，上面的例子中可能输出 0，也可能输出的是 3。</p>
<p><strong>(2) <code>-x</code> 参数</strong></p>
<p><code>-x</code> 参数等同于 <code>export</code> 命令，可以输出一个变量为子 Shell 的环境变量。</p>
<div><pre><code>$ <span>declare</span> -x foo
<span># 等同于</span>
$ <span>export</span> foo
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p><strong>(3) <code>-r</code> 参数</strong></p>
<p><code>-r</code> 参数可以声明只读变量，无法改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>declare</span> -r <span>bar</span><span>=</span><span>1</span>

$ <span>bar</span><span>=</span><span>2</span>
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>

$ <span>unset</span> bar
bash: bar: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，后两个赋值语句都会报错，命令执行失败。</p>
<p><strong>(4) <code>-u</code> 参数</strong></p>
<p><code>-u</code> 参数声明变量为大写字母，可以自动把变量值转成大写字母。</p>
<div><pre><code>$ <span>declare</span> -u foo
$ <span>foo</span><span>=</span>upper
$ <span>echo</span> <span>$foo</span>
UPPER
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>(5) <code>-l</code> 参数</strong></p>
<p><code>-l</code> 参数声明变量为小写字母，可以自动把变量值转成小写字母。</p>
<div><pre><code>$ <span>declare</span> -l bar
$ <span>bar</span><span>=</span>LOWER
$ <span>echo</span> <span>$bar</span>
lower
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p><strong>(6) <code>-p</code> 参数</strong></p>
<p><code>-p</code> 参数输出变量信息。</p>
<div><pre><code>$ <span>foo</span><span>=</span>hello
$ <span>declare</span> -p foo
<span>declare</span> -- <span>foo</span><span>=</span><span>"hello"</span>
$ <span>declare</span> -p bar
bar: 未找到
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，<code>declare -p</code> 可以输出已定义变量的值，对于未定义的变量，会提示找不到。</p>
<p>如果不提供变量名，<code>declare -p</code> 输出所有变量的信息。</p>
<div><pre><code><span>declare</span> -p
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>(7) <code>-f</code> 参数</strong></p>
<p><code>-f</code> 参数输出当前环境的所有函数，包括它的定义。</p>
<div><pre><code><span>declare</span> -f
</code></pre><div aria-hidden="true"><div></div></div></div><p><strong>(8) <code>-F</code> 参数</strong></p>
<p><code>-F</code> 参数输出当前环境的所有函数名，不包含函数定义。</p>
<div><pre><code><span>declare</span> -F
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="readonly-命令" tabindex="-1"> readonly 命令</h2>
<p><code>readonly</code> 命令等同于 <code>declare -r</code>，用来声明只读变量，不能改变变量值，也不能 <code>unset</code> 变量。</p>
<div><pre><code>$ <span>readonly</span> <span>foo</span><span>=</span><span>1</span>
$ <span>foo</span><span>=</span><span>2</span>
bash: foo: 只读变量
$ <span>echo</span> <span>$?</span>
<span>1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>上面例子中，更改只读变量 <code>foo</code> 会报错，命令执行失败。</p>
<p><code>readonly</code> 命令有三个参数。</p>
<ul>
<li><code>-f</code>: 声明的变量为函数名。</li>
<li><code>-p</code>: 打印出所有的只读变量。</li>
<li><code>-a</code>: 声明的变量为数组。</li>
</ul>
<h2 id="let-命令" tabindex="-1"> let 命令</h2>
<p><code>let</code> 命令声明变量时，可以直接执行算术表达式。</p>
<div><pre><code>$ <span>let</span> <span>foo</span><span>=</span><span>1</span>+2
$ <span>echo</span> <span>$foo</span>
<span>3</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>let</code> 命令可以直接计算 <code>1 + 2</code>。</p>
<p><code>let</code> 命令的参数表达式如果包含空格，就需要使用引号。</p>
<div><pre><code><span>let</span> <span>"foo = 1 + 2"</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p><code>let</code> 可以同时对多个变量赋值，赋值表达式之间使用空格分隔。</p>
<div><pre><code>$ <span>let</span> <span>"v1 = 1"</span> <span>"v2 = v1++"</span>
$ <span>echo</span> <span>$v1</span>,<span>$v2</span>
<span>2,1</span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>上面例子中，<code>let</code> 声明了两个变量 <code>v1</code> 和 <code>v2</code>，其中 <code>v2</code> 等于 <code>v1++</code>，表示先返回 <code>v1</code> 的值，然后 <code>v1</code> 自增。</p>
<p>这种语法支持的运算符，参考《Bash 的算术运算》一章。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 命令格式</title>
      <link>https://shimonzhan.com/code/linux/command/</link>
      <guid>https://shimonzhan.com/code/linux/command/</guid>
      <source url="https://shimonzhan.com/rss.xml">Linux 命令格式</source>
      <category>Linux</category>
      <pubDate>Mon, 18 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/code/linux/command/command.html">命令格式简介</a></p>
</li>
<li>
<p><a href="/code/linux/command/dir.html">目录相关</a></p>
</li>
<li>
<p><a href="/code/linux/command/file.html">文件相关</a></p>
</li>
<li>
<p><a href="/code/linux/command/other.html">其他命令</a></p>
</li>
<li>
<p><a href="/code/linux/command/add.html">命令的自动补全</a></p>
</li>
<li>
<p><a href="/code/linux/command/excu.html">命令的执行</a></p>
</li>
<li>
<p><a href="/code/linux/command/path.html">环境变量</a></p>
</li>
<li>
<p><a href="/code/linux/command/ln.html">创建链接</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令补全</title>
      <link>https://shimonzhan.com/code/linux/command/add.html</link>
      <guid>https://shimonzhan.com/code/linux/command/add.html</guid>
      <source url="https://shimonzhan.com/rss.xml">命令补全</source>
      <description>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 cd、mkdir、cp 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。
考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。
</description>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>文件名(或者目录名)是执行 Linux 命令中最常见的参数，例如前面介绍的 <code>cd</code>、<code>mkdir</code>、<code>cp</code> 等命令，都涉及到了文件名。然而对初学者来说，输入完整的文件名感觉很麻烦，尤其面临文件名(目录名)特别长的时候。</p>
<p>考虑到这种情况，Shell (Bash) 提供了一种称为“命令行自动补全”的功能，即在输入文件名的时候，只需要输入该文件名的前几个字符，然后按 Tab 键，Shell 就可以自动将文件名补全。</p>

<p>举个例子，在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> /etc</span></span>
<span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> fs <span>&lt;</span>-- 按一次 Tab 键</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>当按下 Tab 键时，您会发现 Shell 自动将 &quot;fs&quot; 补全成了 &quot;fatab&quot;，这是因为当前 <code>/etc</code> 目录中只有 fstab 是以 &quot;fs&quot; 开头，因此 Shell 可以确定这里想要输入的文件名称为 fstab。</p>
<p>那么，如果当前目录中含有多个以指定字符(或字符串)开头的目录或文件，Shell 还可以成功辨认吗? 答案是否定的，但它会以列表的形式给出所有以指定字符或字符串开头的文件或目录，供用户选择。</p>
<p>例如，还是在 <code>/etc</code> 目录下，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> b <span>&lt;</span>-- 连续按两次 Tab 键</span></span>
<span>bash_completion.d/      blkid/          bonobo-activation/
bashrc                  bluetooth
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>可以看到，当按一次 Tab 键时，Shell 没有任何反映，原因就是当前目录下以 &quot;b&quot; 为开头的文件或目录有多个(2 个以上)，仅凭一个字符 &quot;b&quot; 无法精准判断出具体指的是哪个文件。而当再一次按下 Tab 键时，Shell 会列表的形式显示给用户当前目录下所有以 &quot;b&quot; 开头的文件或目录。</p>
<p>事实上，Shell 提供的命令行补全功能不仅适用于补全文件名，也同样适用于所有 Linux 命令。举个例子，当输入 <code>ca</code> 并连续按下 2 次 Tab 键时，Shell 会罗列出所有以 &quot;ca&quot; 开头的 Linux 命令，如下所示:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span>ca <span>&lt;</span>--连续按两次 Tab 键</span></span>
<span>cacertdir_rehash    cache_restore       capsh       catchsegv
cache_check         cal                 captoinfo
cache_dump          caller              case
cache_repair        canberra-gtk-play   cat
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>另外，Shell 还有一套被称作通配符的转用符号，这些通配符可以搜索并匹配文件名的一部分，从而大大简化了文件名的输入。</p>
<ul>
<li><code>*</code>: 匹配任意数量的字符。</li>
<li><code>?</code>: 匹配任意一个字符。</li>
<li><code>[]</code>: 匹配括号内的任意一个字符，甚至 <code>[]</code> 中还可以包含用 <code>-</code>(短横线)连接的字符或数字，表示一定范围内的字符或数字。</li>
</ul>
<p>为了学习这些通配符的用法，首先需要建立一个空目录(如 test)，并在该目录中创建一些文件(供测试用)，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost etc]</span></span><span>#</span> <span>makdir <span>test</span></span></span>
<span><span><span>[root@localhost etc]</span></span><span>#</span> <span><span>cd</span> <span>test</span></span></span>
<span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>touch</span> apple banana grape grapefruit watermelon</span></span>
<span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>apple banana grape grapefruit watermelon
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>在此基础上，继续执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> a* <span>&lt;</span>--匹配所有以 a 字符开头的文件名</span></span>
<span>apple
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> g*t <span>&lt;</span>--匹配所有以 g 字符开头，以 t 字符结尾的文件名</span></span>
<span>grapefruit
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> *e* <span>&lt;</span>--匹配所有包含 e 字符的文件名</span></span>
<span>apple grape grapefruit watermelon
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> *n* <span>&lt;</span>--匹配所有包含 n 字符的文件名</span></span>
<span>banana watermelon
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>结合以上实例，因为 <code>*</code> 可以匹配任何数量的字符，因此可以一一实现实例中标注的功能。</p>
<p>接下来，列举一下使用 ? 匹配文件名的示例:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> ????e</span></span>
<span>apple grape
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> g???e*</span></span>
<span>grape grapefruit
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>因为 1 个 ? 只能匹配 1 个任意字符，因此该示例中第一个例子表示的是匹配任意包含 5 个字符但以 e 结尾的文件(apple 和 grape)，第二例子表示匹配任何以 g 开头且第 5 个字符为 e 的文件(grape 和 grapefruit)。</p>
<p>最后，列举一些使用括号 <code>[]</code> 匹配文件名的示例:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>abw<span>]</span>*</span></span>
<span>apple banana watermelon
</span><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>agw<span>]</span>*<span>[</span>ne<span>]</span></span></span>
<span>apple grape watermelon
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>此示例中，第一个例子表示匹配任何以 a、b 或 w 开头的文件；第二个例子中表示匹配任何以 a、g、w 开头，以 n 或 e 结尾的文件名。</p>
<p>不仅如此，<code>[]</code> 中还可以通过 -(短横线)表示一定范围内的任意字符(或数字)，例如:</p>
<div><pre><code><span><span><span>[root@localhost test]</span></span><span>#</span> <span><span>ls</span> <span>[</span>a-g<span>]</span>*</span></span>
<span>apple banana grape grapefruit
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>其中，<code>[a-g]*</code> 表示匹配以字母 a 到 g 之间任何一个字母开头的文件名。</p>
]]></content:encoded>
    </item>
    <item>
      <title>基本格式</title>
      <link>https://shimonzhan.com/code/linux/command/command.html</link>
      <guid>https://shimonzhan.com/code/linux/command/command.html</guid>
      <source url="https://shimonzhan.com/rss.xml">基本格式</source>
      <category>Linux</category>
      <pubDate>Mon, 18 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="命令提示符" tabindex="-1"> 命令提示符</h2>
<p>登录系统后，第一眼看到的内容是:</p>
<div><pre><code><span>[root@localhost ~]#
</span></code></pre><div aria-hidden="true"><div></div></div></div><p>这就是 Linux 系统的命令提示符。那么，这个提示符的含义是什么呢?</p>
<ul>
<li><code>[]</code>: 这是提示符的分隔符号，没有特殊含义。</li>
<li><code>root</code>: 显示的是当前的登录用户，笔者现在使用的是 root 用户登录。</li>
<li><code>@</code>: 分隔符号，没有特殊含义。</li>
<li><code>localhost</code>: 当前系统的简写主机名(完整主机名是 <code>localhost.localdomain</code>)。</li>
<li><code>~</code>: 代表用户当前所在的目录，此例中用户当前所在的目录是家目录。</li>
<li><code>#</code>: 命令提示符，Linux 用这个符号标识登录的用户权限等级。如果是超级用户，提示符就是 <code>#</code>；如果是普通用户，提示符就是 <code>$</code>。</li>
</ul>
<p>家目录(又称主目录)是什么? Linux 系统是纯字符界面，用户登录后，要有一个初始登录的位置，这个初始登录位置就称为用户的家:
超级用户的家目录: <code>/root</code>。
普通用户的家目录: <code>/home/用户名</code>。</p>
<p>用户在自己的家目录中拥有完整权限，所以我们也建议操作实验可以放在家目录中进行。我们切换一下用户所在目录，看看有什么效果。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> /usr/local</span></span>
<span>[root@localhost local]#
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>仔细看，如果切换用户所在目录，那么命令提示符中的会变成用户当前所在目录的最后一个目录(不显示完整的所在目录 <code>/usr/loca</code>l，只显示最后一个目录 <code>local</code>)。</p>
<h2 id="命令的基本格式" tabindex="-1"> 命令的基本格式</h2>
<p>接下来看看 Linux 命令的基本格式:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>命令<span>[</span>选项<span>]</span><span>[</span>参数<span>]</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>命令格式中的 <code>[]</code> 代表可选项，也就是有些命令可以不写选项或参数，也能执行。那么，我们就用 Linux 中最常见的 <code>ls</code> 命令来解释一下命令的格式(有关 <code>ls</code> 命令的具体用法，后续章节会详细介绍)。如果按照命令的分类，那么 <code>ls</code> 命令应该属于目录操作命令。</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><ol>
<li>
<p>选项的作用</p>
<p>选项的作用是调整命令功能。如果没有选项，那么命令只能执行最基本的功能；而一旦有选项，则可以显示更加丰富的数据。</p>
<p>Linux 的选项又分为短格式选项(<code>-l</code>)和长格式选项(-<code>-all</code>)。短格式选项是英文的简写，用一个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>而长格式选项是英文完整单词，一般用两个减号调用，例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls --all</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项。当然也有例外，比如 <code>ls</code> 命令的短格式选项 <code>-l</code> 就没有对应的长格式选项。所以具体的命令选项可以通过后面我们要学习的帮助命令来进行査询。</p>
</li>
<li>
<p>参数的作用</p>
<p>参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls -l anaconda-ks.cfg</span>
-rw-------.1 root root <span>1207</span> <span>1</span> 月 <span>14</span> <span>18</span>:18 anaconda-ks.cfg
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>但是为什么一开始 <code>ls</code> 命令可以省略参数? 那是因为有默认参数。命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数。例如:</p>
<div><pre><code><span>[</span>root@localhost ~<span>]</span><span># ls</span>
anaconda-ks.cfg install.log install.log.syslog
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这个 <code>ls</code> 命令后面没有指定参数，默认参数是当前所在位置，所以会显示当前目录下的文件名。</p>
</li>
</ol>
<p>总结一下: <strong>命令的选项用于调整命令功能，而命令的参数是这个命令的操作对象。</strong></p>
]]></content:encoded>
    </item>
    <item>
      <title>文件夹</title>
      <link>https://shimonzhan.com/code/linux/command/dir.html</link>
      <guid>https://shimonzhan.com/code/linux/command/dir.html</guid>
      <source url="https://shimonzhan.com/rss.xml">文件夹</source>
      <category>Linux</category>
      <pubDate>Mon, 18 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="pwd-命令" tabindex="-1"> pwd 命令</h2>
<p>由于 Linux 文件系统中有许多目录，当用户执行一条 Linux 命令又没有指定该命令或参数所在的目录时，Linux 系统就会首先在当前目录(目前的工作目录)搜寻这个命令或它的参数。因此，用户在执行命令之前，常常需要确定目前所在的工作目录，即当前目录。</p>
<p>当用户登陆 Linux 系统之后，其当前目录就是它的主目录。那么，如何确定当前目录呢? 可以使用 Linux 系统的 pwd 命令来显示当前目录的绝对路径。</p>
<p>pwd 命令，是 Print Working Directory (打印工作目录)的缩写，功能是显示用户当前所处的工作目录。该命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>pwd</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="cd-命令" tabindex="-1"> cd 命令</h2>
<p>cd 命令，是 Change Directory 的缩写，用来切换工作目录。</p>
<p>Linux 命令按照来源方式，可分为两种，分别是 Shell 内置命令和外部命令。所谓 Shell 内置命令，就是 Shell 自带的命令，这些命令是没有执行文件的；而外部命令就是由程序员单独开发的，所以会有命令的执行文件。Linux 中的绝大多数命令是外部命令，而 cd 命令是一个典型的 Shell 内置命令，所以 cd 命令没有执行文件所在路径。</p>
<p>cd 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> <span>[</span>相对路径或绝对路径<span>]</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>除此之外，cd 命令后面可以跟一些特殊符号，表达固定的含义。</p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>作 用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>~</code></td>
<td>代表当前登录用户的主目录</td>
</tr>
<tr>
<td><code>~&lt;用户名&gt;</code></td>
<td>表示切换至指定用户的主目录</td>
</tr>
<tr>
<td><code>-</code></td>
<td>代表上次所在目录</td>
</tr>
<tr>
<td><code>.</code></td>
<td>代表当前目录</td>
</tr>
<tr>
<td><code>..</code></td>
<td>代表上级目录</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>在 Linux 系统中，根目录确实存在 <code>.</code>(当前目录)以及 <code>..</code>(当前目录的父目录)两个目录，但由于根目录是最顶级目录，因此根目录的 <code>..</code> 和 <code>.</code> 的属性和权限完全一致，也就是说，根目录的父目录是自身。</p>
</div>
<h2 id="ls-命令" tabindex="-1"> ls 命令</h2>
<p>ls 命令，list 的缩写，是最常见的目录操作命令，其主要功能是显示当前目录下的内容。此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span> <span>[</span>选项<span>]</span> 目录名称</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>| 选项                                                | 功能                                                                                                                                              |
| --------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------- |
| -a                                                  | 显示全部的文件，包括隐藏文件(开头为 <code>.</code> 的文件)也一起罗列出来，这是最常用的选项之一。                                                             |
| -A                                                  | 显示全部的文件，连同隐藏文件，但不包括 <code>.</code> 与 <code>..</code> 这两个目录。                                                                                   |
| -d                                                  | 仅列出目录本身，而不是列出目录内的文件数据。                                                                                                      |
| -f                                                  | ls 默认会以文件名排序，使用 <code>-f</code> 选项会直接列出结果，而不进行排序。                                                                               |
| -F                                                  | 在文件或目录名后加上文件类型的指示符号，例如，<code>*</code> 代表可运行文件，<code>/</code> 代表目录，= 代表 socket 文件，                                              | 代表 FIFO 文件。 |
| -h                                                  | 以人们易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等。                                                                                       |
| -i                                                  | 显示 inode 节点信息。                                                                                                                             |
| -l                                                  | 使用长格式列出文件和目录信息。                                                                                                                    |
| -n                                                  | 以 UID 和 GID 分别代替文件用户名和群组名显示出来。                                                                                                |
| -r                                                  | 将排序结果反向输出，比如，若原本文件名由小到大，反向则为由大到小。                                                                                |
| -R                                                  | 连同子目录内容一起列出来，等於将该目录下的所有文件都显示出来。                                                                                    |
| -S                                                  | 以文件容量大小排序，而不是以文件名排序。                                                                                                          |
| -t                                                  | 以时间排序，而不是以文件名排序。                                                                                                                  |
| --color=never<br />--color=always<br />--color=auto | <code>never</code> 表示不依据文件特性给予颜色显示。<br /><code>always</code> 表示显示颜色，ls 默认采用这种方式。<br /><code>auto</code> 表示让系统自行依据配置来判断是否给予颜色。 |
| --full-time                                         | 以完整时间模式 (包含年、月、日、时、分)输出                                                                                                       |
| --time={atime,ctime}                                | 输出 access 时间或改变权限属性时间(ctime)，而不是内容变更时间。                                                                                   |</p>
<div><p>提示</p>
<p>当 ls 命令不使用任何选项时，默认只会显示非隐藏文件的名称，并以文件名进行排序，同时会根据文件的具体类型给文件名配色(蓝色显示目录，白色显示一般文件)。</p>
</div>
<div><p>提示</p>
<p>ls 命令使用了 <code>-l</code> 选项，显示出文件的详细信息，此选项显示的这 7 列的含义分别是:</p>
<ul>
<li>第一列: 规定了不同的用户对文件所拥有的权限，具体权限的含义将在后续章节中讲解。</li>
<li>第二列: 引用计数，文件的引用计数代表该文件的硬链接个数，而目录的引用计数代表该目录有多少个一级子目录。</li>
<li>第三列: 所有者，也就是这个文件属于哪个用户。默认所有者是文件的建立用户。</li>
<li>第四列: 所属组，默认所属组是文件建立用户的有效组，一般情况下就是建立用户的所在组。</li>
<li>第五列: 大小，默认单位是字节。</li>
<li>第六列: 文件修改时间，文件状态修改时间或文件数据修改时间都会更改这个时间，注意这个时间不是文件的创建时间。</li>
<li>第七列: 文件名或目录名。</li>
</ul>
</div>
<h2 id="mkdir-命令" tabindex="-1"> mkdir 命令</h2>
<p>mkdir 命令，是 make directories 的缩写，用于创建新目录，此命令所有用户都可以使用。</p>
<p>mkdir 命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> <span>[</span>-mp<span>]</span> 目录名</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>-m 选项用于手动配置所创建目录的权限，而不再使用默认权限。</li>
<li>-p 选项递归创建所有目录，以创建 <code>/home/test/demo</code> 为例，在默认情况下，您需要一层一层的创建各个目录，而使用 <code>-p</code> 选项，则系统会自动帮您创建 <code>/home</code>、<code>/home/test</code> 以及 <code>/home/test/demo</code>。</li>
</ul>
<h2 id="rmdir-命令" tabindex="-1"> rmdir 命令</h2>
<p>和 mkdir 命令(创建空目录)恰好相反，rmdir(remove empty directories 的缩写)命令用于删除空目录，此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rmdir</span> <span>[</span>-p<span>]</span> 目录名</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>-p 选项用于递归删除空目录。</p>
<div><p>提示</p>
<p>rmdir 命令的作用十分有限，因为只能刪除空目录，所以一旦目录中有内容，就会报错。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>命令执行</title>
      <link>https://shimonzhan.com/code/linux/command/excu.html</link>
      <guid>https://shimonzhan.com/code/linux/command/excu.html</guid>
      <source url="https://shimonzhan.com/rss.xml">命令执行</source>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>前面讲过，在 Linux 系统中“一切皆文件”，Linux 命令也不例外。那么，当编辑完成 Linux 命令并回车后，系统底层到底发生了什么事情呢?</p>
<p>简单来说，Linux 命令的执行过程分为如下 4 个步骤。</p>
<ol>
<li>
<p>判断路径</p>
<p>判断用户是否以绝对路径或相对路径的方式输入命令(如 <code>/bin/ls</code>)，如果是的话直接执行。</p>
</li>
<li>
<p>检查别名</p>
<p>Linux 系统会检查用户输入的命令是否为 “别名命令”。要知道，通过 alias 命令是可以给现有命令自定义别名的，即用一个自定义的命令名称来替换原本的命令名称。</p>
<p>例如，我们经常使用的 <code>rm</code> 命令，其实就是 <code>rm -i</code> 这个整体的别名:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>rm</span></span></span>
<span>alias rm='rm -i'
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这使得当使用 rm 命令删除指定文件时，Linux 系统会要求我们再次确认是否执行删除操作。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> a.txt <span>&lt;</span>-- 假定当前目录中已经存在 a.txt 文件</span></span>
<span>rm: remove regular file 'a.txt'? y  &lt;-- 手动输入 y，即确定删除
[root@localhost ~]#
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>这里可以使用 <code>unalias</code> 命令，将 Linux 系统设置的 <code>rm</code> 别名删除掉，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>rm</span></span></span>
<span>alias rm='rm -i'
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>unalias</span> <span>rm</span></span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> a.txt</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span>  <span><span>&lt;</span>--直接删除，不再询问</span></span>
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>判断是内部命令还是外部命令</p>
<p>Linux 命令行解释器 (又称为 Shell) 会判断用户输入的命令是内部命令还是外部命令。其中，内部命令指的是解释器内部的命令，会被直接执行；而用户通常输入的命令都是外部命令，这些命令交给步骤四继续处理。
内部命令由 Shell 自带，会随着系统启动，可以直接从内存中读取；而外部命令仅是在系统中有对应的可执行文件，执行时需要读取该文件。</p>
<p>判断一个命令属于内部命令还是外部命令，可以使用 <code>type</code> 命令实现。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>type</span> <span>pwd</span></span></span>
<span>pwd is a shell builtin  &lt;-- pwd是内部命令
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>type</span> <span>top</span></span></span>
<span>top is /usr/bin/top  &lt;-- top是外部命令
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div></li>
<li>
<p>查找外部命令对应的可执行文件</p>
<p>当用户执行的是外部命令时，系统会在指定的多个路径中查找该命令的可执行文件，而定义这些路径的变量，就称为 PATH 环境变量，其作用就是告诉 Shell 待执行命令的可执行文件可能存放的位置，也就是说，Shell 会在 PATH 变量包含的多个路径中逐个查找，直到找到为止(如果找不到，Shell 会提供用户“找不到此命令”)。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>文件</title>
      <link>https://shimonzhan.com/code/linux/command/file.html</link>
      <guid>https://shimonzhan.com/code/linux/command/file.html</guid>
      <source url="https://shimonzhan.com/rss.xml">文件</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="touch-命令" tabindex="-1"> touch 命令</h2>
<p>需要注意的是，touch 命令不光可以用来创建文件(当指定操作文件不存在时，该命令会在当前位置建立一个空文件)，此命令更重要的功能是修改文件的时间参数(但当文件存在时，会修改此文件的时间参数)。</p>
<p>Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间:</p>
<ul>
<li>访问时间 (Access Time，简称 atime): 只要文件的内容被读取，访问时间就会更新。例如，使用 <code>cat</code> 命令可以查看文件的内容，此时文件的访问时间就会发生改变。</li>
<li>数据修改时间 (Modify Time，简称 mtime): 当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变。</li>
<li>状态修改时间 (Change Time，简称 ctime): 当文件的状态发生变化，就会相应改变这个时间。比如说，如果文件的权限或者属性发生改变，此时间就会相应改变。</li>
</ul>
<p>touch 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> <span>[</span>选项<span>]</span> 文件名</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-a: 只修改文件的访问时间；</li>
<li>-c: 仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件。</li>
<li>-d: 后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间。</li>
<li>-m: 只修改文件的数据修改时间。</li>
<li>-t: 命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm。</li>
</ul>
<p>可以看到，touch 命令可以只修改文件的访问时间，也可以只修改文件的数据修改时间，但是不能只修改文件的状态修改时间。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即状态修改时间会随之改变(更新为操作当前文件的真正时间)。</p>
<h2 id="ln-命令" tabindex="-1"> ln 命令</h2>
<p>如果要想说清楚 ln 命令，则必须先解释下 ext 文件系统(Linux 文件系统)是如何工作的。我们在前面讲解了分区的格式化就是写入文件系统，而我们的 Linux 目前使用的是 ext4 文件系统。</p>
<p>ext4 文件系统会把分区主要分为两大部分(暂时不提超级块): 小部分用于保存文件的 inode (i 节点)信息；剩余的大部分用于保存 block 信息。</p>
<p>inode 的默认大小为 128 Byte，用来记录文件的权限(r、w、x)、文件的所有者和属组、文件的大小、文件的状态改变时间(ctime)、文件的最近一次读取时间(atime)、文件的最近一次修改时间(mtime)、文件的数据真正保存的 block 编号。每个文件需要占用一个 inode。大家如果仔细查看，就会发现 inode 中是不记录文件名的，那是因为文件名记录在文件所在目录的 block 中。</p>
<p>block 的大小可以是 1KB、2KB、4KB，默认为 4KB。block 用于实际的数据存储，如果一个 block 放不下数据，则可以占用多个 block。例如，有一个 10KB 的文件需要存储，则会占用 3 个 block，虽然最后一个 block 不能占满，但也不能再放入其他文件的数据。这 3 个 block 有可能是连续的，也有可能是分散的。</p>
<p>由此，我们可以知道以下 2 个重要的信息:</p>
<ol>
<li>每个文件都独自占用一个 inode，文件内容由 inode 的记录来指向；</li>
<li>如果想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块；</li>
</ol>
<p>了解了 Linux 系统底层文件的存储状态后，接下来学习 ln 命令。</p>
<p>ln 命令用于给文件创建链接，根据 Linux 系统存储文件的特点，链接的方式分为以下 2 种:</p>
<ul>
<li>软链接: 类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录。</li>
<li>硬链接: 我们知道，文件的基本信息都存储在 inode 中，而硬链接指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息。</li>
</ul>
<p>ln 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> <span>[</span>选项<span>]</span> 源文件 目标文件</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-s: 建立软链接文件。如果不加 <code>-s</code> 选项，则建立硬链接文件；</li>
<li>-f: 强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；</li>
</ul>
<h3 id="ln-扩展介绍" tabindex="-1"> ln 扩展介绍</h3>
<ul>
<li><a href="/code/linux/command/ln.html">点击前往</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>链接</title>
      <link>https://shimonzhan.com/code/linux/command/ln.html</link>
      <guid>https://shimonzhan.com/code/linux/command/ln.html</guid>
      <source url="https://shimonzhan.com/rss.xml">链接</source>
      <description>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。
</description>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>建立硬链接和软链接非常简单，那这两种链接有什么区别? 它们都有什么作用? 这才是链接文件最不容易理解的地方，我们分别来讲讲。</p>

<h2 id="ln-创建硬链接" tabindex="-1"> ln 创建硬链接</h2>
<p>我们再来建立一个硬链接文件，然后看看这两个文件的特点。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> <span>test</span></span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> /root/test /tmp/test-hard</span></span>
<span>#给源文件建立硬链接文件 /tmp/test-hard
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i /root/test /tmp/test-hard</span></span>
<span>262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /root/test
hard
262147 -rw-r--r-- 2 root root 0 6月 19 10:06 /tmp/test-hard
#查看两个文件的详细信息，可以发现这两个文件的 inode 号是一样的，"ll"等同于"ls -l"。
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这里有一件很奇怪的事情，我们之前在讲 inode 号的时候说过，每个文件的 inode 号都应该是不一样的。inode 号就相当于文件 ID，我们在查找文件的时候，要先查找 inode 号，才能读取到文件的内容。</p>
<p>但是这里源文件和硬链接文件的 inode 号居然是一样的，那我们在查找文件的时候，到底找到的是哪一个文件呢? 我们来画一张示意图，如图 2 所示。</p>
<p><img src="@source/code/linux/assets/hardlink.jpg" alt="Hardlink" loading="lazy"></p>
<p>在 inode 信息中，是不会记录文件名称的，而是把文件名记录在上级目录的 block 中。也就是说，目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应；而文件的 block 中记录的才是文件实际的数据。</p>
<p>当我们查找一个文件，比如 <code>/root/test</code> 时，要经过以下步骤:</p>
<ul>
<li>首先找到根目录的 inode(根目录的 inode 是系统已知的，inode 号是 2)，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限，则可以在根目录的 block 中访问到 <code>/root</code> 的文件名及对应的 inode 号。</li>
<li>通过 <code>/root/</code> 目录的 inode 号，可以查找到 <code>/root/</code> 目录的 inode 信息，接着判断用户是否有权限访问 <code>/root/</code> 目录的 block。</li>
<li>如果有权限，则可以从 <code>/root/</code> 目录的 block 中读取到 test 文件的文件名及对应的 inode 号。</li>
<li>通过 test 文件的 inode 号，就可以找到 test 文件的 inode 信息，接着判断用户是否有权限访问 test 文件的 block。</li>
<li>如果有权限，则可以读取 block 中的数据，这样就完成了 <code>/root/test</code> 文件的读取与访问。</li>
</ul>
<p>按照这个步骤，在给源文件 <code>/root/test</code> 建立了硬链接文件 <code>/tmp/test-hard</code> 之后，在 <code>/root/</code> 目录和 <code>/tmp/</code> 目录的 block 中就会建立 test 和 test-hard 的信息，这个信息主要就是文件名和对应的 inode 号。但是我们会发现 test 和 test-hard 的 inode 信息居然是一样的，那么，我们无论访问哪个文件，最终都会访问 inode 号是 262147 的文件信息。</p>
<p>这就是硬链接的原理。硬链接的特点如下:</p>
<ul>
<li>不论是修改源文件(test 文件)，还是修改硬链接文件(test-hard 文件)，另一个文件中的数据都会发生改变。</li>
<li>不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件(inode 号是 262147 的文件)都可以被访问。</li>
<li>硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。</li>
<li>硬链接不能跨文件系统(分区)建立，因为在不同的文件系统中，inode 号是重新计算的。</li>
<li>硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂。</li>
</ul>
<p>硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征。这些特征都使得硬链接并不常用，大家有所了解就好。</p>
<h2 id="ln-创建软链接" tabindex="-1"> ln 创建软链接</h2>
<p>软链接也称作符号链接，相比硬链接来讲，软链接就要常用多了。我们先建立一个软链接，再来看看软链接的特点。</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> check</span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> -s /root/check /tmp/check-soft</span></span>
<span>#建立软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -id /root/check /tmp/check-soft</span></span>
<span>262154 -rw-r--r-- 1 root root 0 6月 19 11:30 /root/check
917507 lrwxrwxrwx 1 root root 11 6月 19 11:31 /tmp/ check-soft -> /root/check
#软链接和源文件的 inode 号不一致，软链接通过 -> 明显地标识出源文件的位置
#在软链接的权限位 lrwxrwxrwx 中，l 就代表软链接文件
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>再强调一下，软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错，无法正常使用。</p>
<p>软链接的标志非常明显，首先，权限位中&quot;l&quot;表示这是一个软链接文件；其次，在文件的后面通过 &quot;-&gt;&quot; 显示出源文件的完整名字。所以软链接比硬链接的标志要明显得多，而且软链接也不像硬链接的限制那样多，比如软链接可以链接目录，也可以跨分区来建立软链接。</p>
<p>软链接完全可以当作 Windows 的快捷方式来对待，它的特点和快捷方式一样，我们更推荐大家使用软链接，而不是硬链接。</p>
<p>大家在学习软链接的时候会有一些疑问: Windows 的快捷方式是由于源文件放置的位置过深，不容易找到，建立一个快捷方式放在桌面，方便查找，那 Linux 的软链接的作用是什么呢?</p>
<p>软链接主要是为了照顾管理员的使用习惯。比如，有些系统的自启动文件 <code>/etc/rc.local</code> 放置在 <code>/etc</code> 目录中，而有些系统却将其放置在 <code>/etc/rc.d/rc.local</code> 中，那么干脆对这两个文件建立软链接，不论您习惯操作哪一个文件，结果都是一样的。</p>
<p>如果您比较细心，则应该已经发现软链接和源文件的 inode 号是不一致的，我们也画一张示意图来看看软链接的原理，如图 3 所示。</p>
<p><img src="@source/code/linux/assets/softlink.jpg" alt="软链接示意图" loading="lazy"></p>
<p>软链接和硬链接在原理上最主要的不同在于: 硬链接不会建立自己的 inode 索引和 block(数据块)，而是直接指向源文件的 inode 信息和 block，所以硬链接和源文件的 inode 号是一致的；而软链接会真正建立自己的 inode 索引和 block，所以软链接和源文件的 inode 号是不一致的，而且在软链接的 block 中，写的不是真正的数据，而仅仅是源文件的文件名及 inode 号。</p>
<p>我们来看看访问软链接的步骤和访问硬链接的步骤有什么不同。</p>
<ul>
<li>首先找到根目录的 inode 索引信息，然后判断用户是否有权限访问根目录的 block。</li>
<li>如果有权限访问根目录的 block，就会在 block 中查找到 <code>/tmp/</code> 目录的 inode 号。</li>
<li>接着访问 <code>/tmp/</code> 目录的 inode 信息，判断用户是否有权限访问 <code>/tmp/</code> 目录的 block。</li>
<li>如果有权限，就会在 block 中读取到软链接文件 check-soft 的 inode 号。因为软链接文件会真正建立自己的 inode 索引和 block，所以软链接文件和源文件的 inode 号是不一样的。</li>
<li>通过软链接文件的 inode 号，找到了 check-soft 文件 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会发现 check-soft 文件的 block 中没有实际数据，仅有源文件 check 的 inode 号。</li>
<li>接着通过源文件的 inode 号，访问到源文件 check 的 inode 信息，判断用户是否有权限访问 block。</li>
<li>如果有权限，就会在 check 文件的 block 中读取到真正的数据，从而完成数据访问。</li>
</ul>
<p>通过这个过程，我们就可以总结出软链接的特点(软链接的特点和 Windows 中的快捷方式完全一致)。</p>
<ul>
<li>不论是修改源文件(check)，还是修改硬链接文件(check-soft)，另一个文件中的数据都会发生改变。</li>
<li>删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。</li>
<li>软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件名及 inode 号。</li>
<li>软链接可以链接目录。</li>
<li>软链接可以跨分区。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>其他文件命令</title>
      <link>https://shimonzhan.com/code/linux/command/other.html</link>
      <guid>https://shimonzhan.com/code/linux/command/other.html</guid>
      <source url="https://shimonzhan.com/rss.xml">其他文件命令</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="cp-命令" tabindex="-1"> cp 命令</h2>
<p>cp 命令，主要用来复制文件和目录，同时借助某些选项，还可以实现复制整个目录，以及比对两文件的新旧而予以升级等功能。</p>
<p>cp 命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> <span>[</span>选项<span>]</span> 源文件 目标文件</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-a: 相当于 -d、-p、-r 选项的集合，这几个选项我们一一介绍；</li>
<li>-d: 如果源文件为软链接(对硬链接无效)，则复制出的目标文件也为软链接；</li>
<li>-i: 询问，如果目标文件已经存在，则会询问是否覆盖；</li>
<li>-l: 把目标文件建立为源文件的硬链接文件，而不是复制源文件；</li>
<li>-s: 把目标文件建立为源文件的软链接文件，而不是复制源文件；</li>
<li>-p: 复制后目标文件保留源文件的属性(包括所有者、所属组、权限和时间)；</li>
<li>-r: 递归复制，用于复制目录；</li>
<li>-u: 若目标文件比源文件有差异，则使用该选项可以更新目标文件，此选项可用于对文件的升级和备用。</li>
</ul>
<p>需要注意的是，源文件可以有多个，但这种情况下，目标文件必须是目录才可以。</p>
<h3 id="cp-命令基本用法" tabindex="-1"> cp 命令基本用法</h3>
<p>cp 命令既可以复制文件，也可以复制目录。我们先来看看如何复制文件，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#建立源文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/</span></span>
<span>#把源文件不改名复制到 /tmp/ 目录下
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>如果需要改名复制，则命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/bols</span></span>
<span>#改名复制
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>如果复制的目标位置已经存在同名的文件，则会提示是否覆盖，因为 cp 命令默认执行的是 <code>cp -i</code> 的别名，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> cangls /tmp/</span></span>
<span>cp:是否覆盖"/tmp/cangls"?y
#目标位置有同名文件，所以会提示是否覆盖
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>接下来我们看看如何复制目录，其实复制目录只需使用 <code>-r</code> 选项即可，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> movie</span></span>
<span>#建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -r /root/movie/ /tmp/</span></span>
<span>#目录原名复制
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="复制软链接文件" tabindex="-1"> 复制软链接文件</h3>
<p>如果源文件不是一个普通文件，而是一个软链接文件，那么是否可以复制软链接的属性呢? 我们试试:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ln</span> -s /root/cangls /tmp/cangls_slink</span></span>
<span>#建立一个测试软链接文件/tmp/cangls_slink
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /tmp/cangls_slink</span></span>
<span>lrwxrwxrwx 1 root root 12 6 月 14 05:53 /tmp/cangls_slink -> /root/cangls
#源文件本身就是一个软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> /tmp/cangls_slink /tmp/cangls_t1</span></span>
<span>#复制软链接文件，但是不加"-d"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -d /tmp/cangls_slink /tmp/cangls_t2</span></span>
<span>#复制软链接文件，加入"-d"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /tmp/cangls_t1 /tmp/cangls_t2</span></span>
<span>-rw-r--r-- 1 root root 0 6月 14 05:56 /tmp/cangls_t1
#会发现不加"-d"选项，实际复制的是软链接的源文件，而不是软链接文件
lrwxrwxrwx 1 root root 12 6 月 14 05:56/tmp/ cangls_t2-> /root/cangls
#而如果加入了"-d"选项，则会复制软链接文件
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>这个例子说明，如果在复制软链接文件时不使用 <code>-d</code> 选项，则 <code>cp</code> 命令复制的是源文件，而不是软链接文件；只有加入了 <code>-d</code> 选项，才会复制软链接文件。请大家注意，<code>-d</code> 选项对硬链接是无效的。</p>
<h3 id="保留源文件属性复制" tabindex="-1"> 保留源文件属性复制</h3>
<p>我们发现，在执行复制命令后，目标文件的时间会变成复制命令的执行时间，而不是源文件的时间。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> /var/lib/mlocate/mlocate.db /tmp/</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /var/lib/mlocate/mlocate.db</span></span>
<span>-rw-r-----1 root slocate2328027 6月 14 02:08/var/lib/mlocate/mlocate.db
#注意源文件的时间和所属组
[root@localhost ~]#ll /tmp/mlocate.db
-rw-r----- 1 root root2328027 6 月 14 06:05/tmp/mlocate.db
#由于复制命令由root用户执行，所以目标文件的所属组为了root，而且时间也变成了复制命令的执行时间
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>而当我们执行备份、曰志备份的时候，这些文件的时间可能是一个重要的参数，这就需执行 <code>-p</code> 选项了。这个选项会保留源文件的属性，包括所有者、所属组和时间。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -p /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span>
<span>#使用"-p"选项
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll /var/lib/mlocate/mlocate.db /tmp/mlocate.db_2</span></span>
<span>-rw-r----- root slocate 2328027 6月 14 02:08 /tmp/mlocate.db_2
-rw-r----- root slocate 2328027 6月 14 02:08 /var/lib/mlocate/mlocate.db
#源文件和目标文件的所有属性都一致，包括时间
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>我们之前讲过，<code>-a</code> 选项相当于 &quot;-d、-p、-r&quot; 选项，这几个选项我们已经分别讲过了。所以，当我们使用 <code>-a</code> 选项时，目标文件和源文件的所有属性都一致，包括源文件的所有者，所属组、时间和软链接性。使用 <code>-a</code> 选项来取代 &quot;-d、-p、-r&quot; 选项更加方便。</p>
<h3 id="l-和-s-选项" tabindex="-1"> &quot;-l&quot; 和 &quot;-s&quot; 选项</h3>
<p>我们如果使用 <code>-l</code> 选项，则目标文件会被建立为源文件的硬链接；而如果使用了 <code>-s</code> 选项，则目标文件会被建立为源文件的软链接。</p>
<p>这两个选项和 <code>-d</code> 选项是不同的，<code>d</code> 选项要求源文件必须是软链接，目标文件才会复制为软链接；而 <code>-l</code> 和 <code>-s</code> 选项的源文件只需是普通文件，目标文件就可以直接复制为硬链接和软链接。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> bols</span></span>
<span>#建立测试文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i bols</span></span>
<span>262154-rw-r--r-- 1 root root 0 6月 14 06:26 bols
#源文件只是一个普通文件，而不是软链接文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -l /root/bols /tmp/bols_h</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cp</span> -s /root/bols /tmp/bols_s</span></span>
<span>#使用"-l" 和"-s"选项复制
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>ll -i /tmp/bols_h /tmp/bols_s</span></span>
<span>262154-rw-r--r-- 2root root 0 6 月 14 06:26/tmp/bols_h
#目标文件 /tmp/bols_h 为源文件的硬链接文件
932113 lrwxrwxrwx 1 root root 10 6 月 14 06:27/tmp/bols_s -> /root/bols
#目标文件 /tmp/bols_s 为源文件的软链接文件
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="rm-命令" tabindex="-1"> rm 命令</h2>
<p>当 Linux 系统使用很长时间之后，可能会有一些已经没用的文件(即垃圾)，这些文件不但会消耗宝贵的硬盘资源，还是降低系统的运行效率，因此需要及时地清理。</p>
<p>rm 是强大的删除命令，它可以永久性地删除文件系统中指定的文件或目录。在使用 rm 命令删除文件或目录时，系统不会产生任何提示信息。此命令的基本格式为:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>rm<span>[</span>选项<span>]</span> 文件或目录</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-f: 强制删除(force)，和 <code>-i</code> 选项相反，使用 <code>-f</code>，系统将不再询问，而是直接删除目标文件或目录。</li>
<li>-i: 和 <code>-f</code> 正好相反，在删除文件或目录之前，系统会给出提示信息，使用 <code>-i</code> 可以有效防止不小心删除有用的文件或目录。</li>
<li>-r: 递归删除，主要用于删除目录，可删除指定目录及包含的所有内容，包括所有的子目录和文件。</li>
</ul>
<div><p>提示</p>
<p>rm 命令是一个具有破坏性的命令，因为 rm 命令会永久性地删除文件或目录，这就意味着，如果没有对文件或目录进行备份，一旦使用 rm 命令将其删除，将无法恢复，因此，尤其在使用 rm 命令删除目录时，要慎之又慎。</p>
</div>
<h3 id="基本用法" tabindex="-1"> 基本用法</h3>
<p>rm 命令如果任何选项都不加，则默认执行的是 <code>rm -i 文件名</code>，也就是在删除一个文件之前会先询问是否删除。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> cangls</span></span>
<span>rm:是否删除普通空文件"cangls"?y
#删除前会询问是否删除
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="删除目录" tabindex="-1"> 删除目录</h3>
<p>如果需要删除目录，则需要使用 <code>-r</code> 选项。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> -p /test/lm/movie/jp</span></span>
<span>#递归建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> /test</span></span>
<span>rm:无法删除"/test/": 是一个目录
#如果不加"-r"选项，则会报错
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> -r /test</span></span>
<span>rm:是否进入目录"/test"?y
rm:是否进入目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm/movie/jp"?y
rm:是否删除目录"/test/lm/movie"?y
rm:是否删除目录"/test/lm"?y
rm:是否删除目录"/test"?y
#会分别询问是否进入子目录、是否删除子目录
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>大家会发现，如果每级目录和每个文件都需要确认，那么在实际使用中简直是灾难!</p>
<h3 id="强制删除" tabindex="-1"> 强制删除</h3>
<p>如果要删除的目录中有 1 万个子目录或子文件，那么普通的 rm 删除最少需要确认 1 万次。所以，在真正删除文件的时候，我们会选择强制删除。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> -p /test/lm/movie/jp</span></span>
<span>#重新建立测试目录
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>rm</span> -rf /test</span></span>
<span>#强制删除，一了百了
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><p>加入了强制功能之后，删除就会变得很简单，但是需要注意，数据强制删除之后无法恢复，除非依赖第三方的数据恢复工具，如 extundelete 等。但要注意，数据恢复很难恢复完整的数据，一般能恢复 70%~80% 就很难得了。所以，与其把宝压在数据恢复上，不如养成良好的操作习惯。</p>
<p>虽然 <code>-rf</code> 选项是用来删除目录的，但是删除文件也不会报错。所以，为了使用方便，一般不论是删除文件还是删除目录，都会直接使用 <code>-rf</code> 选项。</p>
<h2 id="mv-命令" tabindex="-1"> mv 命令</h2>
<p>mv 命令(move 的缩写)，既可以在不同的目录之间移动文件或目录，也可以对文件和目录进行重命名。该命令的基本格式如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> 【选项】 源文件 目标文件</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>选项:</p>
<ul>
<li>-f: 强制覆盖，如果目标文件已经存在，则不询问，直接强制覆盖；</li>
<li>-i: 交互移动，如果目标文件已经存在，则询问用户是否覆盖(默认选项)；</li>
<li>-n: 如果目标文件已经存在，则不会覆盖移动，而且不询问用户；</li>
<li>-v: 显示文件或目录的移动过程；</li>
<li>-u: 若目标文件已经存在，但两者相比，源文件更新，则会对目标文件进行升级；</li>
</ul>
<p>需要注意的是，同 rm 命令类似，mv 命令也是一个具有破坏性的命令，如果使用不当，很可能给系统带来灾难性的后果。</p>
<h3 id="移动文件或目录" tabindex="-1"> 移动文件或目录</h3>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> cangls /tmp</span></span>
<span>#移动之后，源文件会被删除，类似剪切
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> movie</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> movie/ /tmp</span></span>
<span>#也可以移动目录。和 rm、cp 不同的是，mv 移动目录不需要加入 "-r" 选项
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>如果移动的目标位置已经存在同名的文件，则同样会提示是否覆盖，因为 mv 命令默认执行的也是 <code>mv -i</code> 的别名，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#重新建立文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> cangls /tmp</span></span>
<span>mv:县否覆盖"tmp/cangls"? y
#由于 /tmp 目录下已经存在 cangls 文件，所以会提示是否覆盖，需要手工输入 y 覆盖移动
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="强制移动" tabindex="-1"> 强制移动</h3>
<p>之前说过，如果目标目录下已经存在同名文件，则会提示是否覆盖，需要手工确认。这时如果移动的同名文件较多，则需要一个一个文件进行确认，很不方便。</p>
<p>如果我们确认需要覆盖已经存在的同名文件，则可以使用 <code>-f</code> 选项进行强制移动，这就不再需要用户手工确认了。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> cangls</span></span>
<span>#重新建立文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -f cangls /tmp</span></span>
<span>#就算 /tmp/ 目录下已经存在同名的文件，由于"-f"选项的作用，所以会强制覆盖
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div></div></div><h3 id="不覆盖移动" tabindex="-1"> 不覆盖移动</h3>
<p>既然可以强制覆盖移动，那也有可能需要不覆盖的移动。如果需要移动几百个同名文件，但是不想覆盖，这时就需要 <code>-n</code> 选项的帮助了。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span> /tmp</span></span>
<span>/tmp/bols /tmp/cangls
#在/tmp/目录下已经存在bols、cangls文件了
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -vn bols cangls lmls /tmp/、</span></span>
<span>"lmls"->"/tmp/lmls"
#再向 /tmp/ 目录中移动同名文件，如果使用了 "-n" 选项，则可以看到只移动了 lmls，而同名的 bols 和 cangls 并没有移动("-v" 选项用于显示移动过程)
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h3 id="改名" tabindex="-1"> 改名</h3>
<p>如果源文件和目标文件在同一目录中，那就是改名。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> bols lmls</span></span>
<span>#把 bols 改名为 lmls
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>目录也可以按照同样的方法改名。</p>
<h3 id="显示移动过程" tabindex="-1"> 显示移动过程</h3>
<p>如果我们想要知道在移动过程中到底有哪些文件进行了移动，则可以使用 <code>-v</code> 选项来查看详细的移动信息。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>touch</span> test1.txt test2.txt test3.txt</span></span>
<span>#建立三个测试文件
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> -v *.txt /tmp</span></span>
<span>"test1.txt" -> "/tmp/test1.txt"
"test2.txt" -> "/tmp/test2.txt"
"test3.txt" -> "/tmp/test3.txt"
#加入"-v"选项，可以看到有哪些文件进行了移
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>环境变量</title>
      <link>https://shimonzhan.com/code/linux/command/path.html</link>
      <guid>https://shimonzhan.com/code/linux/command/path.html</guid>
      <source url="https://shimonzhan.com/rss.xml">环境变量</source>
      <category>Linux</category>
      <pubDate>Wed, 20 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="环境变量" tabindex="-1"> 环境变量</h1>
<h2 id="变量" tabindex="-1"> 变量</h2>
<p>变量是计算机系统用于保存可变值的数据类型，我们可以直接通过变量名称来提取到对应的变量值。在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的家目录 (HOME)、邮件存放位置 (MAIL)等。
值得一提的是，Linux 系统中环境变量的名称一般都是大写的，这是一种约定俗成的规范。</p>
<p>我们可以使用 env 命令来查看到 Linux 系统中所有的环境变量，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>env</span></span></span>
<span>ORBIT_SOCKETDIR=/tmp/orbit-root
HOSTNAME=livecd.centos
GIO_LAUNCHED_DESKTOP_FILE_PID=2065
TERM=xterm
SHELL=/bin/bash
......
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>Linux 系统能够正常运行并且为用户提供服务，需要数百个环境变量来协同工作，但是，我们没有必要逐一学习每个变量。常见变量见下表:</p>
<table>
<thead>
<tr>
<th>环境变量名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HOME</td>
<td>用户的主目录(也称家目录)</td>
</tr>
<tr>
<td>SHELL</td>
<td>用户使用的 Shell 解释器名称</td>
</tr>
<tr>
<td>PATH</td>
<td>定义命令行解释器搜索用户执行命令的路径</td>
</tr>
<tr>
<td>EDITOR</td>
<td>用户默认的文本解释器</td>
</tr>
<tr>
<td>RANDOM</td>
<td>生成一个随机数字</td>
</tr>
<tr>
<td>LANG</td>
<td>系统语言、语系名称</td>
</tr>
<tr>
<td>HISTSIZE</td>
<td>输出的历史命令记录条数</td>
</tr>
<tr>
<td>HISTFILESIZE</td>
<td>保存的历史命令记录条数</td>
</tr>
<tr>
<td>PS1</td>
<td>Bash 解释器的提示符</td>
</tr>
<tr>
<td>MAIL</td>
<td>邮件保存路径</td>
</tr>
</tbody>
</table>
<p>Linux 作为一个多用户多任务的操作系统，能够为每个用户提供独立的、合适的工作运行环境，因此，一个相同的环境变量会因为用户身份的不同而具有不同的值。</p>
<p>例如，使用下述命令来查看 <code>HOME</code> 变量在不同用户身份下都有哪些值:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$HOME</span></span></span>
<span>/root
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>su</span> - user1  <span>&lt;</span>--切换到 user1 用户身份</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>echo</span> <span>$HOME</span></span></span>
<span>/home/user1
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>这里的 <code>su</code> 命令可以临时切换用户身份，此命令的具体用法会在后续章节做详细介绍。</p>
<p>其实，环境变量是由固定的变量名与用户或系统设置的变量值两部分组成的，我们完全可以自行创建环境变量来满足工作需求。例如，设置一个名称为 <code>WORKDIR</code> 的环境变量，方便用户更轻松地进入一个层次较深的目录，执行命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mkdir</span> /home/work1</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>WORKDIR</span><span>=</span>/home/work1</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>pwd</span></span></span>
<span>/home/work1
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div></div></div><p>但是，这样的环境变量不具有全局性，作用范围也有限，默认情况下不能被其他用户使用。如果工作需要，可以使用 <code>export</code> 命令将其提升为全局环境变量，这样其他用户就可以使用它了:</p>
<div><pre><code><span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>su</span> user1  <span>&lt;</span>-- 切换到 user1，发现无法使用 WORKDIR 自定义变量</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>echo</span> <span>$WORKDIR</span></span></span>

<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>exit</span> <span>&lt;</span>--退出user1身份</span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>export</span> WORKDIR</span></span>
<span><span><span>[root@localhost work1]</span></span><span>#</span> <span><span>su</span> user1</span></span>
<span><span><span>[user1@localhost ~]</span></span><span>$</span> <span><span>cd</span> <span>$WORKDIR</span></span></span>
<span><span><span>[user1@localhost work1]</span></span><span>$</span> <span><span>pwd</span></span></span>
<span>/home/work1
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><h2 id="path" tabindex="-1"> path</h2>
<p>在讲解 PATH 环境变量之前，首先介绍一下 <code>which</code> 命令，它用于查找某个命令所在的绝对路径。例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>rm</span></span></span>
<span>/bin/rm
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>rmdir</span></span></span>
<span>/bin/rmdir
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>which</span> <span>ls</span></span></span>
<span>alias ls='ls --color=auto'
        /bin/ls
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，<code>ls</code> 是一个相对特殊的命令，它使用 alias 命令做了别名，也就是说，我们常用的 <code>ls</code> 实际上执行的是 <code>ls --color=auto</code>。</p>
<p>通过使用 <code>which</code> 命令，可以查找各个外部命令(和 Shell 内置命令相对)所在的绝对路径。学到这里，读者是否有这样一个疑问，为什么前面在使用 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，无论当前位于哪个目录，都可以直接使用，而无需指明命令的执行文件所在的位置 (绝对路径) 呢? 其实，这是 PATH 环境变量在起作用。</p>
<p>首先，执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$PATH</span></span></span>
<span>/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin
</span></code></pre><div aria-hidden="true"><div></div><div></div></div></div><p>这里的 <code>echo</code> 命令用来输出 PATH 环境变量的值(这里的 <code>$</code> 是 PATH 的前缀符号)，PATH 环境变量的内容是由一堆目录组成的，各目录之间用冒号 <code>:</code> 隔开。当执行某个命令时，Linux 会依照 PATH 中包含的目录依次搜寻该命令的可执行文件，一旦找到，即正常执行；反之，则提示无法找到该命令。
如果在 PATH 包含的目录中，有多个目录都包含某命令的可执行文件，那么会执行先搜索到的可执行文件。</p>
<p>从执行结果中可以看到，<code>/bin</code> 目录已经包含在 PATH 环境变量中，因此在使用类似 <code>rm</code>、<code>rmdir</code>、<code>ls</code> 等命令时，即便直接使用其命令名，Linux 也可以找到该命令。</p>
<p>为了印证以上观点，下面举个反例，如果我们将 <code>ls</code> 命令移动到 <code>/root</code> 目录下，由于 PATH 环境变量中没有包含此目录，所有当直接使用 <code>ls</code> 命令名执行时，Linux 将无法找到此命令的可执行文件，并提示 <code>No such file or directory</code>，示例命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> /bin/ls /root</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>bash: /bin/ls: No such file or directory
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>此时，如果仍想使用 <code>ls</code> 命令，有 2 种方法，一种是直接将 <code>/root</code> 添加到 PATH 环境变量中，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span><span>PATH</span></span><span>=</span><span>$PATH</span>:/root</span></span>
<span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>echo</span> <span>$PATH</span></span></span>
<span>/usr/local/sbin:/usr/sbin:/usr/local/bin:/usr/bin:/bin:/root/bin:/root
</span><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>ls</span></span></span>
<span>Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>注意，这种方式只是临时有效，一旦退出下次再登陆的时候，<code>$PATH</code> 就恢复成了默认值。</p>
<p>另一种方法是以绝对路径的方式使用此命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span>/root/ls</span></span>
<span>Desktop    Downloads    Music    post-install     Public    Videos
Documents  ls           Pictures post-install.org Templates
</span></code></pre><div aria-hidden="true"><div></div><div></div><div></div></div></div><p>为了不影响系统的正常使用，强烈建议大家将移动后的 <code>ls</code> 文件还原，命令如下:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>mv</span> /root/ls /bin</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>其他指令</title>
      <link>https://shimonzhan.com/code/linux/command/temp.html</link>
      <guid>https://shimonzhan.com/code/linux/command/temp.html</guid>
      <source url="https://shimonzhan.com/rss.xml">其他指令</source>
      <category>Linux</category>
      <pubDate>Tue, 19 Apr 2022 07:13:07 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="其他指令" tabindex="-1"> 其他指令</h1>
<h2 id="文件" tabindex="-1"> 文件</h2>
<h3 id="创建文件" tabindex="-1"> 创建文件</h3>
<ul>
<li>touch</li>
<li>vi</li>
</ul>
<h3 id="编辑文件" tabindex="-1"> 编辑文件</h3>
<ul>
<li>vi</li>
</ul>
<div><p>提示</p>
<p>使用 vi 命令后，默认进入浏览模式。</p>
<p>按 <code>i</code> 进入 insert 模式， 按 <code>ESC</code> 退出。</p>
<ol>
<li>
<p>命令模式下，输入: <code>/</code> 字符串</p>
<p>比如搜索 user, 输入 <code>/user</code></p>
<p>按下回车之后，可以看到 vim 已经把光标移动到该字符处和高亮了匹配的字符串</p>
</li>
<li>
<p>查看下一个匹配，按下 n(小写 n)</p>
</li>
<li>
<p>跳转到上一个匹配，按下 N(大写 N)</p>
</li>
<li>
<p>搜索后，我们打开别的文件，发现也被高亮了，怎么关闭高亮?</p>
</li>
</ol>
<p>命令模式下，输入 <code>:nohlsearch</code> 也可以 <code>:set nohlsearch</code>；当然，可以简写，<code>noh</code> 或者 <code>set noh</code>。</p>
</div>
<h3 id="重命名文件" tabindex="-1"> 重命名文件</h3>
<ul>
<li>rename</li>
</ul>
<h3 id="移动文件" tabindex="-1"> 移动文件</h3>
<ul>
<li>mv</li>
</ul>
<div><p>提示</p>
<p>该命令也可用于重命名</p>
</div>
<h3 id="文件浏览" tabindex="-1"> 文件浏览</h3>
<ul>
<li>pwd: 查看当前目录</li>
<li>cd: 移动当前目录</li>
<li>ls: 列出当前目录
<ul>
<li><code>-l</code>: 以表格列出当前目录详情</li>
<li><code>-a</code>: 包括隐藏文件</li>
</ul>
</li>
</ul>
<h2 id="权限" tabindex="-1"> 权限</h2>
<ul>
<li>chmod: 查看/更改文件或文件夹权限</li>
</ul>
<p><code>chmod</code> 是权限管理命令 <code>change the permissions mode of a file</code> 的缩写。</p>
<p><code>u</code> 代表所有者，<code>x</code> 代表执行权限。<code>+</code> 表示增加权限。</p>
<div><pre><code><span>chmod</span> u+x file.sh
</code></pre><div aria-hidden="true"><div></div></div></div><div><pre><code><span>chmod</span> 权限数字 文件名
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>
<p>r 读权限 read 4</p>
</li>
<li>
<p>w 写权限 write 2</p>
</li>
<li>
<p>x 操作权限 execute 1</p>
</li>
</ul>
<div><pre><code><span>chmod</span> <span>600</span> id_rsa
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="用户组" tabindex="-1"> 用户组</h2>
<h3 id="管理用户组" tabindex="-1"> 管理用户组</h3>
<p>groupadd groupname 　　添加用户组</p>
<p>groupdel groupname 　　删除用户组</p>
<p>##　添加用户到用户组
将一个用户添加到用户组中，千万不能直接用:</p>
<div><pre><code><span>usermod</span> -G groupA
</code></pre><div aria-hidden="true"><div></div></div></div><p>这样做会使您离开其他用户组，仅仅做为 这个用户组 groupA 的成员。</p>
<p>应该用 加上 <code>-a</code> 选项:</p>
<div><pre><code><span>usermod</span> -a -G groupA user
<span>(</span>FC4: <span>usermod</span> -G groupA,groupB,groupC user<span>)</span>
</code></pre><div aria-hidden="true"><div></div><div></div></div></div><p><code>-a</code> 代表 <code>append</code>， 也就是 将自己添加到 用户组 groupA 中，而不必离开 其他用户组。</p>
<p>命令的所有的选项，及其含义:</p>
<div><pre><code>Options:

-c, –comment COMMENT new value of the GECOS field
-d, –home HOME_DIR new home directory for the user account
-e, –expiredate EXPIRE_DATE set account expiration date to EXPIRE_DATE
-f, –inactive INACTIVE set password inactive after expiration
to INACTIVE
-g, –gid GROUP force use GROUP as new primary group
-G, –groups GROUPS new list of supplementary GROUPS
-a, –append append the user to the supplemental GROUPS
mentioned by the -G option without removing
him/her from other groups
-h, –help display this help message and exit
-l, –login NEW_LOGIN new value of the login name
-L, –lock lock the user account
-m, –move-home move contents of the home directory to the new
location (use only with -d)
-o, –non-unique allow using duplicate (non-unique) UID
-p, –password PASSWORD use encrypted password for the new password
-s, –shell SHELL new login shell for the user account
-u, –uid UID new UID for the user account
-U, –unlock unlock the user account
</code></pre><div aria-hidden="true"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div><p>查看用户所属的组使用命令:</p>
<div><pre><code><span>groups</span> user
</code></pre><div aria-hidden="true"><div></div></div></div><p>或者查看文件:</p>
<div><pre><code><span>cat</span> /etc/group
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="用户" tabindex="-1"> 用户</h2>
<p><code>cat /etc/passwd</code> 查看用户列表</p>
<h3 id="添加用户" tabindex="-1"> 添加用户</h3>
<div><pre><code><span>sudo</span> <span>useradd</span> <span>[</span>用户名<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>创建新用户: useradd</p>
<p><code>-d</code> 指定目录文件夹</p>
<p><code>-m</code> 新账号名</p>
<p>如:</p>
<div><pre><code><span>useradd</span> -d /www/abc -m abc
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li><code>-c</code>: comment 指定一段注释性描述。</li>
<li><code>-d</code>: 目录 指定用户主目录，如果此目录不存在，则同时使用-m 选项，可以创建主目录。</li>
<li><code>-g</code>: 用户组 指定用户所属的用户组。</li>
<li><code>-G</code>: 用户组，用户组 指定用户所属的附加组。</li>
<li><code>-s</code>: Shell 文件 指定用户的登录 Shell。</li>
<li><code>-u</code>: 用户号 指定用户的用户号，如果同时有-o 选项，则可以重复使用其他用户的标识号。</li>
</ul>
<h3 id="设置密码" tabindex="-1"> 设置密码</h3>
<div><pre><code><span>sudo</span> <span>passwd</span> <span>[</span>用户名<span>]</span>
</code></pre><div aria-hidden="true"><div></div></div></div><h2 id="删除用户" tabindex="-1"> 删除用户</h2>
<div><pre><code><span>userdel</span> abc
</code></pre><div aria-hidden="true"><div></div></div></div><div><p>提示</p>
<p>使用 userdel abc 命令删除该用户时，并不能删除该用户的所有信息，只是删除了/etc/passwd、/etc/shadow、/etc/group/、/etc/gshadow 四个文件里的该账户和组的信息。默认情况下创建一个用户账号，会创建一个家目录和一个用户邮箱(在/var/spool/mail 目录以用户名命名)</p>
<p>所以建议使用 <code>userdel -r abc</code> 删除用户。</p>
</div>
<h2 id="服务管理" tabindex="-1"> 服务管理</h2>
<p>Linux 服务管理两种方式 service 和 systemctl</p>
<ol>
<li>
<p>service 命令</p>
<p>service 命令其实是去 <code>/etc/init.d</code> 目录下，去执行相关程序</p>
<ul>
<li>service 命令启动 redis 脚本</li>
</ul>
<div><pre><code><span>service</span> redis start
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>直接启动 redis 脚本</li>
</ul>
<div><pre><code>/etc/init.d/redis start
</code></pre><div aria-hidden="true"><div></div></div></div><ul>
<li>开机自启动</li>
</ul>
<div><pre><code>update-rc.d redis defaults
</code></pre><div aria-hidden="true"><div></div></div></div><p>其中脚本需要我们自己编写</p>
</li>
<li>
<p>systemctl 命令</p>
<p>systemd 是 Linux 系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。</p>
<p>systemd 对应的进程管理命令是 systemctl</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>文件</title>
      <link>https://shimonzhan.com/code/linux/file/</link>
      <guid>https://shimonzhan.com/code/linux/file/</guid>
      <source url="https://shimonzhan.com/rss.xml">文件</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="目录" tabindex="-1"> 目录</h2>
<ul>
<li>
<p><a href="/code/linux/file/file.html">Linux 文件</a></p>
</li>
<li>
<p><a href="/code/linux/file/dir.html">Linux 目录</a></p>
</li>
<li>
<p><a href="/code/linux/file/mount.html">挂载</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录</title>
      <link>https://shimonzhan.com/code/linux/file/dir.html</link>
      <guid>https://shimonzhan.com/code/linux/file/dir.html</guid>
      <source url="https://shimonzhan.com/rss.xml">目录</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="linux-文件目录结构" tabindex="-1"> Linux 文件目录结构</h2>
<p>学习 Linux，不仅限于学习各种命令，了解整个 Linux 文件系统的目录结构以及各个目录的功能同样至关重要。</p>
<p>使用 Linux 时，通过命令行输入 <code>ls -l /</code> 可以看到，在 Linux 根目录 (/) 下包含很多的子目录(称为一级目录)，例如 <code>bin</code>、<code>boot</code>、<code>dev</code> 等。同时，各一级目录下还含有很多子目录(称为二级目录)，比如 <code>/bin/bash</code>、<code>/bin/ed</code> 等。Linux 文件系统目录总体呈现树形结构，<code>/</code> 根目录就相当于树根。</p>
<p>由于 Linux 系统免费开源，使得 Linux 发行版本有很多，利用 Linux 开发产品的团队也有很多，如果任由每个人都按照自己的想法来配置 Linux 系统文件目录，后期可能会产生诸多的管理问题。试想，如果您进入一家公司，所用 Linux 系统的文件目录结构与所学的完全不同，实在令人头疼。</p>
<p>为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准。</p>
<div><p>提示</p>
<p>FHS(Filesystem Hierarchy Standard)，文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录(<code>/usr</code> 和 <code>/var</code>)的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件。</p>
</div>
<h2 id="linux-根目录" tabindex="-1"> Linux 根目录(/)</h2>
<p>FHS 认为，Linux 系统的根目录 (/) 最为重要(没有之一)，其原因有以下 2 点:</p>
<ul>
<li>所有目录都是由根目录衍生出来的；</li>
<li>根目录与系统的开机、修复、还原密切相关；</li>
</ul>
<p>因此，根目录必须包含开机软件、核心文件、开机所需程序、函数库、修复系统程序等文件。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/bin/</td>
<td>存放系统命令，普通用户和 root 都可以执行。放在 <code>/bin</code> 下的命令在单用户模式下也可以执行</td>
</tr>
<tr>
<td>/boot/</td>
<td>系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序(grub)文件等</td>
</tr>
<tr>
<td>/dev/</td>
<td>设备文件保存位置</td>
</tr>
<tr>
<td>/etc/</td>
<td>配置文件保存位置。系统内所有采用默认安装方式(rpm 安装)的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等</td>
</tr>
<tr>
<td>/home/</td>
<td>普通用户的主目录(也称为家目录)。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 <code>/home/</code> 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 <code>/home/liming</code></td>
</tr>
<tr>
<td>/lib/</td>
<td>系统调用的函数库保存位置</td>
</tr>
<tr>
<td>/media/</td>
<td>挂载目录。系统建议用来挂载媒体设备，如软盘和光盘</td>
</tr>
<tr>
<td>/mnt/</td>
<td>挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区</td>
</tr>
<tr>
<td>/misc/</td>
<td>挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 <code>/media/</code>、<code>/mnt/</code>、<code>/misc/</code>，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 /mnt/，所以养成了在 <code>/mnt/</code> 下建立不同目录挂载不同设备的习惯，如 <code>/mnt/cdrom/</code> 挂载光盘、<code>/mnt/usb/</code> 挂载 U 盘，都是可以的</td>
</tr>
<tr>
<td>/opt/</td>
<td>第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 <code>/usr/local/</code> 目录中，也就是说，<code>/usr/local/</code> 目录也可以用来安装软件</td>
</tr>
<tr>
<td>/root/</td>
<td>root 的主目录。普通用户主目录在 <code>/home/</code> 下，root 主目录直接在“/”下</td>
</tr>
<tr>
<td>/sbin/</td>
<td>保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看</td>
</tr>
<tr>
<td>/srv/</td>
<td>服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据</td>
</tr>
<tr>
<td>/tmp/</td>
<td>临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空</td>
</tr>
</tbody>
</table>
<p>FHS 针对根目录中包含的子目录仅限于上表，但除此之外，Linux 系统根目录下通常还包含下表中的几个一级目录。</p>
<table>
<thead>
<tr>
<th>一级目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/lost+found/</td>
<td>当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，<code>/lost+found</code> 就是根分区的备份恢复目录，<code>/boot/lost+found</code> 就是 <code>/boot</code> 分区的备份恢复目录</td>
</tr>
<tr>
<td>/proc/</td>
<td>虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 <code>/proc/cpuinfo</code> 是保存 CPU 信息的，<code>/proc/devices</code> 是保存设备驱动的列表的，<code>/proc/filesystems</code> 是保存文件系统列表的，<code>/proc/net</code> 是保存网络协议信息的......</td>
</tr>
<tr>
<td>/sys/</td>
<td>虚拟文件系统。和 <code>/proc/</code> 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息</td>
</tr>
</tbody>
</table>
<h2 id="linux-usr-目录" tabindex="-1"> Linux /usr 目录</h2>
<p>usr(注意不是 user)，全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 <code>/usr</code> 目录下的各子目录中，而不是为他们的产品创建单独的目录。</p>
<p>Linux 系统中，所有系统默认的软件都存储在 <code>/usr</code> 目录下，<code>/usr</code> 目录类似 Windows 系统中 <code>C:\Windows\</code> + <code>C:\Program files\</code> 两个目录的综合体。</p>
<p>FHS 建议，<code>/usr</code> 目录应具备下表所示的子目录。</p>
<table>
<thead>
<tr>
<th>子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/usr/bin/</td>
<td>存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行</td>
</tr>
<tr>
<td>/usr/sbin/</td>
<td>存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。</td>
</tr>
<tr>
<td>/usr/lib/</td>
<td>应用程序调用的函数库保存位置</td>
</tr>
<tr>
<td>/usr/XllR6/</td>
<td>图形界面系统保存位置</td>
</tr>
<tr>
<td>/usr/local/</td>
<td>手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置</td>
</tr>
<tr>
<td>/usr/share/</td>
<td>应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录</td>
</tr>
<tr>
<td>/usr/src/</td>
<td>源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 <code>/usr/local/src/</code> 目录中，把内核源码保存到 <code>/usr/src/linux/</code> 目录中</td>
</tr>
<tr>
<td>/usr/include</td>
<td>C/C++ 等编程语言头文件的放置目录</td>
</tr>
</tbody>
</table>
<h2 id="linux-var-目录" tabindex="-1"> Linux /var 目录</h2>
<p><code>/var</code> 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下建议包含如下表所示的这些子目录。</p>
<table>
<thead>
<tr>
<th>/var 子目录</th>
<th>功能(作用)</th>
</tr>
</thead>
<tbody>
<tr>
<td>/var/lib/</td>
<td>程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 <code>/var/lib/mysql/</code> 目录中</td>
</tr>
<tr>
<td>/var/log/</td>
<td>登陆文件放置的目录，其中所包含比较重要的文件如 <code>/var/log/messages</code>, <code>/var/log/wtmp</code> 等。</td>
</tr>
<tr>
<td>/var/run/</td>
<td>一些服务和程序运行后，它们的 PID(进程 ID)保存位置</td>
</tr>
<tr>
<td>/var/spool/</td>
<td>里面主要都是一些临时存放，随时会被用户所调用的数据，例如 <code>/var/spool/mail/</code> 存放新收到的邮件，<code>/var/spool/cron/</code> 存放系统定时任务。</td>
</tr>
<tr>
<td>/var/www/</td>
<td>RPM 包安装的 Apache 的网页主目录</td>
</tr>
<tr>
<td>/var/nis 和/var/yp</td>
<td>NIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录</td>
</tr>
<tr>
<td>/var/tmp</td>
<td>一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除</td>
</tr>
</tbody>
</table>
<p>根据以上各表列举的各目录及作用，如果我们要做一些实验和练习，需要创建一些临时文件，应该保存在哪里呢?</p>
<p>答案是用户的主目录或 <code>/tmp/</code> 临时目录。但是要小心有些目录中不能直接修改和保存数据，比如 <code>/proc/fn/sys/</code> 目录，因为它们是保存在内存中的，如果在这里写入数据，那么您的内存会越来越小，直至死机；<code>/boot/</code> 目录也不能保存额外数据，因为 <code>/boot/</code> 目录会单独分区作为启动分区，如果没有空闲空间，则会导致系统不能正常启动。</p>
<p>总之，Linux 要在合理的目录下进行操作和修改。</p>
<div><p>注意</p>
<p>目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由 <code>/</code> 来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
</div>
<h2 id="硬件设备名称" tabindex="-1"> 硬件设备名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI/SATA/U 盘</td>
<td><code>/dev/sd[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>文件</title>
      <link>https://shimonzhan.com/code/linux/file/file.html</link>
      <guid>https://shimonzhan.com/code/linux/file/file.html</guid>
      <source url="https://shimonzhan.com/rss.xml">文件</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="文件系统" tabindex="-1"> 文件系统</h2>
<p>目录就相当于 Windows 中的文件夹，目录中存放的既可以是文件，也可以是其他的子目录，而文件中存储的是真正的信息。</p>
<p>文件系统的最顶层是由根目录开始的，系统使用“<code>/</code>”来表示根目录，在根目录之下的既可以是目录，也可以是文件，而每一个目录中又可以包含(子)目录或文件。如此反复就可以构成一个庞大的文件系统。
其实，使用这种树状、具有层次的文件结构主要目的是方便文件系统的管理和维护，想象一下，如果所有的文件都放在一个目录下，其文件系统的管理和维护将变成一场噩梦。</p>
<p>现实中也有许多类似的例子，例如在整个行政管理体制中，村民就相当于文件，他们住在一个村庄中，村庄就是存储村民的目录。许多村又组成了个乡，这个乡就相当于存储村的目录，依此类推，最终就构建出了一个庞大的行政区域管理结构图。</p>
<p>注意，目录名或文件名都是区分大小写的，如 dog、DOG 和 Dog 为 3 个不同的目录或文件。完整的目录或文件路径是由一连串的目录名所组成的，其中每一个目录由“/”来分隔。如 cat 的完整路径是 <code>/home/cat</code>。</p>
<p>在文件系统中，有两个特殊的目录，一个是用户所在的工作目录，即当前目录，可用一个点“<code>.</code>”表示；另一个是当前目录的上一层目录，也叫父目录，用两个点“<code>..</code>”表示。</p>
<p>如果一个目录或文件名是以一个点开始，就表示这个目录或文件是一个隐藏目录或文件。即以默认方式査找(后续会讲查找命令)时，不显示该目录或文件。</p>
<p>为了方便管理和维护，Linux 系统采用了文件系统层次标准，也称为 FHS 标准，它规定了根目录下各个目录应该存在哪些类型的文件(或子目录)，比如说，在 <code>/bin</code> 和 <code>/sbin</code> 目录中存放的应该是可执行文件，有关各个目录存放文件的类型，已在《Linux 文件目录结构一览表》一节中作了详解介绍，这里不再过多赘述。</p>
<h2 id="文件" tabindex="-1"> 文件</h2>
<p>虽然从名称上不容易分辨，但是可以从颜色上进行区分。一般情况下，Linux 用蓝色代表目录，其他颜色则表示是文件。</p>
<p>和 Linux 不同，Windows 下带有 <code>&lt;DIR&gt;</code> 标记的行或使用中括号 <code>[]</code> 括起来的名称就是目录，其他的则是文件。</p>
<p>不仅如此，Linux 中还可以用不同的颜色来区分不同种类的文件，例如绿色代表可执行文件、红色代表压缩文件、浅绿色代表链接文件、白色代表其他文件、黄色代表设备文件等。</p>
<p>但是，不同颜色所代表的文件类型不一定是这样，更准确的对应方式还取决于配置文件 <code>/etc/DIR_COLORS</code> 中的规定。因此，如果想详细了解不同文件类型所对应的颜色，可以使用 <code>man</code> 命令，例如:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>man</span> dir_colors</span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>注意，有些 Linux 发行版单独使用 <code>ls</code> 命令，无法显示出带有不同颜色的文件和目录，此时就需要使用 <code>ls --color=auto</code> 命令，明确令其使用颜色来区分文件类型。</p>
<p>在此基础上，如果不想每次使用 <code>ls</code> 命令时，都显式附带 <code>--color=auto</code>，可以执行如下命令:</p>
<div><pre><code><span><span><span>[root@localhost ~]</span></span><span>#</span> <span><span>alias</span> <span>ls</span> <span>=</span> <span>'ls --color=auto'</span></span></span>
</code></pre><div aria-hidden="true"><div></div></div></div><p>通过给 <code>ls --color==auto</code> 这个整体设置一个别名 <code>ls</code>，这样当后续使用 <code>ls</code> 命令时，就等同于执行 <code>ls --color=auto</code> 命令。</p>
<p>同时，如果想使这个设置永远生效，还需要将其添加到 <code>/etc/bashrc</code> 或 <code>/home/&lt;user&gt;/.bashrc</code> 文件中，前者对所有用户有效，而后者仅对用户 <code>&lt;user&gt;</code> 有效。</p>
<p>其实，那些默认提供颜色功能的 Linux 发行版，也是通过这个方法开启的功能。</p>
<p>当然，通过颜色来区分文件类型，难免有些牵强，对于颜色不太敏感的读者来说，很容易搞错。Linux 中精确判断文件类型的方法，是通过文件本身所具有的属性进行判断。</p>
<p>通过 <code>ls -l</code> 命令，我们就可以查看当前目录下所有文件和目录各自的属性</p>
<h2 id="命名规则" tabindex="-1"> 命名规则</h2>
<ul>
<li>除了字符“/”之外，所有的字符都可以使用，但是要注意，在目录名或文件名中，使用某些特殊字符并不是明智之举。例如，在命名时应避免使用 <code>&lt;</code>、<code>&gt;</code>、<code>?</code>、<code>*</code> 和非打印字符等。如果一个文件名中包含了特殊字符，例如空格，那么在访问这个文件时就需要使用引号将文件名括起来。</li>
<li>目录名或文件名的长度不能超过 255 个字符。</li>
<li>目录名或文件名是区分大小写的。如 DOG、dog、Dog 和 DOg ，是互不相同的目录名或文件名，但使用字符大小写来区分不同的文件或目录，也是不明智的。</li>
</ul>
<h2 id="不同字符对应的文件类型" tabindex="-1"> 不同字符对应的文件类型</h2>
<table>
<thead>
<tr>
<th>第一个字符</th>
<th>文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>-</td>
<td>普通文件，包括纯文本文件、二进制文件、各种压缩文件等。</td>
</tr>
<tr>
<td>d</td>
<td>目录，类似 Windows 系统中的文件夹。</td>
</tr>
<tr>
<td>b</td>
<td>块设备文件，就是保存大块数据的设备，比如最常见的硬盘。</td>
</tr>
<tr>
<td>c</td>
<td>字符设备文件，例如键盘、鼠标等。</td>
</tr>
<tr>
<td>s</td>
<td>套接字文件，通常用在网络数据连接，可以启动一个程序开监听用户的要求，用户可以通过套接字进行数据通信。</td>
</tr>
<tr>
<td>p</td>
<td>管道文件，其主要作用是解决多个程序同时存取一个文件所造成的错误。</td>
</tr>
<tr>
<td>l</td>
<td>链接文件，类似 Windows 系统中的快捷方式。</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 挂载</title>
      <link>https://shimonzhan.com/code/linux/file/mount.html</link>
      <guid>https://shimonzhan.com/code/linux/file/mount.html</guid>
      <source url="https://shimonzhan.com/rss.xml">Linux 挂载</source>
      <category>Linux</category>
      <pubDate>Sun, 17 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-挂载" tabindex="-1"> Linux 挂载</h1>
<p>前面讲过，Linux 系统中“一切皆文件”，所有文件都放置在以根目录为树根的树形目录结构中。在 Linux 看来，任何硬件设备也都是文件，它们各有自己的一套文件系统(文件目录结构)。</p>
<p>因此产生的问题是，当在 Linux 系统中使用这些硬件设备时，只有将 Linux 本身的文件目录与硬件设备的文件目录合二为一，硬件设备才能为我们所用。合二为一的过程称为“挂载”。</p>
<p>如果不挂载，通过 Linux 系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到。</p>
<p>挂载，指的就是将设备文件中的顶级目录连接到 Linux 根目录下的某一目录(最好是空目录)，访问此目录就等同于访问设备文件。</p>
<p>纠正一个误区，并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录。</p>
<p>举个例子，我们想通过命令行访问某个 U 盘中的数据，我们要在根目录下新建一个目录 <code>/sdb-u</code>，通过挂载命令将 U 盘文件系统挂载到此目录，</p>
<p>前面讲过，根目录下的 <code>/dev/</code> 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统也确实会给 U 盘分配一个目录文件(比如 sdb1)，就位于 <code>/dev/</code> 目录下 (<code>/dev/sdb1</code>)，但无法通过 <code>/dev/sdb1/</code> 直接访问 U 盘数据，访问此目录只会提供给您此设备的一些基本信息(比如容量)。</p>
<p>总之，Linux 系统使用任何硬件设备，都必须将设备文件与已有目录文件进行挂载。</p>
<h2 id="linux-硬件设备文件名称" tabindex="-1"> Linux 硬件设备文件名称</h2>
<table>
<thead>
<tr>
<th>硬件设备</th>
<th>文件名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>IDE 设备</td>
<td><code>/dev/hd\[a-d]</code>，现在的 IDE 设备已经很少见了，因此一般的硬盘设备会以 <code>/dev/sd</code> 开头。</td>
</tr>
<tr>
<td>SCSI / SATA / U 盘</td>
<td><code>/dev/sd\[a-p]</code>，一台主机可以有多块硬盘，因此系统采用 a~p 代表 16 块不同的硬盘。</td>
</tr>
<tr>
<td>软驱</td>
<td><code>/dev/fd\[0-1]</code></td>
</tr>
<tr>
<td>打印机</td>
<td><code>/dev/lp\[0-15]</code></td>
</tr>
<tr>
<td>光驱</td>
<td><code>/dev/cdrom</code></td>
</tr>
<tr>
<td>鼠标</td>
<td><code>/dev/mouse</code></td>
</tr>
<tr>
<td>磁带机</td>
<td><code>/dev/st0</code> 或 <code>/dev/ht0</code></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 简介</title>
      <link>https://shimonzhan.com/code/linux/intro/</link>
      <guid>https://shimonzhan.com/code/linux/intro/</guid>
      <source url="https://shimonzhan.com/rss.xml">Linux 简介</source>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="linux-简介" tabindex="-1"> Linux 简介</h1>
<ul>
<li>
<p><a href="/code/linux/intro/intro.html">Linux 介绍</a></p>
</li>
<li>
<p><a href="/code/linux/intro/history.html">Linux 历史</a></p>
</li>
<li>
<p><a href="/code/linux/intro/language.html">Linux 编写语言</a></p>
</li>
<li>
<p><a href="/code/linux/intro/advantage.html">Linux 优势</a></p>
</li>
<li>
<p><a href="/code/linux/intro/desktop.html">Linux 桌面环境</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>